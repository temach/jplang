var mxClient = {
  VERSION : "20.3.0",
  IS_IE : null != navigator.userAgent && 0 <= navigator.userAgent.indexOf("MSIE"),
  IS_IE11 : null != navigator.userAgent && !!navigator.userAgent.match(/Trident\/7\./),
  IS_EDGE: null != navigator.userAgent && !!navigator.userAgent.match(/Edge\//),
  IS_EM : "spellcheck" in document.createElement("textarea") && 8 == document.documentMode,
  VML_PREFIX : "v",
  OFFICE_PREFIX : "o",
  IS_NS : null != navigator.userAgent && (0 <= navigator.userAgent.indexOf("Mozilla/") && (0 > navigator.userAgent.indexOf("MSIE") && 0 > navigator.userAgent.indexOf("Edge/"))),
  IS_OP : null != navigator.userAgent && (0 <= navigator.userAgent.indexOf("Opera/") || 0 <= navigator.userAgent.indexOf("OPR/")),
  IS_OT : null != navigator.userAgent && (0 <= navigator.userAgent.indexOf("Presto/") && (0 > navigator.userAgent.indexOf("Presto/2.4.") && (0 > navigator.userAgent.indexOf("Presto/2.3.") && (0 > navigator.userAgent.indexOf("Presto/2.2.") && (0 > navigator.userAgent.indexOf("Presto/2.1.") && (0 > navigator.userAgent.indexOf("Presto/2.0.") && 0 > navigator.userAgent.indexOf("Presto/1."))))))),
  IS_SF : /Apple Computer, Inc/.test(navigator.vendor),
  IS_ANDROID : 0 <= navigator.appVersion.indexOf("Android"),
  IS_IOS : /iP(hone|od|ad)/.test(navigator.platform) || navigator.userAgent.match(/Mac/) && (navigator.maxTouchPoints && 2 < navigator.maxTouchPoints),
  IS_WEBVIEW : /((iPhone|iPod|iPad).*AppleWebKit(?!.*Version)|; wv)/i.test(navigator.userAgent),
  IS_GC : /Google Inc/.test(navigator.vendor),
  IS_CHROMEAPP : null != window.chrome && (null != chrome.app && null != chrome.app.runtime),
  IS_FF : "undefined" !== typeof InstallTrigger,
  IS_MT : 0 <= navigator.userAgent.indexOf("Firefox/") && (0 > navigator.userAgent.indexOf("Firefox/1.") && 0 > navigator.userAgent.indexOf("Firefox/2.")) || (0 <= navigator.userAgent.indexOf("Iceweasel/") && (0 > navigator.userAgent.indexOf("Iceweasel/1.") && 0 > navigator.userAgent.indexOf("Iceweasel/2.")) || (0 <= navigator.userAgent.indexOf("SeaMonkey/") && 0 > navigator.userAgent.indexOf("SeaMonkey/1.") || 0 <= navigator.userAgent.indexOf("Iceape/") && 0 > navigator.userAgent.indexOf("Iceape/1."))),
  IS_SVG : "MICROSOFT INTERNET EXPLORER" != navigator.appName.toUpperCase(),
  NO_FO : !document.createElementNS || ("[object SVGForeignObjectElement]" !== document.createElementNS("http://www.w3.org/2000/svg", "foreignObject").toString() || 0 <= navigator.userAgent.indexOf("Opera/")),
  IS_WIN : 0 < navigator.appVersion.indexOf("Win"),
  IS_MAC : 0 < navigator.appVersion.indexOf("Mac"),
  IS_CHROMEOS : /\bCrOS\b/.test(navigator.appVersion),
  IS_LINUX : /\bLinux\b/.test(navigator.appVersion),
  IS_TOUCH : "ontouchstart" in document.documentElement,
  IS_POINTER : null != window.PointerEvent && !(0 < navigator.appVersion.indexOf("Mac")),
  IS_LOCAL : 0 > document.location.href.indexOf("http://") && 0 > document.location.href.indexOf("https://"),
  defaultBundles : [],
  isBrowserSupported : function() {
    return mxClient.IS_SVG;
  },
  link : function(rel, name, doc, pad) {
    doc = doc || document;
    var link = doc.createElement("link");
    link.setAttribute("rel", rel);
    link.setAttribute("href", name);
    link.setAttribute("charset", "UTF-8");
    link.setAttribute("type", "text/css");
    if (pad) {
      link.setAttribute("id", pad);
    }
    doc.getElementsByTagName("head")[0].appendChild(link);
  },
  loadResources : function(fn, lan) {
    function callback() {
      if (0 == --pending) {
        fn();
      }
    }
    var pending = mxClient.defaultBundles.length;
    for (var i = 0;i < mxClient.defaultBundles.length;i++) {
      mxResources.add(mxClient.defaultBundles[i], lan, callback);
    }
  },
  include : function(src) {
    document.write('<script src="' + src + '">\x3c/script>');
  }
};
if ("undefined" == typeof mxLoadResources) {
  mxLoadResources = true;
}
if ("undefined" == typeof mxForceIncludes) {
  mxForceIncludes = false;
}
if ("undefined" == typeof mxResourceExtension) {
  mxResourceExtension = ".txt";
}
if ("undefined" == typeof mxLoadStylesheets) {
  mxLoadStylesheets = true;
}
if ("undefined" != typeof mxBasePath && 0 < mxBasePath.length) {
  if ("/" == mxBasePath.substring(mxBasePath.length - 1)) {
    mxBasePath = mxBasePath.substring(0, mxBasePath.length - 1);
  }
  mxClient.basePath = mxBasePath;
} else {
  mxClient.basePath = ".";
}
if ("undefined" != typeof mxImageBasePath && 0 < mxImageBasePath.length) {
  if ("/" == mxImageBasePath.substring(mxImageBasePath.length - 1)) {
    mxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1);
  }
  mxClient.imageBasePath = mxImageBasePath;
} else {
  mxClient.imageBasePath = "images";
}
mxClient.language = "undefined" != typeof mxLanguage && null != mxLanguage ? mxLanguage : mxClient.IS_IE ? navigator.userLanguage : navigator.language;
mxClient.defaultLanguage = "undefined" != typeof mxDefaultLanguage && null != mxDefaultLanguage ? mxDefaultLanguage : "en";
if (mxLoadStylesheets) {
  mxClient.link("stylesheet", "mxgraph/css/common.css");
}
if ("undefined" != typeof mxLanguages) {
  if (null != mxLanguages) {
    mxClient.languages = mxLanguages;
  }
}
var mxLog = {
  consoleName : "Console",
  TRACE : false,
  DEBUG : true,
  WARN : true,
  buffer : "",
  init : function() {
    if (null == mxLog.window && null != document.body) {
      var resizeHandler = mxLog.consoleName + " - mxGraph " + mxClient.VERSION;
      var table = document.createElement("table");
      table.setAttribute("width", "100%");
      table.setAttribute("height", "100%");
      var tbody = document.createElement("tbody");
      var tr = document.createElement("tr");
      var td = document.createElement("td");
      td.style.verticalAlign = "top";
      mxLog.textarea = document.createElement("textarea");
      mxLog.textarea.setAttribute("wrap", "off");
      mxLog.textarea.setAttribute("readOnly", "true");
      mxLog.textarea.style.height = "100%";
      mxLog.textarea.style.resize = "none";
      mxLog.textarea.value = mxLog.buffer;
      mxLog.textarea.style.width = mxClient.IS_NS && "BackCompat" != document.compatMode ? "99%" : "100%";
      td.appendChild(mxLog.textarea);
      tr.appendChild(td);
      tbody.appendChild(tr);
      tr = document.createElement("tr");
      mxLog.td = document.createElement("td");
      mxLog.td.style.verticalAlign = "top";
      mxLog.td.setAttribute("height", "30px");
      tr.appendChild(mxLog.td);
      tbody.appendChild(tr);
      table.appendChild(tbody);
      mxLog.addButton("Info", function(flex) {
        mxLog.info();
      });
      mxLog.addButton("DOM", function(content) {
        content = mxUtils.getInnerHtml(document.body);
        mxLog.debug(content);
      });
      mxLog.addButton("Trace", function(flex) {
        mxLog.TRACE = !mxLog.TRACE;
        if (mxLog.TRACE) {
          mxLog.debug("Tracing enabled");
        } else {
          mxLog.debug("Tracing disabled");
        }
      });
      mxLog.addButton("Copy", function(flex) {
        try {
          mxUtils.copy(mxLog.textarea.value);
        } catch (message) {
          mxUtils.alert(message);
        }
      });
      mxLog.addButton("Show", function(flex) {
        try {
          mxUtils.popup(mxLog.textarea.value);
        } catch (message) {
          mxUtils.alert(message);
        }
      });
      mxLog.addButton("Clear", function(flex) {
        mxLog.textarea.value = "";
      });
      tr = tbody = 0;
      if ("number" === typeof window.innerWidth) {
        tbody = window.innerHeight;
        tr = window.innerWidth;
      } else {
        tbody = document.documentElement.clientHeight || document.body.clientHeight;
        tr = document.body.clientWidth;
      }
      mxLog.window = new mxWindow(resizeHandler, table, Math.max(0, tr - 320), Math.max(0, tbody - 210), 300, 160);
      mxLog.window.setMaximizable(true);
      mxLog.window.setScrollable(false);
      mxLog.window.setResizable(true);
      mxLog.window.setClosable(true);
      mxLog.window.destroyOnClose = false;
      if ((mxClient.IS_NS || mxClient.IS_IE) && (!mxClient.IS_GC && (!mxClient.IS_SF && "BackCompat" != document.compatMode)) || 11 == document.documentMode) {
        var elt = mxLog.window.getElement();
        resizeHandler = function(evt, sender) {
          mxLog.textarea.style.height = Math.max(0, elt.offsetHeight - 70) + "px";
        };
        mxLog.window.addListener(mxEvent.RESIZE_END, resizeHandler);
        mxLog.window.addListener(mxEvent.MAXIMIZE, resizeHandler);
        mxLog.window.addListener(mxEvent.NORMALIZE, resizeHandler);
        mxLog.textarea.style.height = "92px";
      }
    }
  },
  info : function() {
    mxLog.writeln(mxUtils.toString(navigator));
  },
  addButton : function(lab, funct) {
    var button = document.createElement("button");
    mxUtils.write(button, lab);
    mxEvent.addListener(button, "click", funct);
    mxLog.td.appendChild(button);
  },
  isVisible : function() {
    return null != mxLog.window ? mxLog.window.isVisible() : false;
  },
  show : function() {
    mxLog.setVisible(true);
  },
  setVisible : function(visible) {
    if (null == mxLog.window) {
      mxLog.init();
    }
    if (null != mxLog.window) {
      mxLog.window.setVisible(visible);
    }
  },
  enter : function(string) {
    if (mxLog.TRACE) {
      return mxLog.writeln("Entering " + string), (new Date).getTime();
    }
  },
  leave: function(string, t0) {
    if (mxLog.TRACE) {
      var dt = (t0 != 0) ? ' ('+(new Date().getTime() - t0)+' ms)' : '';
      mxLog.writeln('Leaving '+string+dt);
    }
  },
  debug : function() {
    if (mxLog.DEBUG) {
      mxLog.writeln.apply(this, arguments);
    }
  },
  warn : function() {
    if (mxLog.WARN) {
      mxLog.writeln.apply(this, arguments);
    }
  },
  write : function() {
    var string = "";
    for (var i = 0;i < arguments.length;i++) {
      string += arguments[i];
      if (i < arguments.length - 1) {
        string += " ";
      }
    }
    if (null != mxLog.textarea) {
      mxLog.textarea.value += string;
      if (null != navigator.userAgent) {
        if (0 <= navigator.userAgent.indexOf("Presto/2.5")) {
          mxLog.textarea.style.visibility = "hidden";
          mxLog.textarea.style.visibility = "visible";
        }
      }
      mxLog.textarea.scrollTop = mxLog.textarea.scrollHeight;
    } else {
      mxLog.buffer += string;
    }
  },
  writeln : function() {
    var string = "";
    for (var i = 0;i < arguments.length;i++) {
      string += arguments[i];
      if (i < arguments.length - 1) {
        string += " ";
      }
    }
    mxLog.write(string + "\n");
  }
};
var mxObjectIdentity = {
  FIELD_NAME : "mxObjectId",
  counter : 0,
  get : function(cell) {
    if (null != cell) {
      if (null == cell[mxObjectIdentity.FIELD_NAME]) {
        if ("object" === typeof cell) {
          var ctor = mxUtils.getFunctionName(cell.constructor);
          cell[mxObjectIdentity.FIELD_NAME] = ctor + "#" + mxObjectIdentity.counter++;
        } else {
          if ("function" === typeof cell) {
            cell[mxObjectIdentity.FIELD_NAME] = "Function#" + mxObjectIdentity.counter++;
          }
        }
      }
      return cell[mxObjectIdentity.FIELD_NAME];
    }
    return null;
  },
  clear : function(obj) {
    if (!("object" !== typeof obj && "function" !== typeof obj)) {
      delete obj[mxObjectIdentity.FIELD_NAME];
    }
  }
};
function mxDictionary() {
  this.clear();
}
mxDictionary.prototype.map = null;
mxDictionary.prototype.clear = function() {
  this.map = {};
};
mxDictionary.prototype.get = function(cell) {
  cell = mxObjectIdentity.get(cell);
  return this.map[cell];
};
mxDictionary.prototype.put = function(key, value) {
  var id = mxObjectIdentity.get(key);
  var previous = this.map[id];
  this.map[id] = value;
  return previous;
};
mxDictionary.prototype.remove = function(cell) {
  cell = mxObjectIdentity.get(cell);
  var previous = this.map[cell];
  delete this.map[cell];
  return previous;
};
mxDictionary.prototype.getKeys = function() {
  var result = [];
  for (var key in this.map) {
    result.push(key);
  }
  return result;
};
mxDictionary.prototype.getValues = function() {
  var result = [];
  for (var key in this.map) {
    result.push(this.map[key]);
  }
  return result;
};
mxDictionary.prototype.visit = function(visitor) {
  for (var key in this.map) {
    visitor(key, this.map[key]);
  }
};
var mxResources = {
  resources : {},
  extension : mxResourceExtension,
  resourcesEncoded : false,
  loadDefaultBundle : true,
  loadSpecialBundle : true,
  isLanguageSupported : function(lan) {
    return null != mxClient.languages ? 0 <= mxUtils.indexOf(mxClient.languages, lan) : true;
  },
  getDefaultBundle : function(basename, lan) {
    return mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(lan) ? basename + mxResources.extension : null;
  },
  getSpecialBundle : function(basename, lan) {
    if (null == mxClient.languages || !this.isLanguageSupported(lan)) {
      var dash = lan.indexOf("-");
      if (0 < dash) {
        lan = lan.substring(0, dash);
      }
    }
    return mxResources.loadSpecialBundle && (mxResources.isLanguageSupported(lan) && lan != mxClient.defaultLanguage) ? basename + "_" + lan + mxResources.extension : null;
  },
  add : function(parent, lan, callback) {
    lan = null != lan ? lan : null != mxClient.language ? mxClient.language.toLowerCase() : mxConstants.NONE;
    if (lan != mxConstants.NONE) {
      var cell = mxResources.getDefaultBundle(parent, lan);
      var child = mxResources.getSpecialBundle(parent, lan);
      var loadSpecialBundle = function() {
        if (null != child) {
          if (callback) {
            mxUtils.get(child, function(req) {
              mxResources.parse(req.getText());
              callback();
            }, function() {
              callback();
            });
          } else {
            try {
              var req = mxUtils.load(child);
              if (req.isReady()) {
                mxResources.parse(req.getText());
              }
            } catch (l) {
            }
          }
        } else {
          if (null != callback) {
            callback();
          }
        }
      };
      if (null != cell) {
        if (callback) {
          mxUtils.get(cell, function(req) {
            mxResources.parse(req.getText());
            loadSpecialBundle();
          }, function() {
            loadSpecialBundle();
          });
        } else {
          try {
            var req = mxUtils.load(cell);
            if (req.isReady()) {
              mxResources.parse(req.getText());
            }
            loadSpecialBundle();
          } catch (k) {
          }
        }
      } else {
        loadSpecialBundle();
      }
    }
  },
  parse : function(lines) {
    if (null != lines) {
      lines = lines.split("\n");
      for (var i = 0;i < lines.length;i++) {
        if ("#" != lines[i].charAt(0)) {
          var value = lines[i].indexOf("=");
          if (0 < value) {
            var key = lines[i].substring(0, value);
            var idx = lines[i].length;
            if (13 == lines[i].charCodeAt(idx - 1)) {
              idx--;
            }
            value = lines[i].substring(value + 1, idx);
            if (this.resourcesEncoded) {
              value = value.replace(/\\(?=u[a-fA-F\d]{4})/g, "%");
              mxResources.resources[key] = unescape(value);
            } else {
              mxResources.resources[key] = value;
            }
          }
        }
      }
    }
  },
  get : function(cell, params, onerror) {
    cell = mxResources.resources[cell];
    if (null == cell) {
      cell = onerror;
    }
    if (null != cell) {
      if (null != params) {
        cell = mxResources.replacePlaceholders(cell, params);
      }
    }
    return cell;
  },
  replacePlaceholders : function(value, params) {
    var result = [];
    var index = null;
    for (var i = 0;i < value.length;i++) {
      var c = value.charAt(i);
      if ("{" == c) {
        index = "";
      } else {
        if (null != index && "}" == c) {
          index = parseInt(index) - 1;
          if (0 <= index) {
            if (index < params.length) {
              result.push(params[index]);
            }
          }
          index = null;
        } else {
          if (null != index) {
            index += c;
          } else {
            result.push(c);
          }
        }
      }
    }
    return result.join("");
  },
  loadResources : function(callback) {
    mxResources.add(mxClient.basePath + "/resources/editor", null, function() {
      mxResources.add(mxClient.basePath + "/resources/graph", null, callback);
    });
  }
};
function mxPoint(x, y) {
  this.x = null != x ? x : 0;
  this.y = null != y ? y : 0;
}
mxPoint.prototype.x = null;
mxPoint.prototype.y = null;
mxPoint.prototype.equals = function(bounds) {
  return null != bounds && (bounds.x == this.x && bounds.y == this.y);
};
mxPoint.prototype.clone = function() {
  return mxUtils.clone(this);
};
function mxRectangle(x, y, width, height) {
  mxPoint.call(this, x, y);
  this.width = null != width ? width : 0;
  this.height = null != height ? height : 0;
}
mxRectangle.prototype = new mxPoint;
mxRectangle.prototype.constructor = mxRectangle;
mxRectangle.prototype.width = null;
mxRectangle.prototype.height = null;
mxRectangle.prototype.setRect = function(x, y, w, h) {
  this.x = x;
  this.y = y;
  this.width = w;
  this.height = h;
};
mxRectangle.prototype.getCenterX = function() {
  return this.x + this.width / 2;
};
mxRectangle.prototype.getCenterY = function() {
  return this.y + this.height / 2;
};
mxRectangle.prototype.add = function(parent) {
  if (null != parent) {
    var minX = Math.min(this.x, parent.x);
    var minY = Math.min(this.y, parent.y);
    var maxX = Math.max(this.x + this.width, parent.x + parent.width);
    parent = Math.max(this.y + this.height, parent.y + parent.height);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = parent - minY;
  }
};
mxRectangle.prototype.intersect = function(rect) {
  if (null != rect) {
    var r1 = this.x + this.width;
    var r2 = rect.x + rect.width;
    var b1 = this.y + this.height;
    var b2 = rect.y + rect.height;
    this.x = Math.max(this.x, rect.x);
    this.y = Math.max(this.y, rect.y);
    this.width = Math.min(r1, r2) - this.x;
    this.height = Math.min(b1, b2) - this.y;
  }
};
mxRectangle.prototype.grow = function(amount) {
  this.x -= amount;
  this.y -= amount;
  this.width += 2 * amount;
  this.height += 2 * amount;
  return this;
};
mxRectangle.prototype.getPoint = function() {
  return new mxPoint(this.x, this.y);
};
mxRectangle.prototype.rotate90 = function() {
  var t = (this.width - this.height) / 2;
  this.x += t;
  this.y -= t;
  t = this.width;
  this.width = this.height;
  this.height = t;
};
mxRectangle.prototype.equals = function(bounds) {
  return null != bounds && (bounds.x == this.x && (bounds.y == this.y && (bounds.width == this.width && bounds.height == this.height)));
};
mxRectangle.fromPoint = function(b) {
  return new mxRectangle(b.x, b.y, 0, 0);
};
mxRectangle.fromRectangle = function(state) {
  return new mxRectangle(state.x, state.y, state.width, state.height);
};
var mxEffects = {
  animateChanges : function(graph, changes, done) {
    var d = 0;
    var animate = function() {
      var g = false;
      for (var i = 0;i < changes.length;i++) {
        var change = changes[i];
        if (change instanceof mxGeometryChange || (change instanceof mxTerminalChange || (change instanceof mxValueChange || (change instanceof mxChildChange || change instanceof mxStyleChange)))) {
          var state = graph.getView().getState(change.cell || change.child, false);
          if (null != state) {
            if (g = true, change.constructor != mxGeometryChange || graph.model.isEdge(change.cell)) {
              mxUtils.setOpacity(state.shape.node, 100 * d / 10);
            } else {
              var sy = graph.getView().scale;
              var dx = (change.geometry.x - change.previous.x) * sy;
              var dy = (change.geometry.y - change.previous.y) * sy;
              var sx = (change.geometry.width - change.previous.width) * sy;
              sy = (change.geometry.height - change.previous.height) * sy;
              if (0 == d) {
                state.x -= dx;
                state.y -= dy;
                state.width -= sx;
                state.height -= sy;
              } else {
                state.x += dx / 10;
                state.y += dy / 10;
                state.width += sx / 10;
                state.height += sy / 10;
              }
              graph.cellRenderer.redraw(state);
              mxEffects.cascadeOpacity(graph, change.cell, 100 * d / 10);
            }
          }
        }
      }
      if (10 > d && g) {
        d++;
        window.setTimeout(animate, delay);
      } else {
        if (null != done) {
          done();
        }
      }
    };
    var delay = 30;
    animate();
  },
  cascadeOpacity : function(graph, cell, opacity) {
    var state = graph.model.getChildCount(cell);
    for (var i = 0;i < state;i++) {
      var child = graph.model.getChildAt(cell, i);
      var childState = graph.getView().getState(child);
      if (null != childState) {
        mxUtils.setOpacity(childState.shape.node, opacity);
        mxEffects.cascadeOpacity(graph, child, opacity);
      }
    }
    cell = graph.model.getEdges(cell);
    if (null != cell) {
      for (i = 0;i < cell.length;i++) {
        state = graph.getView().getState(cell[i]);
        if (null != state) {
          mxUtils.setOpacity(state.shape.node, opacity);
        }
      }
    }
  },
  fadeOut : function(node, from, isEnabled, step, delay, remove) {
    step = step || 40;
    delay = delay || 30;
    var opacity = from || 100;
    mxUtils.setOpacity(node, opacity);
    if (remove || null == remove) {
      var f = function() {
        opacity = Math.max(opacity - step, 0);
        mxUtils.setOpacity(node, opacity);
        if (0 < opacity) {
          window.setTimeout(f, delay);
        } else {
          node.style.visibility = "hidden";
          if (isEnabled) {
            if (node.parentNode) {
              node.parentNode.removeChild(node);
            }
          }
        }
      };
      window.setTimeout(f, delay);
    } else {
      node.style.visibility = "hidden";
      if (isEnabled) {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      }
    }
  }
};
var mxUtils = {
  errorResource : "none" != mxClient.language ? "error" : "",
  closeResource : "none" != mxClient.language ? "close" : "",
  errorImage : mxClient.imageBasePath + "/error.gif",
  removeCursors : function(a) {
    if (null != a.style) {
      a.style.cursor = "";
    }
    a = a.childNodes;
    if (null != a) {
      var numRanks = a.length;
      for (var i = 0;i < numRanks;i += 1) {
        mxUtils.removeCursors(a[i]);
      }
    }
  },
  getCurrentStyle : function() {
    return mxClient.IS_IE && (null == document.documentMode || 9 > document.documentMode) ? function(element) {
      return null != element ? element.currentStyle : null;
    } : function(element) {
      return null != element ? window.getComputedStyle(element, "") : null;
    };
  }(),
  parseCssNumber : function(value) {
    if ("thin" == value) {
      value = "2";
    } else {
      if ("medium" == value) {
        value = "4";
      } else {
        if ("thick" == value) {
          value = "6";
        }
      }
    }
    value = parseFloat(value);
    if (isNaN(value)) {
      value = 0;
    }
    return value;
  },
  setPrefixedStyle : function() {
    var prefix = null;
    if (mxClient.IS_OT) {
      prefix = "O";
    } else {
      if (mxClient.IS_SF || mxClient.IS_GC) {
        prefix = "Webkit";
      } else {
        if (mxClient.IS_MT) {
          prefix = "Moz";
        } else {
          if (mxClient.IS_IE) {
            if (9 <= document.documentMode) {
              if (10 > document.documentMode) {
                prefix = "ms";
              }
            }
          }
        }
      }
    }
    return function(style, name, value) {
      style[name] = value;
      if (null != prefix) {
        if (0 < name.length) {
          name = prefix + name.substring(0, 1).toUpperCase() + name.substring(1);
          style[name] = value;
        }
      }
    };
  }(),
  hasScrollbars : function(node) {
    node = mxUtils.getCurrentStyle(node);
    return null != node && ("scroll" == node.overflow || "auto" == node.overflow);
  },
  bind : function(state, funct) {
    return function() {
      return funct.apply(state, arguments);
    };
  },
  eval : function(expr) {
    var result = null;
    if (0 <= expr.indexOf("function")) {
      try {
        eval("var _mxJavaScriptExpression=" + expr);
        result = _mxJavaScriptExpression;
        _mxJavaScriptExpression = null;
      } catch (e) {
        mxLog.warn(e.message + " while evaluating " + expr);
      }
    } else {
      try {
        result = eval(expr);
      } catch (message) {
        mxLog.warn(message.message + " while evaluating " + expr);
      }
    }
    return result;
  },
  findNode : function(node, attr, value) {
    if (node.nodeType == mxConstants.NODETYPE_ELEMENT) {
      var tmp = node.getAttribute(attr);
      if (null != tmp && tmp == value) {
        return node;
      }
    }
    for (node = node.firstChild;null != node;) {
      tmp = mxUtils.findNode(node, attr, value);
      if (null != tmp) {
        return tmp;
      }
      node = node.nextSibling;
    }
    return null;
  },
  getFunctionName : function(f) {
    var str = null;
    if (null != f) {
      if (null != f.name) {
        str = f.name;
      } else {
        str = mxUtils.trim(f.toString());
        if (/^function\s/.test(str)) {
          str = mxUtils.ltrim(str.substring(9));
          f = str.indexOf("(");
          if (0 < f) {
            str = str.substring(0, f);
          }
        }
      }
    }
    return str;
  },
  indexOf : function(array, cell) {
    if (null != array && null != cell) {
      for (var i = 0;i < array.length;i++) {
        if (array[i] == cell) {
          return i;
        }
      }
    }
    return-1;
  },
  forEach : function(array, fn) {
    if (null != array && null != fn) {
      for (var i = 0;i < array.length;i++) {
        fn(array[i]);
      }
    }
    return array;
  },
  remove : function(cell, array) {
    var best = null;
    if ("object" == typeof array) {
      for (var index = mxUtils.indexOf(array, cell);0 <= index;) {
        array.splice(index, 1);
        best = cell;
        index = mxUtils.indexOf(array, cell);
      }
    }
    for (var key in array) {
      if (array[key] == cell) {
        delete array[key];
        best = cell;
      }
    }
    return best;
  },
  isNode : function(value, nodeName, attributeName, attributeValue) {
    return null == value || (value.constructor !== Element || null != nodeName && value.nodeName.toLowerCase() != nodeName.toLowerCase()) ? false : null == attributeName || value.getAttribute(attributeName) == attributeValue;
  },
  isAncestorNode : function(ancestor, child) {
    for (var parent = child;null != parent;) {
      if (parent == ancestor) {
        return true;
      }
      parent = parent.parentNode;
    }
    return false;
  },
  getChildNodes : function(node, nodeType) {
    nodeType = nodeType || mxConstants.NODETYPE_ELEMENT;
    var children = [];
    for (var tmp = node.firstChild;null != tmp;) {
      if (tmp.nodeType == nodeType) {
        children.push(tmp);
      }
      tmp = tmp.nextSibling;
    }
    return children;
  },
  importNode : function(doc, node, allChildren) {
    return mxClient.IS_IE && (null == document.documentMode || 10 > document.documentMode) ? mxUtils.importNodeImplementation(doc, node, allChildren) : doc.importNode(node, allChildren);
  },
  importNodeImplementation : function(doc, node, allChildren) {
    switch(node.nodeType) {
      case 1:
        var newNode = doc.createElement(node.nodeName);
        if (node.attributes && 0 < node.attributes.length) {
          for (var i = 0;i < node.attributes.length;i++) {
            newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));
          }
        }
        if (allChildren && (node.childNodes && 0 < node.childNodes.length)) {
          for (i = 0;i < node.childNodes.length;i++) {
            newNode.appendChild(mxUtils.importNodeImplementation(doc, node.childNodes[i], allChildren));
          }
        }
        return newNode;
      case 3:
      ;
      case 4:
      ;
      case 8:
        return doc.createTextNode(null != node.nodeValue ? node.nodeValue : node.value);
    }
  },
  createXmlDocument : function() {
    var doc = null;
    if (document.implementation) {
      if (document.implementation.createDocument) {
        doc = document.implementation.createDocument("", "", null);
      }
    }
    return doc;
  },
  parseXml : function(xml) {
    return(new DOMParser).parseFromString(xml, "text/xml");
  },
  clearSelection : function() {
    return document.selection ? function() {
      document.selection.empty();
    } : window.getSelection ? function() {
      if (window.getSelection().empty) {
        window.getSelection().empty();
      } else {
        if (window.getSelection().removeAllRanges) {
          window.getSelection().removeAllRanges();
        }
      }
    } : function() {
    };
  }(),
  removeWhitespace : function(node, before) {
    for (var tmp = before ? node.previousSibling : node.nextSibling;null != tmp && tmp.nodeType == mxConstants.NODETYPE_TEXT;) {
      var next = before ? tmp.previousSibling : tmp.nextSibling;
      var text = mxUtils.getTextContent(tmp);
      if (0 == mxUtils.trim(text).length) {
        tmp.parentNode.removeChild(tmp);
      }
      tmp = next;
    }
  },
  htmlEntities : function(s, layer) {
    s = String(s || "");
    s = s.replace(/&/g, "&amp;");
    s = s.replace(/"/g, "&quot;");
    s = s.replace(/'/g, "&#39;");
    s = s.replace(/</g, "&lt;");
    s = s.replace(/>/g, "&gt;");
    if (null == layer || layer) {
      s = s.replace(/\n/g, "&#xa;");
    }
    return s;
  },
  decodeHtml : function(str) {
    var ta = document.createElement("textarea");
    ta.innerHTML = str;
    return ta.value;
  },
  getXml : function(node, linefeed) {
    var xml = "";
    if (mxClient.IS_IE || mxClient.IS_IE11) {
      xml = mxUtils.getPrettyXml(node, "", "", "");
    } else {
      if (null != window.XMLSerializer) {
        xml = (new XMLSerializer).serializeToString(node);
      } else {
        if (null != node.xml) {
          xml = node.xml.replace(/\r\n\t[\t]*/g, "").replace(/>\r\n/g, ">").replace(/\r\n/g, "\n");
        }
      }
    }
    return xml = xml.replace(/\n/g, linefeed || "&#xa;");
  },
  getPrettyXml : function(node, tab, indent, newline, ns) {
    var result = [];
    if (null != node) {
      if (tab = null != tab ? tab : "  ", indent = null != indent ? indent : "", newline = null != newline ? newline : "\n", null != node.namespaceURI && (node.namespaceURI != ns && (ns = node.namespaceURI, null == node.getAttribute("xmlns") && node.setAttribute("xmlns", node.namespaceURI))), node.nodeType == mxConstants.NODETYPE_DOCUMENT) {
        result.push(mxUtils.getPrettyXml(node.documentElement, tab, indent, newline, ns));
      } else {
        if (node.nodeType == mxConstants.NODETYPE_DOCUMENT_FRAGMENT) {
          var tmp = node.firstChild;
          if (null != tmp) {
            for (;null != tmp;) {
              result.push(mxUtils.getPrettyXml(tmp, tab, indent, newline, ns));
              tmp = tmp.nextSibling;
            }
          }
        } else {
          if (node.nodeType == mxConstants.NODETYPE_COMMENT) {
            node = mxUtils.getTextContent(node);
            if (0 < node.length) {
              result.push(indent + "\x3c!--" + node + "--\x3e" + newline);
            }
          } else {
            if (node.nodeType == mxConstants.NODETYPE_TEXT) {
              node = mxUtils.trim(mxUtils.getTextContent(node));
              if (0 < node.length) {
                result.push(indent + mxUtils.htmlEntities(node, false) + newline);
              }
            } else {
              if (node.nodeType == mxConstants.NODETYPE_CDATA) {
                node = mxUtils.getTextContent(node);
                if (0 < node.length) {
                  result.push(indent + "<![CDATA[" + node + "]]" + newline);
                }
              } else {
                result.push(indent + "<" + node.nodeName);
                tmp = node.attributes;
                if (null != tmp) {
                  for (var i = 0;i < tmp.length;i++) {
                    var l = mxUtils.htmlEntities(tmp[i].value);
                    result.push(" " + tmp[i].nodeName + '="' + l + '"');
                  }
                }
                tmp = node.firstChild;
                if (null != tmp) {
                  for (result.push(">" + newline);null != tmp;) {
                    result.push(mxUtils.getPrettyXml(tmp, tab, indent + tab, newline, ns));
                    tmp = tmp.nextSibling;
                  }
                  result.push(indent + "</" + node.nodeName + ">" + newline);
                } else {
                  result.push(" />" + newline);
                }
              }
            }
          }
        }
      }
    }
    return result.join("");
  },
  extractTextWithWhitespace : function(elems) {
    function doExtract(elts) {
      if (1 != elts.length || "BR" != elts[0].nodeName && "\n" != elts[0].innerHTML) {
        for (var i = 0;i < elts.length;i++) {
          var elem = elts[i];
          if ("BR" == elem.nodeName || ("\n" == elem.innerHTML || (1 == elts.length || 0 == i) && ("DIV" == elem.nodeName && "<br>" == elem.innerHTML.toLowerCase()))) {
            ret.push("\n");
          } else {
            if (3 === elem.nodeType || 4 === elem.nodeType) {
              if (0 < elem.nodeValue.length) {
                ret.push(elem.nodeValue);
              }
            } else {
              if (8 !== elem.nodeType) {
                if (0 < elem.childNodes.length) {
                  doExtract(elem.childNodes);
                }
              }
            }
            if (i < elts.length - 1) {
              if (0 <= mxUtils.indexOf(transients, elts[i + 1].nodeName)) {
                ret.push("\n");
              }
            }
          }
        }
      }
    }
    var transients = "BLOCKQUOTE DIV H1 H2 H3 H4 H5 H6 OL P PRE TABLE UL".split(" ");
    var ret = [];
    doExtract(elems);
    return ret.join("");
  },
  replaceTrailingNewlines : function(val, pattern) {
    for (var postfix = "";0 < val.length && "\n" == val.charAt(val.length - 1);) {
      val = val.substring(0, val.length - 1);
      postfix += pattern;
    }
    return val + postfix;
  },
  getTextContent : function(node) {
    return mxClient.IS_IE && void 0 !== node.innerText ? node.innerText : null != node ? node[void 0 === node.textContent ? "text" : "textContent"] : "";
  },
  setTextContent : function(node, text) {
    if (void 0 !== node.innerText) {
      node.innerText = text;
    } else {
      node[void 0 === node.textContent ? "text" : "textContent"] = text;
    }
  },
  getInnerHtml : function() {
    return mxClient.IS_IE ? function(node) {
      return null != node ? node.innerHTML : "";
    } : function(node) {
      return null != node ? (new XMLSerializer).serializeToString(node) : "";
    };
  }(),
  getOuterHtml : function() {
    return mxClient.IS_IE ? function(node) {
      if (null != node) {
        if (null != node.outerHTML) {
          return node.outerHTML;
        }
        var tmp = [];
        tmp.push("<" + node.nodeName);
        var attrs = node.attributes;
        if (null != attrs) {
          for (var i = 0;i < attrs.length;i++) {
            var value = attrs[i].value;
            if (null != value) {
              if (0 < value.length) {
                tmp.push(" ");
                tmp.push(attrs[i].nodeName);
                tmp.push('="');
                tmp.push(value);
                tmp.push('"');
              }
            }
          }
        }
        if (0 == node.innerHTML.length) {
          tmp.push("/>");
        } else {
          tmp.push(">");
          tmp.push(node.innerHTML);
          tmp.push("</" + node.nodeName + ">");
        }
        return tmp.join("");
      }
      return "";
    } : function(node) {
      return null != node ? (new XMLSerializer).serializeToString(node) : "";
    };
  }(),
  write : function(parent, text) {
    var node = parent.ownerDocument.createTextNode(text);
    if (null != parent) {
      parent.appendChild(node);
    }
    return node;
  },
  writeln : function(parent, text) {
    var node = parent.ownerDocument.createTextNode(text);
    if (null != parent) {
      parent.appendChild(node);
      parent.appendChild(document.createElement("br"));
    }
    return node;
  },
  br : function(parent, count) {
    count = count || 1;
    var br = null;
    for (var i = 0;i < count;i++) {
      if (null != parent) {
        br = parent.ownerDocument.createElement("br");
        parent.appendChild(br);
      }
    }
    return br;
  },
  button : function(label, funct, button) {
    button = null != button ? button : document;
    button = button.createElement("button");
    mxUtils.write(button, label);
    mxEvent.addListener(button, "click", function(evt) {
      funct(evt);
    });
    return button;
  },
  para : function(parent, text) {
    var p = document.createElement("p");
    mxUtils.write(p, text);
    if (null != parent) {
      parent.appendChild(p);
    }
    return p;
  },
  addTransparentBackgroundFilter : function(node) {
    node.style.filter += "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + mxClient.imageBasePath + "/transparent.gif', sizingMethod='scale')";
  },
  linkAction : function(doc, text, editor, parent, pad) {
    return mxUtils.link(doc, text, function() {
      editor.execute(parent);
    }, pad);
  },
  linkInvoke : function(doc, text, editor, functName, arg, pad) {
    return mxUtils.link(doc, text, function() {
      editor[functName](arg);
    }, pad);
  },
  link : function(doc, text, funct, pad) {
    var a = document.createElement("span");
    a.style.color = "blue";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    if (null != pad) {
      a.style.paddingLeft = pad + "px";
    }
    mxEvent.addListener(a, "click", funct);
    mxUtils.write(a, text);
    if (null != doc) {
      doc.appendChild(a);
    }
    return a;
  },
  getDocumentSize : function() {
    var b = document.body;
    var d = document.documentElement;
    try {
      return new mxRectangle(0, 0, b.clientWidth || d.clientWidth, Math.max(b.clientHeight || 0, d.clientHeight));
    } catch (c) {
      return new mxRectangle;
    }
  },
  fit : function(node) {
    var ds = mxUtils.getDocumentSize();
    var left = parseInt(node.offsetLeft);
    var width = parseInt(node.offsetWidth);
    var st = mxUtils.getDocumentScrollOrigin(node.ownerDocument);
    var sl = st.x;
    st = st.y;
    var right = sl + ds.width;
    if (left + width > right) {
      node.style.left = Math.max(sl, right - width) + "px";
    }
    left = parseInt(node.offsetTop);
    width = parseInt(node.offsetHeight);
    ds = st + ds.height;
    if (left + width > ds) {
      node.style.top = Math.max(st, ds - width) + "px";
    }
  },
  load : function(url) {
    url = new mxXmlRequest(url, null, "GET", false);
    url.send();
    return url;
  },
  get : function(cell, onload, onerror, key, timeout, ontimeout, headers) {
    cell = new mxXmlRequest(cell, null, "GET");
    var old = cell.setRequestHeaders;
    if (headers) {
      cell.setRequestHeaders = function(request, params) {
        old.apply(this, arguments);
        for (var key in headers) {
          request.setRequestHeader(key, headers[key]);
        }
      };
    }
    if (null != key) {
      cell.setBinary(key);
    }
    cell.send(onload, onerror, timeout, ontimeout);
    return cell;
  },
  getAll : function(urls, onload, onerror) {
    var remain = urls.length;
    var result = [];
    var f = 0;
    var err = function() {
      if (0 == f) {
        if (null != onerror) {
          onerror();
        }
      }
      f++;
    };
    for (var i = 0;i < urls.length;i++) {
      (function(cell, index) {
        mxUtils.get(cell, function(req) {
          var status = req.getStatus();
          if (200 > status || 299 < status) {
            err();
          } else {
            result[index] = req;
            remain--;
            if (0 == remain) {
              onload(result);
            }
          }
        }, err);
      })(urls[i], i);
    }
    if (0 == remain) {
      onload(result);
    }
  },
  post : function(url, params, onload, onerror) {
    return(new mxXmlRequest(url, params)).send(onload, onerror);
  },
  submit : function(url, params, doc, target) {
    return(new mxXmlRequest(url, params)).simulate(doc, target);
  },
  loadInto : function(url, doc, onload) {
    if (mxClient.IS_IE) {
      doc.onreadystatechange = function() {
        if (4 == doc.readyState) {
          onload();
        }
      };
    } else {
      doc.addEventListener("load", onload, false);
    }
    doc.load(url);
  },
  getValue : function(cell, key, defaultValue) {
    cell = null != cell ? cell[key] : null;
    if (null == cell) {
      cell = defaultValue;
    }
    return cell;
  },
  getNumber : function(array, key, update) {
    array = null != array ? array[key] : null;
    if (null == array) {
      array = update || 0;
    }
    return Number(array);
  },
  getColor : function(value, key, defaultValue) {
    value = null != value ? value[key] : null;
    if (null == value) {
      value = defaultValue;
    } else {
      if (value == mxConstants.NONE) {
        value = null;
      }
    }
    return value;
  },
  isEmptyObject : function(a) {
    for (var key in a) {
      return false;
    }
    return true;
  },
  clone : function(obj, transients, shallow) {
    shallow = null != shallow ? shallow : false;
    var clone = null;
    if (null != obj && "function" == typeof obj.constructor) {
      if (obj.constructor === Element) {
        clone = obj.cloneNode(null != shallow ? !shallow : false);
      } else {
        clone = new obj.constructor;
        for (var i in obj) {
          if (i != mxObjectIdentity.FIELD_NAME) {
            if (null == transients || 0 > mxUtils.indexOf(transients, i)) {
              clone[i] = shallow || "object" != typeof obj[i] ? obj[i] : mxUtils.clone(obj[i]);
            }
          }
        }
      }
    }
    return clone;
  },
  equalPoints : function(a, b) {
    if (null == a && null != b || (null != a && null == b || null != a && (null != b && a.length != b.length))) {
      return false;
    }
    if (null != a && null != b) {
      for (var i = 0;i < a.length;i++) {
        if (null != a[i] && null == b[i] || (null == a[i] && null != b[i] || null != a[i] && (null != b[i] && (a[i].x != b[i].x || a[i].y != b[i].y)))) {
          return false;
        }
      }
    }
    return true;
  },
  equalEntries : function(a, b) {
    var c = 0;
    if (null == a && null != b || (null != a && null == b || null != a && (null != b && a.length != b.length))) {
      return false;
    }
    if (null != a && null != b) {
      for (var i in b) {
        c++;
      }
      for (i in a) {
        if (c--, !(mxUtils.isNaN(a[i]) && mxUtils.isNaN(b[i]) || a[i] == b[i])) {
          return false;
        }
      }
    }
    return 0 == c;
  },
  removeDuplicates : function(arr) {
    var dict = new mxDictionary;
    var result = [];
    for (var i = 0;i < arr.length;i++) {
      if (!dict.get(arr[i])) {
        result.push(arr[i]);
        dict.put(arr[i], true);
      }
    }
    return result;
  },
  isNaN : function(value) {
    return "number" == typeof value && isNaN(value);
  },
  extend : function(shape, superCtor) {
    var f = function() {
    };
    f.prototype = superCtor.prototype;
    shape.prototype = new f;
    shape.prototype.constructor = shape;
  },
  toString : function(obj) {
    var output = "";
    for (var i in obj) {
      try {
        if (null == obj[i]) {
          output += i + " = [null]\n";
        } else {
          if ("function" == typeof obj[i]) {
            output += i + " => [Function]\n";
          } else {
            if ("object" == typeof obj[i]) {
              var ctor = mxUtils.getFunctionName(obj[i].constructor);
              output += i + " => [" + ctor + "]\n";
            } else {
              output += i + " = " + obj[i] + "\n";
            }
          }
        }
      } catch (e) {
        output += i + "=" + e.message;
      }
    }
    return output;
  },
  toRadians : function(deg) {
    return Math.PI * deg / 180;
  },
  toDegree : function(max) {
    return 180 * max / Math.PI;
  },
  arcToCurves : function(y0, x0, r1, r2, rxd, alpha, sweepFlag, x, y) {
    x -= y0;
    y -= x0;
    if (0 === r1 || 0 === r2) {
      return spsi;
    }
    r1 = Math.abs(r1);
    r2 = Math.abs(r2);
    var ryd = -x / 2;
    var txd = -y / 2;
    var cpsi = Math.cos(rxd * Math.PI / 180);
    spsi = Math.sin(rxd * Math.PI / 180);
    rxd = cpsi * ryd + spsi * txd;
    ryd = -1 * spsi * ryd + cpsi * txd;
    txd = rxd * rxd;
    var tyd = ryd * ryd;
    var r1x = r1 * r1;
    var y3 = r2 * r2;
    var projlenSq = txd / r1x + tyd / y3;
    if (1 < projlenSq) {
      r1 *= Math.sqrt(projlenSq);
      r2 *= Math.sqrt(projlenSq);
      alpha = 0;
    } else {
      projlenSq = 1;
      if (alpha === sweepFlag) {
        projlenSq = -1;
      }
      alpha = projlenSq * Math.sqrt((r1x * y3 - r1x * tyd - y3 * txd) / (r1x * tyd + y3 * txd));
    }
    txd = alpha * r1 * ryd / r2;
    tyd = -1 * alpha * r2 * rxd / r1;
    x = cpsi * txd - spsi * tyd + x / 2;
    y = spsi * txd + cpsi * tyd + y / 2;
    r1x = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
    alpha = 0 <= r1x ? r1x : 2 * Math.PI + r1x;
    r1x = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
    rxd = 0 <= r1x ? r1x : 2 * Math.PI + r1x;
    if (0 == sweepFlag && 0 < rxd) {
      rxd -= 2 * Math.PI;
    } else {
      if (0 != sweepFlag) {
        if (0 > rxd) {
          rxd += 2 * Math.PI;
        }
      }
    }
    sweepFlag = 2 * rxd / Math.PI;
    sweepFlag = Math.ceil(0 > sweepFlag ? -1 * sweepFlag : sweepFlag);
    rxd /= sweepFlag;
    ryd = 8 / 3 * Math.sin(rxd / 4) * Math.sin(rxd / 4) / Math.sin(rxd / 2);
    txd = cpsi * r1;
    cpsi *= r2;
    r1 *= spsi;
    r2 *= spsi;
    var sin = Math.cos(alpha);
    var cos = Math.sin(alpha);
    tyd = -ryd * (txd * cos + r2 * sin);
    r1x = -ryd * (r1 * cos - cpsi * sin);
    var spsi = [];
    for (var A = 0;A < sweepFlag;++A) {
      alpha += rxd;
      sin = Math.cos(alpha);
      cos = Math.sin(alpha);
      y3 = txd * sin - r2 * cos + x;
      projlenSq = r1 * sin + cpsi * cos + y;
      var dy = -ryd * (txd * cos + r2 * sin);
      sin = -ryd * (r1 * cos - cpsi * sin);
      cos = 6 * A;
      spsi[cos] = Number(tyd + y0);
      spsi[cos + 1] = Number(r1x + x0);
      spsi[cos + 2] = Number(y3 - dy + y0);
      spsi[cos + 3] = Number(projlenSq - sin + x0);
      spsi[cos + 4] = Number(y3 + y0);
      spsi[cos + 5] = Number(projlenSq + x0);
      tyd = y3 + dy;
      r1x = projlenSq + sin;
    }
    return spsi;
  },
  getBoundingBox : function(rect, pt, cx) {
    var cos = null;
    if (null != rect && (null != pt && 0 != pt)) {
      pt = mxUtils.toRadians(pt);
      cos = Math.cos(pt);
      var sin = Math.sin(pt);
      cx = null != cx ? cx : new mxPoint(rect.x + rect.width / 2, rect.y + rect.height / 2);
      var p4 = new mxPoint(rect.x, rect.y);
      pt = new mxPoint(rect.x + rect.width, rect.y);
      var p3 = new mxPoint(pt.x, rect.y + rect.height);
      rect = new mxPoint(rect.x, p3.y);
      p4 = mxUtils.getRotatedPoint(p4, cos, sin, cx);
      pt = mxUtils.getRotatedPoint(pt, cos, sin, cx);
      p3 = mxUtils.getRotatedPoint(p3, cos, sin, cx);
      rect = mxUtils.getRotatedPoint(rect, cos, sin, cx);
      cos = new mxRectangle(p4.x, p4.y, 0, 0);
      cos.add(new mxRectangle(pt.x, pt.y, 0, 0));
      cos.add(new mxRectangle(p3.x, p3.y, 0, 0));
      cos.add(new mxRectangle(rect.x, rect.y, 0, 0));
    }
    return cos;
  },
  getRotatedPoint : function(pt, cos, sin, c) {
    c = null != c ? c : new mxPoint;
    var x = pt.x - c.x;
    pt = pt.y - c.y;
    return new mxPoint(x * cos - pt * sin + c.x, pt * cos + x * sin + c.y);
  },
  getPortConstraints : function(edge, state, source, directions) {
    state = mxUtils.getValue(edge.style, mxConstants.STYLE_PORT_CONSTRAINT, mxUtils.getValue(state.style, source ? mxConstants.STYLE_SOURCE_PORT_CONSTRAINT : mxConstants.STYLE_TARGET_PORT_CONSTRAINT, null));
    if (null == state) {
      return directions;
    }
    directions = state.toString();
    state = mxConstants.DIRECTION_MASK_NONE;
    source = 0;
    if (1 == mxUtils.getValue(edge.style, mxConstants.STYLE_PORT_CONSTRAINT_ROTATION, 0)) {
      source = mxUtils.getValue(edge.style, mxConstants.STYLE_ROTATION, 0);
    }
    edge = 0;
    if (45 < source) {
      edge = 1;
      if (135 <= source) {
        edge = 2;
      }
    } else {
      if (-45 > source) {
        edge = 3;
        if (-135 >= source) {
          edge = 2;
        }
      }
    }
    if (0 <= directions.indexOf(mxConstants.DIRECTION_NORTH)) {
      switch(edge) {
        case 0:
          state |= mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 1:
          state |= mxConstants.DIRECTION_MASK_EAST;
          break;
        case 2:
          state |= mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 3:
          state |= mxConstants.DIRECTION_MASK_WEST;
      }
    }
    if (0 <= directions.indexOf(mxConstants.DIRECTION_WEST)) {
      switch(edge) {
        case 0:
          state |= mxConstants.DIRECTION_MASK_WEST;
          break;
        case 1:
          state |= mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 2:
          state |= mxConstants.DIRECTION_MASK_EAST;
          break;
        case 3:
          state |= mxConstants.DIRECTION_MASK_SOUTH;
      }
    }
    if (0 <= directions.indexOf(mxConstants.DIRECTION_SOUTH)) {
      switch(edge) {
        case 0:
          state |= mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 1:
          state |= mxConstants.DIRECTION_MASK_WEST;
          break;
        case 2:
          state |= mxConstants.DIRECTION_MASK_NORTH;
          break;
        case 3:
          state |= mxConstants.DIRECTION_MASK_EAST;
      }
    }
    if (0 <= directions.indexOf(mxConstants.DIRECTION_EAST)) {
      switch(edge) {
        case 0:
          state |= mxConstants.DIRECTION_MASK_EAST;
          break;
        case 1:
          state |= mxConstants.DIRECTION_MASK_SOUTH;
          break;
        case 2:
          state |= mxConstants.DIRECTION_MASK_WEST;
          break;
        case 3:
          state |= mxConstants.DIRECTION_MASK_NORTH;
      }
    }
    return state;
  },
  reversePortConstraints : function(constraint) {
    var b = (constraint & mxConstants.DIRECTION_MASK_WEST) << 3;
    b |= (constraint & mxConstants.DIRECTION_MASK_NORTH) << 1;
    b |= (constraint & mxConstants.DIRECTION_MASK_SOUTH) >> 1;
    return b |= (constraint & mxConstants.DIRECTION_MASK_EAST) >> 3;
  },
  findNearestSegment : function(state, x, y) {
    var index = -1;
    if (0 < state.absolutePoints.length) {
      var last = state.absolutePoints[0];
      var f = null;
      for (var i = 1;i < state.absolutePoints.length;i++) {
        var current = state.absolutePoints[i];
        last = mxUtils.ptSegDistSq(last.x, last.y, current.x, current.y, x, y);
        if (null == f || last < f) {
          f = last;
          index = i - 1;
        }
        last = current;
      }
    }
    return index;
  },
  getDirectedBounds : function(rect, m, style, flipH, flipV) {
    var direction = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
    flipH = null != flipH ? flipH : mxUtils.getValue(style, mxConstants.STYLE_FLIPH, false);
    flipV = null != flipV ? flipV : mxUtils.getValue(style, mxConstants.STYLE_FLIPV, false);
    m.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));
    m.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));
    m.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));
    m.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));
    if (flipV && (direction == mxConstants.DIRECTION_SOUTH || direction == mxConstants.DIRECTION_NORTH) || flipH && (direction == mxConstants.DIRECTION_EAST || direction == mxConstants.DIRECTION_WEST)) {
      style = m.x;
      m.x = m.width;
      m.width = style;
    }
    if (flipH && (direction == mxConstants.DIRECTION_SOUTH || direction == mxConstants.DIRECTION_NORTH) || flipV && (direction == mxConstants.DIRECTION_EAST || direction == mxConstants.DIRECTION_WEST)) {
      style = m.y;
      m.y = m.height;
      m.height = style;
    }
    var m2 = mxRectangle.fromRectangle(m);
    if (direction == mxConstants.DIRECTION_SOUTH) {
      m2.y = m.x;
      m2.x = m.height;
      m2.width = m.y;
      m2.height = m.width;
    } else {
      if (direction == mxConstants.DIRECTION_WEST) {
        m2.y = m.height;
        m2.x = m.width;
        m2.width = m.x;
        m2.height = m.y;
      } else {
        if (direction == mxConstants.DIRECTION_NORTH) {
          m2.y = m.width;
          m2.x = m.y;
          m2.width = m.height;
          m2.height = m.x;
        }
      }
    }
    return new mxRectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);
  },
  getPerimeterPoint : function(pts, center, point) {
    var min = null;
    for (var i = 0;i < pts.length - 1;i++) {
      var pt = mxUtils.intersection(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, center.x, center.y, point.x, point.y);
      if (null != pt) {
        var dy = point.x - pt.x;
        var dx = point.y - pt.y;
        pt = {
          p : pt,
          distSq : dx * dx + dy * dy
        };
        if (null != pt) {
          if (null == min || min.distSq > pt.distSq) {
            min = pt;
          }
        }
      }
    }
    return null != min ? min.p : null;
  },
  intersectsPoints : function(rect, pts) {
    for (var i = 0;i < pts.length - 1;i++) {
      if (mxUtils.rectangleIntersectsSegment(rect, pts[i], pts[i + 1])) {
        return true;
      }
    }
    return false;
  },
  rectangleIntersectsSegment : function(bounds, p1, p2) {
    var top = bounds.y;
    var left = bounds.x;
    var bottom = top + bounds.height;
    var right = left + bounds.width;
    bounds = p1.x;
    var maxX = p2.x;
    if (p1.x > p2.x) {
      bounds = p2.x;
      maxX = p1.x;
    }
    if (maxX > right) {
      maxX = right;
    }
    if (bounds < left) {
      bounds = left;
    }
    if (bounds > maxX) {
      return false;
    }
    left = p1.y;
    right = p2.y;
    var dist = p2.x - p1.x;
    if (1E-7 < Math.abs(dist)) {
      p2 = (p2.y - p1.y) / dist;
      p1 = p1.y - p2 * p1.x;
      left = p2 * bounds + p1;
      right = p2 * maxX + p1;
    }
    if (left > right) {
      p1 = right;
      right = left;
      left = p1;
    }
    if (right > bottom) {
      right = bottom;
    }
    if (left < top) {
      left = top;
    }
    return left > right ? false : true;
  },
  contains : function(cell, x, y) {
    return cell.x <= x && (cell.x + cell.width >= x && (cell.y <= y && cell.y + cell.height >= y));
  },
  intersects : function(a, x) {
    var tw = a.width;
    var th = a.height;
    var rw = x.width;
    var rh = x.height;
    if (0 >= rw || (0 >= rh || (0 >= tw || 0 >= th))) {
      return false;
    }
    var tx = a.x;
    var ty = a.y;
    var rx = x.x;
    var ry = x.y;
    rw = rw + rx;
    rh = rh + ry;
    tw = tw + tx;
    th = th + ty;
    return(rw < rx || rw > tx) && ((rh < ry || rh > ty) && ((tw < tx || tw > rx) && (th < ty || th > ry)));
  },
  intersectsHotspot : function(state, x, y, hotspot, min, max) {
    hotspot = null != hotspot ? hotspot : 1;
    min = null != min ? min : 0;
    max = null != max ? max : 0;
    if (0 < hotspot) {
      var cx = state.getCenterX();
      var cy = state.getCenterY();
      var w = state.width;
      var h = state.height;
      var start = mxUtils.getValue(state.style, mxConstants.STYLE_STARTSIZE) * state.view.scale;
      if (0 < start) {
        if (mxUtils.getValue(state.style, mxConstants.STYLE_HORIZONTAL, true)) {
          cy = state.y + start / 2;
          h = start;
        } else {
          cx = state.x + start / 2;
          w = start;
        }
      }
      w = Math.max(min, w * hotspot);
      h = Math.max(min, h * hotspot);
      if (0 < max) {
        w = Math.min(w, max);
        h = Math.min(h, max);
      }
      hotspot = new mxRectangle(cx - w / 2, cy - h / 2, w, h);
      cx = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);
      if (0 != cx) {
        min = Math.cos(-cx);
        max = Math.sin(-cx);
        cx = new mxPoint(state.getCenterX(), state.getCenterY());
        state = mxUtils.getRotatedPoint(new mxPoint(x, y), min, max, cx);
        x = state.x;
        y = state.y;
      }
      return mxUtils.contains(hotspot, x, y);
    }
    return true;
  },
  getOffset : function(container, scrollOffset) {
    var offsetLeft = 0;
    var offsetTop = 0;
    var fixed = false;
    var node = container;
    var b = document.body;
    for (var d = document.documentElement;null != node && (node != b && (node != d && !fixed));) {
      var style = mxUtils.getCurrentStyle(node);
      if (null != style) {
        fixed = fixed || "fixed" == style.position;
      }
      node = node.parentNode;
    }
    if (!scrollOffset) {
      if (!fixed) {
        var offset = mxUtils.getDocumentScrollOrigin(container.ownerDocument);
        offsetLeft += offset.x;
        offsetTop += offset.y;
      }
    }
    var r = container.getBoundingClientRect();
    if (null != r) {
      offsetLeft += r.left;
      offsetTop += r.top;
    }
    return new mxPoint(offsetLeft, offsetTop);
  },
  getDocumentScrollOrigin : function(doc) {
    doc = doc.defaultView || doc.parentWindow;
    return new mxPoint(null != doc && void 0 !== window.pageXOffset ? window.pageXOffset : (document.documentElement || (document.body.parentNode || document.body)).scrollLeft, null != doc && void 0 !== window.pageYOffset ? window.pageYOffset : (document.documentElement || (document.body.parentNode || document.body)).scrollTop);
  },
  getScrollOrigin : function(node, includeAncestors, includeDocument) {
    includeAncestors = null != includeAncestors ? includeAncestors : false;
    includeDocument = null != includeDocument ? includeDocument : true;
    var doc = null != node ? node.ownerDocument : document;
    var b = doc.body;
    var d = doc.documentElement;
    var result = new mxPoint;
    for (var fixed = false;null != node && (node != b && node != d);) {
      if (!isNaN(node.scrollLeft)) {
        if (!isNaN(node.scrollTop)) {
          result.x += node.scrollLeft;
          result.y += node.scrollTop;
        }
      }
      var style = mxUtils.getCurrentStyle(node);
      if (null != style) {
        fixed = fixed || "fixed" == style.position;
      }
      node = includeAncestors ? node.parentNode : null;
    }
    if (!fixed) {
      if (includeDocument) {
        node = mxUtils.getDocumentScrollOrigin(doc);
        result.x += node.x;
        result.y += node.y;
      }
    }
    return result;
  },
  convertPoint : function(container, x, y) {
    var origin = mxUtils.getScrollOrigin(container, false);
    var offset = mxUtils.getOffset(container);
    offset.x -= origin.x;
    offset.y -= origin.y;
    return new mxPoint(x - offset.x, y - offset.y);
  },
  ltrim : function(str, chars) {
    return null != str ? str.replace(new RegExp("^[" + (chars || "\\s") + "]+", "g"), "") : null;
  },
  rtrim : function(str, chars) {
    return null != str ? str.replace(new RegExp("[" + (chars || "\\s") + "]+$", "g"), "") : null;
  },
  trim : function(str, chars) {
    return mxUtils.ltrim(mxUtils.rtrim(str, chars), chars);
  },
  isNumeric : function(n) {
    return!isNaN(parseFloat(n)) && (isFinite(n) && ("string" != typeof n || 0 > n.toLowerCase().indexOf("0x")));
  },
  isInteger : function(n) {
    return String(parseInt(n)) === String(n);
  },
  mod : function(angle, defaultValue) {
    return(angle % defaultValue + defaultValue) % defaultValue;
  },
  intersection : function(x2, y0, x0, y1, x1, y2, x3, y3) {
    var l = (y3 - y2) * (x0 - x2) - (x3 - x1) * (y1 - y0);
    x3 = ((x3 - x1) * (y0 - y2) - (y3 - y2) * (x2 - x1)) / l;
    x1 = ((x0 - x2) * (y0 - y2) - (y1 - y0) * (x2 - x1)) / l;
    return 0 <= x3 && (1 >= x3 && (0 <= x1 && 1 >= x1)) ? new mxPoint(x2 + x3 * (x0 - x2), y0 + x3 * (y1 - y0)) : null;
  },
  ptSegDistSq : function(x1, y1, x2, y2, px, py) {
    x2 -= x1;
    y2 -= y1;
    px -= x1;
    py -= y1;
    if (0 >= px * x2 + py * y2) {
      x2 = 0;
    } else {
      px = x2 - px;
      py = y2 - py;
      x1 = px * x2 + py * y2;
      x2 = 0 >= x1 ? 0 : x1 * x1 / (x2 * x2 + y2 * y2);
    }
    px = px * px + py * py - x2;
    if (0 > px) {
      px = 0;
    }
    return px;
  },
  ptLineDist : function(y1, x1, y2, x2, py, px) {
    return Math.abs((x2 - x1) * py - (y2 - y1) * px + y2 * x1 - x2 * y1) / Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  },
  relativeCcw : function(x1, y1, x2, y2, px, py) {
    x2 -= x1;
    y2 -= y1;
    px -= x1;
    py -= y1;
    x1 = px * y2 - py * x2;
    if (0 == x1) {
      x1 = px * x2 + py * y2;
      if (0 < x1) {
        x1 = (px - x2) * x2 + (py - y2) * y2;
        if (0 > x1) {
          x1 = 0;
        }
      }
    }
    return 0 > x1 ? -1 : 0 < x1 ? 1 : 0;
  },
  animateChanges : function(graph, changes) {
    mxEffects.animateChanges.apply(this, arguments);
  },
  cascadeOpacity : function(graph, cell, opacity) {
    mxEffects.cascadeOpacity.apply(this, arguments);
  },
  fadeOut : function(delay, node, from, step, isEnabled, remove) {
    mxEffects.fadeOut.apply(this, arguments);
  },
  setOpacity : function(node, opacity) {
    if (mxClient.IS_IE && ("undefined" === typeof document.documentMode || 9 > document.documentMode)) {
      node.style.filter = 100 <= opacity ? "" : "alpha(opacity=" + opacity + ")";
    } else {
      node.style.opacity = opacity / 100;
    }
  },
  createImage : function(src) {
    var imageNode = document.createElement("img");
    imageNode.setAttribute("src", src);
    imageNode.setAttribute("border", "0");
    return imageNode;
  },
  sortCells : function(cells, initialMove) {
    initialMove = null != initialMove ? initialMove : true;
    var lookup = new mxDictionary;
    cells.sort(function(cell, terminal) {
      var p1 = lookup.get(cell);
      if (null == p1) {
        p1 = mxCellPath.create(cell).split(mxCellPath.PATH_SEPARATOR);
        lookup.put(cell, p1);
      }
      var p2 = lookup.get(terminal);
      if (null == p2) {
        p2 = mxCellPath.create(terminal).split(mxCellPath.PATH_SEPARATOR);
        lookup.put(terminal, p2);
      }
      p1 = mxCellPath.compare(p1, p2);
      return 0 == p1 ? 0 : 0 < p1 == initialMove ? 1 : -1;
    });
    return cells;
  },
  getStylename : function(style) {
    return null != style && (style = style.split(";")[0], 0 > style.indexOf("=")) ? style : "";
  },
  getStylenames : function(tokens) {
    var result = [];
    if (null != tokens) {
      tokens = tokens.split(";");
      for (var i = 0;i < tokens.length;i++) {
        if (0 > tokens[i].indexOf("=")) {
          result.push(tokens[i]);
        }
      }
    }
    return result;
  },
  indexOfStylename : function(style, stylename) {
    if (null != style && null != stylename) {
      var tokens = style.split(";");
      var pos = 0;
      for (var i = 0;i < tokens.length;i++) {
        if (tokens[i] == stylename) {
          return pos;
        }
        pos += tokens[i].length + 1;
      }
    }
    return-1;
  },
  addStylename : function(style, stylename) {
    if (0 > mxUtils.indexOfStylename(style, stylename)) {
      if (null == style) {
        style = "";
      } else {
        if (0 < style.length) {
          if (";" != style.charAt(style.length - 1)) {
            style += ";";
          }
        }
      }
      style += stylename;
    }
    return style;
  },
  removeStylename : function(style, stylename) {
    var result = [];
    if (null != style) {
      var tokens = style.split(";");
      for (var i = 0;i < tokens.length;i++) {
        if (tokens[i] != stylename) {
          result.push(tokens[i]);
        }
      }
    }
    return result.join(";");
  },
  removeAllStylenames : function(tokens) {
    var result = [];
    if (null != tokens) {
      tokens = tokens.split(";");
      for (var i = 0;i < tokens.length;i++) {
        if (0 <= tokens[i].indexOf("=")) {
          result.push(tokens[i]);
        }
      }
    }
    return result.join(";");
  },
  setCellStyles : function(model, value, key, flag) {
    if (null != value && 0 < value.length) {
      model.beginUpdate();
      try {
        for (var i = 0;i < value.length;i++) {
          if (null != value[i]) {
            var style = mxUtils.setStyle(model.getStyle(value[i]), key, flag);
            model.setStyle(value[i], style);
          }
        }
      } finally {
        model.endUpdate();
      }
    }
  },
  hex2rgb : function(url) {
    if (null != url && (7 == url.length && "#" == url.charAt(0))) {
      var current = parseInt(url.substring(1, 3), 16);
      var w = parseInt(url.substring(3, 5), 16);
      url = parseInt(url.substring(5, 7), 16);
      url = "rgb(" + current + ", " + w + ", " + url + ")";
    }
    return url;
  },
  hex2rgba : function(url) {
    if (null != url && (7 <= url.length && "#" == url.charAt(0))) {
      var current = parseInt(url.substring(1, 3), 16);
      var w = parseInt(url.substring(3, 5), 16);
      var left = parseInt(url.substring(5, 7), 16);
      var e = 1;
      if (7 < url.length) {
        e = parseInt(url.substring(7, 9), 16) / 255;
      }
      url = "rgba(" + current + ", " + w + ", " + left + ", " + e + ")";
    }
    return url;
  },
  rgba2hex : function(start) {
    return(rgb = start && start.match ? start.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i) : start) && 4 === rgb.length ? "#" + ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2) : start;
  },
  setCssText : function(fo, value) {
    if (null != fo && null != value) {
      value = value.split(";");
      for (var i = 0;i < value.length;i++) {
        var lines = value[i].split(":");
        if (1 < lines.length) {
          lines[0] = mxUtils.trim(lines[0].replace(/-([a-z])/gi, function(editor, flex) {
            return flex.toUpperCase();
          }));
          fo[lines[0]] = mxUtils.trim(lines[1]);
        }
      }
    }
  },
  setStyle : function(style, key, flag) {
    var sep = null != flag && ("undefined" == typeof flag.length || 0 < flag.length);
    if (null == style || 0 == style.length) {
      if (sep) {
        style = key + "=" + flag + ";";
      }
    } else {
      if (style.substring(0, key.length + 1) == key + "=") {
        var next = style.indexOf(";");
        style = sep ? key + "=" + flag + (0 > next ? ";" : style.substring(next)) : 0 > next || next == style.length - 1 ? "" : style.substring(next + 1);
      } else {
        var index = style.indexOf(";" + key + "=");
        if (0 > index) {
          if (sep) {
            sep = ";" == style.charAt(style.length - 1) ? "" : ";";
            style = style + sep + key + "=" + flag + ";";
          }
        } else {
          next = style.indexOf(";", index + 1);
          style = sep ? style.substring(0, index + 1) + key + "=" + flag + (0 > next ? ";" : style.substring(next)) : style.substring(0, index) + (0 > next ? ";" : style.substring(next));
        }
      }
    }
    return style;
  },
  setCellStyleFlags : function(model, cells, key, flag, value) {
    if (null != cells && 0 < cells.length) {
      model.beginUpdate();
      try {
        for (var i = 0;i < cells.length;i++) {
          if (null != cells[i]) {
            var style = mxUtils.setStyleFlag(model.getStyle(cells[i]), key, flag, value);
            model.setStyle(cells[i], style);
          }
        }
      } finally {
        model.endUpdate();
      }
    }
  },
  setStyleFlag : function(style, key, flag, value) {
    if (null == style || 0 == style.length) {
      style = value || null == value ? key + "=" + flag : key + "=0";
    } else {
      var index = style.indexOf(key + "=");
      if (0 > index) {
        index = ";" == style.charAt(style.length - 1) ? "" : ";";
        style = value || null == value ? style + index + key + "=" + flag : style + index + key + "=0";
      } else {
        var cont = style.indexOf(";", index);
        var tmp = 0 > cont ? style.substring(index + key.length + 1) : style.substring(index + key.length + 1, cont);
        tmp = null == value ? parseInt(tmp) ^ flag : value ? parseInt(tmp) | flag : parseInt(tmp) & ~flag;
        style = style.substring(0, index) + key + "=" + tmp + (0 <= cont ? style.substring(cont) : "");
      }
    }
    return style;
  },
  getAlignmentAsPoint : function(align, valign) {
    var x = -0.5;
    var y = -0.5;
    if (align == mxConstants.ALIGN_LEFT) {
      x = 0;
    } else {
      if (align == mxConstants.ALIGN_RIGHT) {
        x = -1;
      }
    }
    if (valign == mxConstants.ALIGN_TOP) {
      y = 0;
    } else {
      if (valign == mxConstants.ALIGN_BOTTOM) {
        y = -1;
      }
    }
    return new mxPoint(x, y);
  },
  getSizeForString : function(text, fontSize, fontFamily, width, fontStyle) {
    fontSize = null != fontSize ? fontSize : mxConstants.DEFAULT_FONTSIZE;
    fontFamily = null != fontFamily ? fontFamily : mxConstants.DEFAULT_FONTFAMILY;
    var div = document.createElement("div");
    div.style.fontFamily = fontFamily;
    div.style.fontSize = Math.round(fontSize) + "px";
    div.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT * mxSvgCanvas2D.prototype.lineHeightCorrection;
    if (null != fontStyle) {
      if ((fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
        div.style.fontWeight = "bold";
      }
      if ((fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
        div.style.fontStyle = "italic";
      }
      fontSize = [];
      if ((fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
        fontSize.push("underline");
      }
      if ((fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
        fontSize.push("line-through");
      }
      if (0 < fontSize.length) {
        div.style.textDecoration = fontSize.join(" ");
      }
    }
    div.style.position = "absolute";
    div.style.visibility = "hidden";
    div.style.display = "inline-block";
    div.style.zoom = "1";
    if (null != width) {
      div.style.width = width + "px";
      div.style.whiteSpace = "normal";
    } else {
      div.style.whiteSpace = "nowrap";
    }
    div.innerHTML = text;
    document.body.appendChild(div);
    text = new mxRectangle(0, 0, div.offsetWidth, div.offsetHeight);
    document.body.removeChild(div);
    return text;
  },
  getViewXml : function(graph, scale, cells, x0, y0) {
    x0 = null != x0 ? x0 : 0;
    y0 = null != y0 ? y0 : 0;
    scale = null != scale ? scale : 1;
    if (null == cells) {
      cells = [graph.getModel().getRoot()];
    }
    var view = graph.getView();
    var result = null;
    var eventsEnabled = view.isEventsEnabled();
    view.setEventsEnabled(false);
    var drawPane = view.drawPane;
    var overlayPane = view.overlayPane;
    if (graph.dialect == mxConstants.DIALECT_SVG) {
      view.drawPane = document.createElementNS(mxConstants.NS_SVG, "g");
      view.canvas.appendChild(view.drawPane);
      view.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g");
    } else {
      view.drawPane = view.drawPane.cloneNode(false);
      view.canvas.appendChild(view.drawPane);
      view.overlayPane = view.overlayPane.cloneNode(false);
    }
    view.canvas.appendChild(view.overlayPane);
    var translate = view.getTranslate();
    view.translate = new mxPoint(x0, y0);
    scale = new mxTemporaryCellStates(graph.getView(), scale, cells);
    try {
      result = (new mxCodec).encode(graph.getView());
    } finally {
      scale.destroy();
      view.translate = translate;
      view.canvas.removeChild(view.drawPane);
      view.canvas.removeChild(view.overlayPane);
      view.drawPane = drawPane;
      view.overlayPane = overlayPane;
      view.setEventsEnabled(eventsEnabled);
    }
    return result;
  },
  getScaleForPageCount : function(pageCount, graph, numRowPages, numColumnPages) {
    if (1 > pageCount) {
      return 1;
    }
    numRowPages = null != numRowPages ? numRowPages : mxConstants.PAGE_FORMAT_A4_PORTRAIT;
    numColumnPages = null != numColumnPages ? numColumnPages : 0;
    var availablePageWidth = numRowPages.width - 2 * numColumnPages;
    numRowPages = numRowPages.height - 2 * numColumnPages;
    numColumnPages = graph.getGraphBounds().clone();
    graph = graph.getView().getScale();
    numColumnPages.width /= graph;
    numColumnPages.height /= graph;
    graph = numColumnPages.width;
    var pageRoot = Math.sqrt(pageCount);
    numColumnPages = Math.sqrt(graph / numColumnPages.height / (availablePageWidth / numRowPages));
    numRowPages = pageRoot * numColumnPages;
    numColumnPages = pageRoot / numColumnPages;
    if (1 > numRowPages && numColumnPages > pageCount) {
      var scaleChange = numColumnPages / pageCount;
      numColumnPages = pageCount;
      numRowPages /= scaleChange;
    }
    if (1 > numColumnPages) {
      if (numRowPages > pageCount) {
        scaleChange = numRowPages / pageCount;
        numRowPages = pageCount;
        numColumnPages /= scaleChange;
      }
    }
    scaleChange = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
    for (pageRoot = 0;scaleChange > pageCount;) {
      scaleChange = Math.floor(numRowPages) / numRowPages;
      var roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;
      if (1 == scaleChange) {
        scaleChange = Math.floor(numRowPages - 1) / numRowPages;
      }
      if (1 == roundColumnDownProportion) {
        roundColumnDownProportion = Math.floor(numColumnPages - 1) / numColumnPages;
      }
      scaleChange = scaleChange > roundColumnDownProportion ? scaleChange : roundColumnDownProportion;
      numRowPages *= scaleChange;
      numColumnPages *= scaleChange;
      scaleChange = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
      pageRoot++;
      if (10 < pageRoot) {
        break;
      }
    }
    return availablePageWidth * numRowPages / graph * 0.99999;
  },
  show : function(graph, doc, outer, y0, node, tmp) {
    outer = null != outer ? outer : 0;
    y0 = null != y0 ? y0 : 0;
    if (null == doc) {
      doc = window.open().document;
    } else {
      doc.open();
    }
    if (9 == document.documentMode) {
      doc.writeln('\x3c!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=9"><![endif]--\x3e');
    }
    var bounds = graph.getGraphBounds();
    var dx = Math.ceil(outer - bounds.x);
    var dy = Math.ceil(y0 - bounds.y);
    if (null == node) {
      node = Math.ceil(bounds.width + outer) + Math.ceil(Math.ceil(bounds.x) - bounds.x);
    }
    if (null == tmp) {
      tmp = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);
    }
    if (mxClient.IS_IE || 11 == document.documentMode) {
      y0 = "<html><head>";
      bounds = document.getElementsByTagName("base");
      for (outer = 0;outer < bounds.length;outer++) {
        y0 += bounds[outer].outerHTML;
      }
      y0 += "<style>";
      for (outer = 0;outer < document.styleSheets.length;outer++) {
        try {
          y0 += document.styleSheets[outer].cssText;
        } catch (m) {
        }
      }
      y0 = y0 + '</style></head><body style="margin:0px;"><div style="position:absolute;overflow:hidden;width:' + (node + "px;height:" + tmp + 'px;"><div style="position:relative;left:' + dx + "px;top:" + dy + 'px;">') + graph.container.innerHTML;
      doc.writeln(y0 + "</div></div></body><html>");
      doc.close();
    } else {
      doc.writeln("<html><head>");
      bounds = document.getElementsByTagName("base");
      for (outer = 0;outer < bounds.length;outer++) {
        doc.writeln(mxUtils.getOuterHtml(bounds[outer]));
      }
      y0 = document.getElementsByTagName("link");
      for (outer = 0;outer < y0.length;outer++) {
        doc.writeln(mxUtils.getOuterHtml(y0[outer]));
      }
      y0 = document.getElementsByTagName("style");
      for (outer = 0;outer < y0.length;outer++) {
        doc.writeln(mxUtils.getOuterHtml(y0[outer]));
      }
      doc.writeln('</head><body style="margin:0px;"></body></html>');
      doc.close();
      outer = doc.createElement("div");
      outer.position = "absolute";
      outer.overflow = "hidden";
      outer.style.width = node + "px";
      outer.style.height = tmp + "px";
      node = doc.createElement("div");
      node.style.position = "absolute";
      node.style.left = dx + "px";
      node.style.top = dy + "px";
      tmp = graph.container.firstChild;
      for (y0 = null;null != tmp;) {
        bounds = tmp.cloneNode(true);
        if (tmp == graph.view.drawPane.ownerSVGElement) {
          outer.appendChild(bounds);
          y0 = bounds;
        } else {
          node.appendChild(bounds);
        }
        tmp = tmp.nextSibling;
      }
      doc.body.appendChild(outer);
      if (null != node.firstChild) {
        doc.body.appendChild(node);
      }
      if (null != y0) {
        y0.style.minWidth = "";
        y0.style.minHeight = "";
        y0.firstChild.setAttribute("transform", "translate(" + dx + "," + dy + ")");
      }
    }
    mxUtils.removeCursors(doc.body);
    return doc;
  },
  printScreen : function(print) {
    var wnd = window.open();
    print.getGraphBounds();
    mxUtils.show(print, wnd.document);
    print = function() {
      wnd.focus();
      wnd.print();
      wnd.close();
    };
    if (mxClient.IS_GC) {
      wnd.setTimeout(print, 500);
    } else {
      print();
    }
  },
  popup : function(content, isInternalWindow) {
    if (isInternalWindow) {
      var div = document.createElement("div");
      div.style.overflow = "scroll";
      div.style.width = "636px";
      div.style.height = "460px";
      var pre = document.createElement("pre");
      pre.innerHTML = mxUtils.htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
      div.appendChild(pre);
      div = new mxWindow("Popup Window", div, document.body.clientWidth / 2 - 320, Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight) / 2 - 240, 640, 480, false, true);
      div.setClosable(true);
      div.setVisible(true);
    } else {
      if (mxClient.IS_NS) {
        div = window.open();
        div.document.writeln("<pre>" + mxUtils.htmlEntities(content) + "</pre");
        div.document.close();
      } else {
        div = window.open();
        pre = div.document.createElement("pre");
        pre.innerHTML = mxUtils.htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
        div.document.body.appendChild(pre);
      }
    }
  },
  alert : function(message) {
    alert(message);
  },
  prompt : function(message, defaultValue) {
    return prompt(message, null != defaultValue ? defaultValue : "");
  },
  confirm : function(message) {
    return confirm(message);
  },
  error : function(x, y, button, icon) {
    var div = document.createElement("div");
    div.style.padding = "20px";
    var img = document.createElement("img");
    img.setAttribute("src", icon || mxUtils.errorImage);
    img.setAttribute("valign", "bottom");
    img.style.verticalAlign = "middle";
    div.appendChild(img);
    div.appendChild(document.createTextNode("\u00a0"));
    div.appendChild(document.createTextNode("\u00a0"));
    div.appendChild(document.createTextNode("\u00a0"));
    mxUtils.write(div, x);
    x = document.body.clientWidth;
    icon = document.body.clientHeight || document.documentElement.clientHeight;
    var warn = new mxWindow(mxResources.get(mxUtils.errorResource) || mxUtils.errorResource, div, (x - y) / 2, icon / 4, y, null, false, true);
    if (button) {
      mxUtils.br(div);
      y = document.createElement("p");
      button = document.createElement("button");
      if (mxClient.IS_IE) {
        button.style.cssText = "float:right";
      } else {
        button.setAttribute("style", "float:right");
      }
      mxEvent.addListener(button, "click", function(flex) {
        warn.destroy();
      });
      mxUtils.write(button, mxResources.get(mxUtils.closeResource) || mxUtils.closeResource);
      y.appendChild(button);
      div.appendChild(y);
      mxUtils.br(div);
      warn.setClosable(true);
    }
    warn.setVisible(true);
    return warn;
  },
  makeDraggable : function(dragSource, graphF, funct, dragElement, dx, dy, autoscroll, scalePreview, highlightDropTargets, getDropTarget) {
    dragSource = new mxDragSource(dragSource, funct);
    dragSource.dragOffset = new mxPoint(null != dx ? dx : 0, null != dy ? dy : mxConstants.TOOLTIP_VERTICAL_OFFSET);
    dragSource.autoscroll = autoscroll;
    dragSource.setGuidesEnabled(false);
    if (null != highlightDropTargets) {
      dragSource.highlightDropTargets = highlightDropTargets;
    }
    if (null != getDropTarget) {
      dragSource.getDropTarget = getDropTarget;
    }
    dragSource.getGraphForEvent = function(evt) {
      return "function" == typeof graphF ? graphF(evt) : graphF;
    };
    if (null != dragElement) {
      dragSource.createDragElement = function() {
        return dragElement.cloneNode(true);
      };
      if (scalePreview) {
        dragSource.createPreviewElement = function(graph) {
          var elt = dragElement.cloneNode(true);
          var h = parseInt(elt.style.width);
          var w = parseInt(elt.style.height);
          elt.style.width = Math.round(h * graph.view.scale) + "px";
          elt.style.height = Math.round(w * graph.view.scale) + "px";
          return elt;
        };
      }
    }
    return dragSource;
  },
  format : function(value) {
    return parseFloat(parseFloat(value).toFixed(2));
  }
};
var mxConstants = {
  DEFAULT_HOTSPOT : 0.3,
  MIN_HOTSPOT_SIZE : 8,
  MAX_HOTSPOT_SIZE : 0,
  RENDERING_HINT_EXACT : "exact",
  RENDERING_HINT_FASTER : "faster",
  RENDERING_HINT_FASTEST : "fastest",
  DIALECT_SVG : "svg",
  DIALECT_MIXEDHTML : "mixedHtml",
  DIALECT_PREFERHTML : "preferHtml",
  DIALECT_STRICTHTML : "strictHtml",
  NS_SVG : "http://www.w3.org/2000/svg",
  NS_XHTML : "http://www.w3.org/1999/xhtml",
  NS_XLINK : "http://www.w3.org/1999/xlink",
  SHADOWCOLOR : "gray",
  VML_SHADOWCOLOR : "gray",
  SHADOW_OFFSET_X : 2,
  SHADOW_OFFSET_Y : 3,
  SHADOW_OPACITY : 1,
  NODETYPE_ELEMENT : 1,
  NODETYPE_ATTRIBUTE : 2,
  NODETYPE_TEXT : 3,
  NODETYPE_CDATA : 4,
  NODETYPE_ENTITY_REFERENCE : 5,
  NODETYPE_ENTITY : 6,
  NODETYPE_PROCESSING_INSTRUCTION : 7,
  NODETYPE_COMMENT : 8,
  NODETYPE_DOCUMENT : 9,
  NODETYPE_DOCUMENTTYPE : 10,
  NODETYPE_DOCUMENT_FRAGMENT : 11,
  NODETYPE_NOTATION : 12,
  TOOLTIP_VERTICAL_OFFSET : 16,
  DEFAULT_VALID_COLOR : "#00FF00",
  DEFAULT_INVALID_COLOR : "#FF0000",
  OUTLINE_HIGHLIGHT_COLOR : "#00FF00",
  OUTLINE_HIGHLIGHT_STROKEWIDTH : 5,
  HIGHLIGHT_STROKEWIDTH : 3,
  HIGHLIGHT_SIZE : 2,
  HIGHLIGHT_OPACITY : 100,
  CURSOR_MOVABLE_VERTEX : "move",
  CURSOR_MOVABLE_EDGE : "move",
  CURSOR_LABEL_HANDLE : "default",
  CURSOR_TERMINAL_HANDLE : "pointer",
  CURSOR_BEND_HANDLE : "crosshair",
  CURSOR_VIRTUAL_BEND_HANDLE : "crosshair",
  CURSOR_CONNECT : "pointer",
  HIGHLIGHT_COLOR : "#00FF00",
  CONNECT_TARGET_COLOR : "#0000FF",
  INVALID_CONNECT_TARGET_COLOR : "#FF0000",
  DROP_TARGET_COLOR : "#0000FF",
  VALID_COLOR : "#00FF00",
  INVALID_COLOR : "#FF0000",
  EDGE_SELECTION_COLOR : "#00FF00",
  VERTEX_SELECTION_COLOR : "#00FF00",
  VERTEX_SELECTION_STROKEWIDTH : 1,
  EDGE_SELECTION_STROKEWIDTH : 1,
  VERTEX_SELECTION_DASHED : true,
  EDGE_SELECTION_DASHED : true,
  GUIDE_COLOR : "#FF0000",
  GUIDE_STROKEWIDTH : 1,
  OUTLINE_COLOR : "#0099FF",
  OUTLINE_STROKEWIDTH : mxClient.IS_IE ? 2 : 3,
  HANDLE_SIZE : 6,
  LABEL_HANDLE_SIZE : 4,
  HANDLE_FILLCOLOR : "#00FF00",
  HANDLE_STROKECOLOR : "black",
  LABEL_HANDLE_FILLCOLOR : "yellow",
  CONNECT_HANDLE_FILLCOLOR : "#0000FF",
  LOCKED_HANDLE_FILLCOLOR : "#FF0000",
  OUTLINE_HANDLE_FILLCOLOR : "#00FFFF",
  OUTLINE_HANDLE_STROKECOLOR : "#0033FF",
  DEFAULT_FONTFAMILY : "Arial,Helvetica",
  DEFAULT_FONTSIZE : 11,
  DEFAULT_TEXT_DIRECTION : "",
  LINE_HEIGHT : 1.2,
  WORD_WRAP : "normal",
  ABSOLUTE_LINE_HEIGHT : false,
  DEFAULT_FONTSTYLE : 0,
  DEFAULT_STARTSIZE : 40,
  DEFAULT_MARKERSIZE : 6,
  DEFAULT_IMAGESIZE : 24,
  ENTITY_SEGMENT : 30,
  RECTANGLE_ROUNDING_FACTOR : 0.15,
  LINE_ARCSIZE : 20,
  ARROW_SPACING : 0,
  ARROW_WIDTH : 30,
  ARROW_SIZE : 30,
  PAGE_FORMAT_A4_PORTRAIT : new mxRectangle(0, 0, 827, 1169),
  PAGE_FORMAT_A4_LANDSCAPE : new mxRectangle(0, 0, 1169, 827),
  PAGE_FORMAT_LETTER_PORTRAIT : new mxRectangle(0, 0, 850, 1100),
  PAGE_FORMAT_LETTER_LANDSCAPE : new mxRectangle(0, 0, 1100, 850),
  NONE : "none",
  STYLE_PERIMETER : "perimeter",
  STYLE_SOURCE_PORT : "sourcePort",
  STYLE_TARGET_PORT : "targetPort",
  STYLE_PORT_CONSTRAINT : "portConstraint",
  STYLE_PORT_CONSTRAINT_ROTATION : "portConstraintRotation",
  STYLE_SOURCE_PORT_CONSTRAINT : "sourcePortConstraint",
  STYLE_TARGET_PORT_CONSTRAINT : "targetPortConstraint",
  STYLE_OPACITY : "opacity",
  STYLE_FILL_OPACITY : "fillOpacity",
  STYLE_FILL_STYLE : "fillStyle",
  STYLE_STROKE_OPACITY : "strokeOpacity",
  STYLE_TEXT_OPACITY : "textOpacity",
  STYLE_TEXT_DIRECTION : "textDirection",
  STYLE_OVERFLOW : "overflow",
  STYLE_BLOCK_SPACING : "blockSpacing",
  STYLE_ORTHOGONAL : "orthogonal",
  STYLE_EXIT_X : "exitX",
  STYLE_EXIT_Y : "exitY",
  STYLE_EXIT_DX : "exitDx",
  STYLE_EXIT_DY : "exitDy",
  STYLE_EXIT_PERIMETER : "exitPerimeter",
  STYLE_ENTRY_X : "entryX",
  STYLE_ENTRY_Y : "entryY",
  STYLE_ENTRY_DX : "entryDx",
  STYLE_ENTRY_DY : "entryDy",
  STYLE_ENTRY_PERIMETER : "entryPerimeter",
  STYLE_WHITE_SPACE : "whiteSpace",
  STYLE_ROTATION : "rotation",
  STYLE_FILLCOLOR : "fillColor",
  STYLE_POINTER_EVENTS : "pointerEvents",
  STYLE_SWIMLANE_FILLCOLOR : "swimlaneFillColor",
  STYLE_MARGIN : "margin",
  STYLE_GRADIENTCOLOR : "gradientColor",
  STYLE_GRADIENT_DIRECTION : "gradientDirection",
  STYLE_STROKECOLOR : "strokeColor",
  STYLE_SEPARATORCOLOR : "separatorColor",
  STYLE_STROKEWIDTH : "strokeWidth",
  STYLE_ALIGN : "align",
  STYLE_VERTICAL_ALIGN : "verticalAlign",
  STYLE_LABEL_WIDTH : "labelWidth",
  STYLE_LABEL_POSITION : "labelPosition",
  STYLE_VERTICAL_LABEL_POSITION : "verticalLabelPosition",
  STYLE_IMAGE_ASPECT : "imageAspect",
  STYLE_IMAGE_ALIGN : "imageAlign",
  STYLE_IMAGE_VERTICAL_ALIGN : "imageVerticalAlign",
  STYLE_GLASS : "glass",
  STYLE_IMAGE : "image",
  STYLE_IMAGE_WIDTH : "imageWidth",
  STYLE_IMAGE_HEIGHT : "imageHeight",
  STYLE_IMAGE_BACKGROUND : "imageBackground",
  STYLE_IMAGE_BORDER : "imageBorder",
  STYLE_FLIPH : "flipH",
  STYLE_FLIPV : "flipV",
  STYLE_NOLABEL : "noLabel",
  STYLE_NOEDGESTYLE : "noEdgeStyle",
  STYLE_LABEL_BACKGROUNDCOLOR : "labelBackgroundColor",
  STYLE_LABEL_BORDERCOLOR : "labelBorderColor",
  STYLE_LABEL_PADDING : "labelPadding",
  STYLE_INDICATOR_SHAPE : "indicatorShape",
  STYLE_INDICATOR_IMAGE : "indicatorImage",
  STYLE_INDICATOR_COLOR : "indicatorColor",
  STYLE_INDICATOR_STROKECOLOR : "indicatorStrokeColor",
  STYLE_INDICATOR_GRADIENTCOLOR : "indicatorGradientColor",
  STYLE_INDICATOR_SPACING : "indicatorSpacing",
  STYLE_INDICATOR_WIDTH : "indicatorWidth",
  STYLE_INDICATOR_HEIGHT : "indicatorHeight",
  STYLE_INDICATOR_DIRECTION : "indicatorDirection",
  STYLE_SHADOW : "shadow",
  STYLE_SEGMENT : "segment",
  STYLE_ENDARROW : "endArrow",
  STYLE_STARTARROW : "startArrow",
  STYLE_ENDSIZE : "endSize",
  STYLE_STARTSIZE : "startSize",
  STYLE_SWIMLANE_LINE : "swimlaneLine",
  STYLE_SWIMLANE_HEAD : "swimlaneHead",
  STYLE_SWIMLANE_BODY : "swimlaneBody",
  STYLE_ENDFILL : "endFill",
  STYLE_STARTFILL : "startFill",
  STYLE_DASHED : "dashed",
  STYLE_DASH_PATTERN : "dashPattern",
  STYLE_FIX_DASH : "fixDash",
  STYLE_ROUNDED : "rounded",
  STYLE_CURVED : "curved",
  STYLE_ARCSIZE : "arcSize",
  STYLE_ABSOLUTE_ARCSIZE : "absoluteArcSize",
  STYLE_SOURCE_PERIMETER_SPACING : "sourcePerimeterSpacing",
  STYLE_TARGET_PERIMETER_SPACING : "targetPerimeterSpacing",
  STYLE_PERIMETER_SPACING : "perimeterSpacing",
  STYLE_SPACING : "spacing",
  STYLE_SPACING_TOP : "spacingTop",
  STYLE_SPACING_LEFT : "spacingLeft",
  STYLE_SPACING_BOTTOM : "spacingBottom",
  STYLE_SPACING_RIGHT : "spacingRight",
  STYLE_HORIZONTAL : "horizontal",
  STYLE_DIRECTION : "direction",
  STYLE_ANCHOR_POINT_DIRECTION : "anchorPointDirection",
  STYLE_ELBOW : "elbow",
  STYLE_FONTCOLOR : "fontColor",
  STYLE_FONTFAMILY : "fontFamily",
  STYLE_FONTSIZE : "fontSize",
  STYLE_FONTSTYLE : "fontStyle",
  STYLE_ASPECT : "aspect",
  STYLE_AUTOSIZE : "autosize",
  STYLE_FIXED_WIDTH : "fixedWidth",
  STYLE_FOLDABLE : "foldable",
  STYLE_EDITABLE : "editable",
  STYLE_BACKGROUND_OUTLINE : "backgroundOutline",
  STYLE_BENDABLE : "bendable",
  STYLE_MOVABLE : "movable",
  STYLE_RESIZABLE : "resizable",
  STYLE_RESIZE_WIDTH : "resizeWidth",
  STYLE_RESIZE_HEIGHT : "resizeHeight",
  STYLE_ROTATABLE : "rotatable",
  STYLE_CLONEABLE : "cloneable",
  STYLE_DELETABLE : "deletable",
  STYLE_SHAPE : "shape",
  STYLE_EDGE : "edgeStyle",
  STYLE_JETTY_SIZE : "jettySize",
  STYLE_SOURCE_JETTY_SIZE : "sourceJettySize",
  STYLE_TARGET_JETTY_SIZE : "targetJettySize",
  STYLE_LOOP : "loopStyle",
  STYLE_ORTHOGONAL_LOOP : "orthogonalLoop",
  STYLE_ROUTING_CENTER_X : "routingCenterX",
  STYLE_ROUTING_CENTER_Y : "routingCenterY",
  STYLE_CLIP_PATH : "clipPath",
  FONT_BOLD : 1,
  FONT_ITALIC : 2,
  FONT_UNDERLINE : 4,
  FONT_STRIKETHROUGH : 8,
  SHAPE_RECTANGLE : "rectangle",
  SHAPE_ELLIPSE : "ellipse",
  SHAPE_DOUBLE_ELLIPSE : "doubleEllipse",
  SHAPE_RHOMBUS : "rhombus",
  SHAPE_LINE : "line",
  SHAPE_IMAGE : "image",
  SHAPE_ARROW : "arrow",
  SHAPE_ARROW_CONNECTOR : "arrowConnector",
  SHAPE_LABEL : "label",
  SHAPE_CYLINDER : "cylinder",
  SHAPE_SWIMLANE : "swimlane",
  SHAPE_CONNECTOR : "connector",
  SHAPE_ACTOR : "actor",
  SHAPE_CLOUD : "cloud",
  SHAPE_TRIANGLE : "triangle",
  SHAPE_HEXAGON : "hexagon",
  ARROW_CLASSIC : "classic",
  ARROW_CLASSIC_THIN : "classicThin",
  ARROW_BLOCK : "block",
  ARROW_BLOCK_THIN : "blockThin",
  ARROW_OPEN : "open",
  ARROW_OPEN_THIN : "openThin",
  ARROW_OVAL : "oval",
  ARROW_DIAMOND : "diamond",
  ARROW_DIAMOND_THIN : "diamondThin",
  ALIGN_LEFT : "left",
  ALIGN_CENTER : "center",
  ALIGN_RIGHT : "right",
  ALIGN_TOP : "top",
  ALIGN_MIDDLE : "middle",
  ALIGN_BOTTOM : "bottom",
  DIRECTION_NORTH : "north",
  DIRECTION_SOUTH : "south",
  DIRECTION_EAST : "east",
  DIRECTION_WEST : "west",
  DIRECTION_RADIAL : "radial",
  TEXT_DIRECTION_DEFAULT : "",
  TEXT_DIRECTION_AUTO : "auto",
  TEXT_DIRECTION_LTR : "ltr",
  TEXT_DIRECTION_RTL : "rtl",
  DIRECTION_MASK_NONE : 0,
  DIRECTION_MASK_WEST : 1,
  DIRECTION_MASK_NORTH : 2,
  DIRECTION_MASK_SOUTH : 4,
  DIRECTION_MASK_EAST : 8,
  DIRECTION_MASK_ALL : 15,
  ELBOW_VERTICAL : "vertical",
  ELBOW_HORIZONTAL : "horizontal",
  EDGESTYLE_ELBOW : "elbowEdgeStyle",
  EDGESTYLE_ENTITY_RELATION : "entityRelationEdgeStyle",
  EDGESTYLE_LOOP : "loopEdgeStyle",
  EDGESTYLE_SIDETOSIDE : "sideToSideEdgeStyle",
  EDGESTYLE_TOPTOBOTTOM : "topToBottomEdgeStyle",
  EDGESTYLE_ORTHOGONAL : "orthogonalEdgeStyle",
  EDGESTYLE_SEGMENT : "segmentEdgeStyle",
  PERIMETER_ELLIPSE : "ellipsePerimeter",
  PERIMETER_RECTANGLE : "rectanglePerimeter",
  PERIMETER_RHOMBUS : "rhombusPerimeter",
  PERIMETER_HEXAGON : "hexagonPerimeter",
  PERIMETER_TRIANGLE : "trianglePerimeter"
};
function mxEventObject(name) {
  this.name = name;
  this.properties = [];
  for (var i = 1;i < arguments.length;i += 2) {
    if (null != arguments[i + 1]) {
      this.properties[arguments[i]] = arguments[i + 1];
    }
  }
}
mxEventObject.prototype.name = null;
mxEventObject.prototype.properties = null;
mxEventObject.prototype.consumed = false;
mxEventObject.prototype.getName = function() {
  return this.name;
};
mxEventObject.prototype.getProperties = function() {
  return this.properties;
};
mxEventObject.prototype.getProperty = function(key) {
  return this.properties[key];
};
mxEventObject.prototype.isConsumed = function() {
  return this.consumed;
};
mxEventObject.prototype.consume = function() {
  this.consumed = true;
};
function mxMouseEvent(evt, state) {
  this.evt = evt;
  this.sourceState = this.state = state;
}
mxMouseEvent.prototype.consumed = false;
mxMouseEvent.prototype.evt = null;
mxMouseEvent.prototype.graphX = null;
mxMouseEvent.prototype.graphY = null;
mxMouseEvent.prototype.state = null;
mxMouseEvent.prototype.sourceState = null;
mxMouseEvent.prototype.getEvent = function() {
  return this.evt;
};
mxMouseEvent.prototype.getSource = function() {
  return mxEvent.getSource(this.evt);
};
mxMouseEvent.prototype.isSource = function(shape) {
  return null != shape ? mxUtils.isAncestorNode(shape.node, this.getSource()) : false;
};
mxMouseEvent.prototype.getX = function() {
  return mxEvent.getClientX(this.getEvent());
};
mxMouseEvent.prototype.getY = function() {
  return mxEvent.getClientY(this.getEvent());
};
mxMouseEvent.prototype.getGraphX = function() {
  return this.graphX;
};
mxMouseEvent.prototype.getGraphY = function() {
  return this.graphY;
};
mxMouseEvent.prototype.getState = function() {
  return this.state;
};
mxMouseEvent.prototype.getCell = function() {
  var state = this.getState();
  return null != state ? state.cell : null;
};
mxMouseEvent.prototype.isPopupTrigger = function() {
  return mxEvent.isPopupTrigger(this.getEvent());
};
mxMouseEvent.prototype.isConsumed = function() {
  return this.consumed;
};
mxMouseEvent.prototype.consume = function(evt) {
  if (evt = null != evt ? evt : null != this.evt.touches || mxEvent.isMouseEvent(this.evt)) {
    if (this.evt.preventDefault) {
      this.evt.preventDefault();
    }
  }
  if (mxClient.IS_IE) {
    this.evt.returnValue = true;
  }
  this.consumed = true;
};
function mxEventSource(eventSource) {
  this.setEventSource(eventSource);
}
mxEventSource.prototype.eventListeners = null;
mxEventSource.prototype.eventsEnabled = true;
mxEventSource.prototype.eventSource = null;
mxEventSource.prototype.isEventsEnabled = function() {
  return this.eventsEnabled;
};
mxEventSource.prototype.setEventsEnabled = function(value) {
  this.eventsEnabled = value;
};
mxEventSource.prototype.getEventSource = function() {
  return this.eventSource;
};
mxEventSource.prototype.setEventSource = function(value) {
  this.eventSource = value;
};
mxEventSource.prototype.addListener = function(name, funct) {
  if (null == this.eventListeners) {
    this.eventListeners = [];
  }
  this.eventListeners.push(name);
  this.eventListeners.push(funct);
};
mxEventSource.prototype.removeListener = function(funct) {
  if (null != this.eventListeners) {
    for (var i = 0;i < this.eventListeners.length;) {
      if (this.eventListeners[i + 1] == funct) {
        this.eventListeners.splice(i, 2);
      } else {
        i += 2;
      }
    }
  }
};
mxEventSource.prototype.fireEvent = function(evt, sender) {
  if (null != this.eventListeners && this.isEventsEnabled()) {
    if (null == evt) {
      evt = new mxEventObject;
    }
    if (null == sender) {
      sender = this.getEventSource();
    }
    if (null == sender) {
      sender = this;
    }
    for (var i = 0;i < this.eventListeners.length;i += 2) {
      var listen = this.eventListeners[i];
      if (!(null != listen && listen != evt.getName())) {
        this.eventListeners[i + 1].apply(this, [sender, evt]);
      }
    }
  }
};
var mxEvent = {
  addListener : function() {
    if (window.addEventListener) {
      var a = false;
      try {
        document.addEventListener("test", function() {
        }, Object.defineProperty && Object.defineProperty({}, "passive", {
          get : function() {
            a = true;
          }
        }));
      } catch (b) {
      }
      return function(element, eventName, funct) {
        element.addEventListener(eventName, funct, a ? {
          passive : false
        } : false);
        if (null == element.mxListenerList) {
          element.mxListenerList = [];
        }
        element.mxListenerList.push({
          name : eventName,
          f : funct
        });
      };
    }
    return function(element, eventName, funct) {
      element.attachEvent("on" + eventName, funct);
      if (null == element.mxListenerList) {
        element.mxListenerList = [];
      }
      element.mxListenerList.push({
        name : eventName,
        f : funct
      });
    };
  }(),
  removeListener : function() {
    var updateListener = function(element, eventName, funct) {
      if (null != element.mxListenerList) {
        eventName = element.mxListenerList.length;
        for (var i = 0;i < eventName;i++) {
          if (element.mxListenerList[i].f == funct) {
            element.mxListenerList.splice(i, 1);
            break;
          }
        }
        if (0 == element.mxListenerList.length) {
          element.mxListenerList = null;
        }
      }
    };
    return window.removeEventListener ? function(element, eventName, funct) {
      element.removeEventListener(eventName, funct, false);
      updateListener(element, eventName, funct);
    } : function(element, eventName, funct) {
      element.detachEvent("on" + eventName, funct);
      updateListener(element, eventName, funct);
    };
  }(),
  removeAllListeners : function(element) {
    var list = element.mxListenerList;
    if (null != list) {
      for (;0 < list.length;) {
        var entry = list[0];
        mxEvent.removeListener(element, entry.name, entry.f);
      }
    }
  },
  addGestureListeners : function(node, connectingEdge, funct, dropHandler) {
    if (null != connectingEdge) {
      mxEvent.addListener(node, mxClient.IS_POINTER ? "pointerdown" : "mousedown", connectingEdge);
    }
    if (null != funct) {
      mxEvent.addListener(node, mxClient.IS_POINTER ? "pointermove" : "mousemove", funct);
    }
    if (null != dropHandler) {
      mxEvent.addListener(node, mxClient.IS_POINTER ? "pointerup" : "mouseup", dropHandler);
    }
    if (!mxClient.IS_POINTER) {
      if (mxClient.IS_TOUCH) {
        if (null != connectingEdge) {
          mxEvent.addListener(node, "touchstart", connectingEdge);
        }
        if (null != funct) {
          mxEvent.addListener(node, "touchmove", funct);
        }
        if (null != dropHandler) {
          mxEvent.addListener(node, "touchend", dropHandler);
        }
      }
    }
  },
  removeGestureListeners : function(node, connectingEdge, moveListener, dropHandler) {
    if (null != connectingEdge) {
      mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointerdown" : "mousedown", connectingEdge);
    }
    if (null != moveListener) {
      mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointermove" : "mousemove", moveListener);
    }
    if (null != dropHandler) {
      mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointerup" : "mouseup", dropHandler);
    }
    if (!mxClient.IS_POINTER) {
      if (mxClient.IS_TOUCH) {
        if (null != connectingEdge) {
          mxEvent.removeListener(node, "touchstart", connectingEdge);
        }
        if (null != moveListener) {
          mxEvent.removeListener(node, "touchmove", moveListener);
        }
        if (null != dropHandler) {
          mxEvent.removeListener(node, "touchend", dropHandler);
        }
      }
    }
  },
  redirectMouseEvents : function(node, graph, state, dblClick, down, move, up) {
    var getState = function(evt) {
      return "function" == typeof state ? state(evt) : state;
    };
    mxEvent.addGestureListeners(node, function(evt) {
      if (null != dblClick) {
        dblClick(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, getState(evt)));
        }
      }
    }, function(evt) {
      if (null != down) {
        down(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));
        }
      }
    }, function(evt) {
      if (null != move) {
        move(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));
        }
      }
    });
    mxEvent.addListener(node, "dblclick", function(evt) {
      if (null != up) {
        up(evt);
      } else {
        if (!mxEvent.isConsumed(evt)) {
          var tmp = getState(evt);
          graph.dblClick(evt, null != tmp ? tmp.cell : null);
        }
      }
    });
  },
  release : function(element) {
    try {
      if (null != element) {
        mxEvent.removeAllListeners(element);
        var children = element.childNodes;
        if (null != children) {
          var childCount = children.length;
          for (element = 0;element < childCount;element += 1) {
            mxEvent.release(children[element]);
          }
        }
      }
    } catch (d) {
    }
  },
  addMouseWheelListener : function(funct, target) {
    if (null != funct) {
      target = null != target ? target : window;
      if (mxClient.IS_SF && !mxClient.IS_TOUCH) {
        var scale = 1;
        mxEvent.addListener(target, "gesturestart", function(evt) {
          mxEvent.consume(evt);
          scale = 1;
        });
        mxEvent.addListener(target, "gesturechange", function(evt) {
          mxEvent.consume(evt);
          var diff = scale - evt.scale;
          if (0.2 < Math.abs(diff)) {
            funct(evt, 0 > diff, true);
            scale = evt.scale;
          }
        });
        mxEvent.addListener(target, "gestureend", function(evt) {
          mxEvent.consume(evt);
        });
      } else {
        var evtCache = [];
        var dx0 = 0;
        var dy0 = 0;
        mxEvent.addGestureListeners(target, mxUtils.bind(this, function(evt) {
          if (!mxEvent.isMouseEvent(evt)) {
            if (!(null == evt.pointerId)) {
              evtCache.push(evt);
            }
          }
        }), mxUtils.bind(this, function(evt) {
          if (!mxEvent.isMouseEvent(evt) && 2 == evtCache.length) {
            for (var dy = 0;dy < evtCache.length;dy++) {
              if (evt.pointerId == evtCache[dy].pointerId) {
                evtCache[dy] = evt;
                break;
              }
            }
            evt = Math.abs(evtCache[0].clientX - evtCache[1].clientX);
            dy = Math.abs(evtCache[0].clientY - evtCache[1].clientY);
            var tx = Math.abs(evt - dx0);
            var ty = Math.abs(dy - dy0);
            if (tx > mxEvent.PINCH_THRESHOLD || ty > mxEvent.PINCH_THRESHOLD) {
              funct(evtCache[0], tx > ty ? evt > dx0 : dy > dy0, true, evtCache[0].clientX + (evtCache[1].clientX - evtCache[0].clientX) / 2, evtCache[0].clientY + (evtCache[1].clientY - evtCache[0].clientY) / 2);
              dx0 = evt;
              dy0 = dy;
            }
          }
        }), mxUtils.bind(this, function(flex) {
          evtCache = [];
          dy0 = dx0 = 0;
        }));
      }
      mxEvent.addListener(target, "wheel", function(evt) {
        if (null == evt) {
          evt = window.event;
        }
        if (evt.ctrlKey) {
          evt.preventDefault();
        }
        if (0.5 < Math.abs(evt.deltaX) || 0.5 < Math.abs(evt.deltaY)) {
          funct(evt, 0 == evt.deltaY ? 0 < -evt.deltaX : 0 < -evt.deltaY);
        }
      });
    }
  },
  disableContextMenu : function(element) {
    mxEvent.addListener(element, "contextmenu", function(evt) {
      if (evt.preventDefault) {
        evt.preventDefault();
      }
      return false;
    });
  },
  getSource : function(evt) {
    return null != evt.srcElement ? evt.srcElement : evt.target;
  },
  isConsumed : function(evt) {
    return null != evt.isConsumed && evt.isConsumed;
  },
  isTouchEvent : function(evt) {
    return null != evt.pointerType ? "touch" == evt.pointerType || evt.pointerType === evt.MSPOINTER_TYPE_TOUCH : null != evt.mozInputSource ? 5 == evt.mozInputSource : 0 == evt.type.indexOf("touch");
  },
  isPenEvent : function(evt) {
    return null != evt.pointerType ? "pen" == evt.pointerType || evt.pointerType === evt.MSPOINTER_TYPE_PEN : null != evt.mozInputSource ? 2 == evt.mozInputSource : 0 == evt.type.indexOf("pen");
  },
  isMultiTouchEvent : function(evt) {
    return null != evt.type && (0 == evt.type.indexOf("touch") && (null != evt.touches && 1 < evt.touches.length));
  },
  isMouseEvent : function(evt) {
    return!mxClient.IS_ANDROID && (mxClient.IS_LINUX && mxClient.IS_GC) ? true : null != evt.pointerType ? "mouse" == evt.pointerType || evt.pointerType === evt.MSPOINTER_TYPE_MOUSE : null != evt.mozInputSource ? 1 == evt.mozInputSource : 0 == evt.type.indexOf("mouse");
  },
  isLeftMouseButton : function(evt) {
    return "buttons" in evt && ("mousedown" == evt.type || "mousemove" == evt.type) ? 1 == evt.buttons : "which" in evt ? 1 === evt.which : 1 === evt.button;
  },
  isMiddleMouseButton : function(evt) {
    return "which" in evt ? 2 === evt.which : 4 === evt.button;
  },
  isRightMouseButton : function(evt) {
    return "which" in evt ? 3 === evt.which : 2 === evt.button;
  },
  isPopupTrigger : function(evt) {
    return mxEvent.isRightMouseButton(evt) || mxClient.IS_MAC && (mxEvent.isControlDown(evt) && (!mxEvent.isShiftDown(evt) && (!mxEvent.isMetaDown(evt) && !mxEvent.isAltDown(evt))));
  },
  isShiftDown : function(evt) {
    return null != evt ? evt.shiftKey : false;
  },
  isAltDown : function(evt) {
    return null != evt ? evt.altKey : false;
  },
  isControlDown : function(evt) {
    return null != evt ? evt.ctrlKey : false;
  },
  isMetaDown : function(evt) {
    return null != evt ? evt.metaKey : false;
  },
  getMainEvent : function(evt) {
    if ("touchstart" != evt.type && "touchmove" != evt.type || (null == evt.touches || null == evt.touches[0])) {
      if ("touchend" == evt.type) {
        if (null != evt.changedTouches) {
          if (null != evt.changedTouches[0]) {
            evt = evt.changedTouches[0];
          }
        }
      }
    } else {
      evt = evt.touches[0];
    }
    return evt;
  },
  getClientX : function(evt) {
    return mxEvent.getMainEvent(evt).clientX;
  },
  getClientY : function(evt) {
    return mxEvent.getMainEvent(evt).clientY;
  },
  consume : function(evt, preventDefault, stopPropagation) {
    stopPropagation = null != stopPropagation ? stopPropagation : true;
    if (null != preventDefault ? preventDefault : 1) {
      if (evt.preventDefault) {
        if (stopPropagation) {
          evt.stopPropagation();
        }
        evt.preventDefault();
      } else {
        if (stopPropagation) {
          evt.cancelBubble = true;
        }
      }
    }
    evt.isConsumed = true;
    if (!evt.preventDefault) {
      evt.returnValue = false;
    }
  },
  LABEL_HANDLE : -1,
  ROTATION_HANDLE : -2,
  CUSTOM_HANDLE : -100,
  VIRTUAL_HANDLE : -1E5,
  MOUSE_DOWN : "mouseDown",
  MOUSE_MOVE : "mouseMove",
  MOUSE_UP : "mouseUp",
  ACTIVATE : "activate",
  RESIZE_START : "resizeStart",
  RESIZE : "resize",
  RESIZE_END : "resizeEnd",
  MOVE_START : "moveStart",
  MOVE : "move",
  MOVE_END : "moveEnd",
  PAN_START : "panStart",
  PAN : "pan",
  PAN_END : "panEnd",
  MINIMIZE : "minimize",
  NORMALIZE : "normalize",
  MAXIMIZE : "maximize",
  HIDE : "hide",
  SHOW : "show",
  CLOSE : "close",
  DESTROY : "destroy",
  REFRESH : "refresh",
  SIZE : "size",
  SELECT : "select",
  FIRED : "fired",
  FIRE_MOUSE_EVENT : "fireMouseEvent",
  GESTURE : "gesture",
  TAP_AND_HOLD : "tapAndHold",
  GET : "get",
  RECEIVE : "receive",
  CONNECT : "connect",
  DISCONNECT : "disconnect",
  SUSPEND : "suspend",
  RESUME : "resume",
  MARK : "mark",
  ROOT : "root",
  POST : "post",
  OPEN : "open",
  SAVE : "save",
  BEFORE_ADD_VERTEX : "beforeAddVertex",
  ADD_VERTEX : "addVertex",
  AFTER_ADD_VERTEX : "afterAddVertex",
  DONE : "done",
  EXECUTE : "execute",
  EXECUTED : "executed",
  BEGIN_UPDATE : "beginUpdate",
  START_EDIT : "startEdit",
  END_UPDATE : "endUpdate",
  END_EDIT : "endEdit",
  BEFORE_UNDO : "beforeUndo",
  UNDO : "undo",
  REDO : "redo",
  CHANGE : "change",
  NOTIFY : "notify",
  LAYOUT_CELLS : "layoutCells",
  CLICK : "click",
  SCALE : "scale",
  TRANSLATE : "translate",
  SCALE_AND_TRANSLATE : "scaleAndTranslate",
  UP : "up",
  DOWN : "down",
  ADD : "add",
  REMOVE : "remove",
  CLEAR : "clear",
  ADD_CELLS : "addCells",
  CELLS_ADDED : "cellsAdded",
  MOVE_CELLS : "moveCells",
  CELLS_MOVED : "cellsMoved",
  RESIZE_CELLS : "resizeCells",
  CELLS_RESIZED : "cellsResized",
  TOGGLE_CELLS : "toggleCells",
  CELLS_TOGGLED : "cellsToggled",
  ORDER_CELLS : "orderCells",
  CELLS_ORDERED : "cellsOrdered",
  REMOVE_CELLS : "removeCells",
  CELLS_REMOVED : "cellsRemoved",
  GROUP_CELLS : "groupCells",
  UNGROUP_CELLS : "ungroupCells",
  REMOVE_CELLS_FROM_PARENT : "removeCellsFromParent",
  FOLD_CELLS : "foldCells",
  CELLS_FOLDED : "cellsFolded",
  ALIGN_CELLS : "alignCells",
  LABEL_CHANGED : "labelChanged",
  CONNECT_CELL : "connectCell",
  CELL_CONNECTED : "cellConnected",
  SPLIT_EDGE : "splitEdge",
  FLIP_EDGE : "flipEdge",
  START_EDITING : "startEditing",
  EDITING_STARTED : "editingStarted",
  EDITING_STOPPED : "editingStopped",
  ADD_OVERLAY : "addOverlay",
  REMOVE_OVERLAY : "removeOverlay",
  UPDATE_CELL_SIZE : "updateCellSize",
  ESCAPE : "escape",
  DOUBLE_CLICK : "doubleClick",
  START : "start",
  RESET : "reset",
  PINCH_THRESHOLD : 10
};
function mxXmlRequest(url, params, method, async, username, password) {
  this.url = url;
  this.params = params;
  this.method = method || "POST";
  this.async = null != async ? async : true;
  this.username = username;
  this.password = password;
}
mxXmlRequest.prototype.url = null;
mxXmlRequest.prototype.params = null;
mxXmlRequest.prototype.method = null;
mxXmlRequest.prototype.async = null;
mxXmlRequest.prototype.binary = false;
mxXmlRequest.prototype.withCredentials = false;
mxXmlRequest.prototype.username = null;
mxXmlRequest.prototype.password = null;
mxXmlRequest.prototype.request = null;
mxXmlRequest.prototype.decodeSimulateValues = false;
mxXmlRequest.prototype.isBinary = function() {
  return this.binary;
};
mxXmlRequest.prototype.setBinary = function(value) {
  this.binary = value;
};
mxXmlRequest.prototype.getText = function() {
  return this.request.responseText;
};
mxXmlRequest.prototype.isReady = function() {
  return 4 == this.request.readyState;
};
mxXmlRequest.prototype.getDocumentElement = function() {
  var doc = this.getXml();
  return null != doc ? doc.documentElement : null;
};
mxXmlRequest.prototype.getXml = function() {
  var xml = this.request.responseXML;
  if (9 <= document.documentMode || (null == xml || null == xml.documentElement)) {
    xml = mxUtils.parseXml(this.request.responseText);
  }
  return xml;
};
mxXmlRequest.prototype.getStatus = function() {
  return null != this.request ? this.request.status : null;
};
mxXmlRequest.prototype.create = function() {
  if (window.XMLHttpRequest) {
    return function() {
      var req = new XMLHttpRequest;
      if (this.isBinary()) {
        if (req.overrideMimeType) {
          req.overrideMimeType("text/plain; charset=x-user-defined");
        }
      }
      return req;
    };
  }
  if ("undefined" != typeof ActiveXObject) {
    return function() {
      return new ActiveXObject("Microsoft.XMLHTTP");
    };
  }
}();
mxXmlRequest.prototype.send = function(onload, onerror, timeout, ontimeout) {
  this.request = this.create();
  if (null != this.request) {
    if (null != onload) {
      this.request.onreadystatechange = mxUtils.bind(this, function() {
        if (this.isReady()) {
          onload(this);
          this.request.onreadystatechange = null;
        }
      });
    }
    this.request.open(this.method, this.url, this.async, this.username, this.password);
    this.setRequestHeaders(this.request, this.params);
    if (window.XMLHttpRequest) {
      if (this.withCredentials) {
        this.request.withCredentials = "true";
      }
    }
    if (null == document.documentMode || 9 < document.documentMode) {
      if (window.XMLHttpRequest) {
        if (null != timeout) {
          if (null != ontimeout) {
            this.request.timeout = timeout;
            this.request.ontimeout = ontimeout;
          }
        }
      }
    }
    this.request.send(this.params);
  }
};
mxXmlRequest.prototype.setRequestHeaders = function(request, params) {
  if (null != params) {
    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  }
};
mxXmlRequest.prototype.simulate = function(doc, target) {
  doc = doc || document;
  var old = null;
  if (doc == document) {
    old = window.onbeforeunload;
    window.onbeforeunload = null;
  }
  var form = doc.createElement("form");
  form.setAttribute("method", this.method);
  form.setAttribute("action", this.url);
  if (null != target) {
    form.setAttribute("target", target);
  }
  form.style.display = "none";
  form.style.visibility = "hidden";
  var pars = 0 < this.params.indexOf("&") ? this.params.split("&") : this.params.split();
  for (var i = 0;i < pars.length;i++) {
    var value = pars[i].indexOf("=");
    if (0 < value) {
      var src = pars[i].substring(0, value);
      value = pars[i].substring(value + 1);
      if (this.decodeSimulateValues) {
        value = decodeURIComponent(value);
      }
      var textarea = doc.createElement("textarea");
      textarea.setAttribute("wrap", "off");
      textarea.setAttribute("name", src);
      mxUtils.write(textarea, value);
      form.appendChild(textarea);
    }
  }
  doc.body.appendChild(form);
  form.submit();
  if (null != form.parentNode) {
    form.parentNode.removeChild(form);
  }
  if (null != old) {
    window.onbeforeunload = old;
  }
};
var mxClipboard = {
  STEPSIZE : 10,
  insertCount : 1,
  cells : null,
  setCells : function(cells) {
    mxClipboard.cells = cells;
  },
  getCells : function() {
    return mxClipboard.cells;
  },
  isEmpty : function() {
    return null == mxClipboard.getCells();
  },
  cut : function(graph, cells) {
    cells = mxClipboard.copy(graph, cells);
    mxClipboard.insertCount = 0;
    mxClipboard.removeCells(graph, cells, false);
    return cells;
  },
  removeCells : function(graph, cells, includeEdges) {
    graph.removeCells(cells, includeEdges);
  },
  copy : function(graph, cells) {
    cells = cells || graph.getSelectionCells();
    cells = graph.getExportableCells(graph.model.getTopmostCells(cells));
    mxClipboard.insertCount = 1;
    mxClipboard.setCells(graph.cloneCells(cells));
    return cells;
  },
  paste : function(graph) {
    var cells = null;
    if (!mxClipboard.isEmpty()) {
      cells = graph.getImportableCells(mxClipboard.getCells());
      var delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;
      var parent = graph.getDefaultParent();
      cells = graph.importCells(cells, delta, delta, parent);
      mxClipboard.insertCount++;
      graph.setSelectionCells(cells);
    }
    return cells;
  }
};
function mxWindow(title, content, container, y, width, height, minimizable, movable, replaceNode, style) {
  if (null != content) {
    minimizable = null != minimizable ? minimizable : true;
    this.content = content;
    this.init(container, y, width, height, style);
    this.installMaximizeHandler();
    this.installMinimizeHandler();
    this.installCloseHandler();
    this.setMinimizable(minimizable);
    this.setTitle(title);
    if (null == movable || movable) {
      this.installMoveHandler();
    }
    if (null != replaceNode && null != replaceNode.parentNode) {
      replaceNode.parentNode.replaceChild(this.div, replaceNode);
    } else {
      document.body.appendChild(this.div);
    }
  }
}
mxWindow.prototype = new mxEventSource;
mxWindow.prototype.constructor = mxWindow;
mxWindow.prototype.closeImage = mxClient.imageBasePath + "/close.gif";
mxWindow.prototype.minimizeImage = mxClient.imageBasePath + "/minimize.gif";
mxWindow.prototype.normalizeImage = mxClient.imageBasePath + "/normalize.gif";
mxWindow.prototype.maximizeImage = mxClient.imageBasePath + "/maximize.gif";
mxWindow.prototype.resizeImage = mxClient.imageBasePath + "/resize.gif";
mxWindow.prototype.visible = false;
mxWindow.prototype.minimumSize = new mxRectangle(0, 0, 50, 40);
mxWindow.prototype.destroyOnClose = true;
mxWindow.prototype.contentHeightCorrection = 8 == document.documentMode || 7 == document.documentMode ? 6 : 2;
mxWindow.prototype.title = null;
mxWindow.prototype.content = null;
mxWindow.prototype.init = function(container, tr, width, height, style) {
  style = null != style ? style : "mxWindow";
  this.div = document.createElement("div");
  this.div.className = style;
  this.div.style.left = container + "px";
  this.div.style.top = tr + "px";
  this.table = document.createElement("table");
  this.table.className = style;
  if (mxClient.IS_POINTER) {
    this.div.style.touchAction = "none";
  }
  if (null != width) {
    this.div.style.width = width + "px";
    this.table.style.width = width + "px";
  }
  if (null != height) {
    this.div.style.height = height + "px";
    this.table.style.height = height + "px";
  }
  container = document.createElement("tbody");
  tr = document.createElement("tr");
  this.title = document.createElement("td");
  this.title.className = style + "Title";
  this.buttons = document.createElement("div");
  this.buttons.style.position = "absolute";
  this.buttons.style.display = "inline-block";
  this.buttons.style.right = "4px";
  this.buttons.style.top = "5px";
  this.title.appendChild(this.buttons);
  tr.appendChild(this.title);
  container.appendChild(tr);
  tr = document.createElement("tr");
  this.td = document.createElement("td");
  this.td.className = style + "Pane";
  if (7 == document.documentMode) {
    this.td.style.height = "100%";
  }
  this.contentWrapper = document.createElement("div");
  this.contentWrapper.className = style + "Pane";
  this.contentWrapper.style.width = "100%";
  this.contentWrapper.appendChild(this.content);
  if ("DIV" != this.content.nodeName.toUpperCase()) {
    this.contentWrapper.style.height = "100%";
  }
  this.td.appendChild(this.contentWrapper);
  tr.appendChild(this.td);
  container.appendChild(tr);
  this.table.appendChild(container);
  this.div.appendChild(this.table);
  style = mxUtils.bind(this, function(flex) {
    this.activate();
  });
  mxEvent.addGestureListeners(this.title, style);
  mxEvent.addGestureListeners(this.table, style);
  this.hide();
};
mxWindow.prototype.setTitle = function(title) {
  for (var child = this.title.firstChild;null != child;) {
    var tmp = child.nextSibling;
    if (child.nodeType == mxConstants.NODETYPE_TEXT) {
      child.parentNode.removeChild(child);
    }
    child = tmp;
  }
  mxUtils.write(this.title, title || "");
  this.title.appendChild(this.buttons);
};
mxWindow.prototype.setScrollable = function(layer) {
  if (null == navigator.userAgent || 0 > navigator.userAgent.indexOf("Presto/2.5")) {
    this.contentWrapper.style.overflow = layer ? "auto" : "hidden";
  }
};
mxWindow.prototype.activate = function() {
  if (mxWindow.activeWindow != this) {
    var index = mxUtils.getCurrentStyle(this.getElement());
    index = null != index ? index.zIndex : 3;
    if (mxWindow.activeWindow) {
      var edge = mxWindow.activeWindow.getElement();
      if (null != edge) {
        if (null != edge.style) {
          edge.style.zIndex = index;
        }
      }
    }
    edge = mxWindow.activeWindow;
    this.getElement().style.zIndex = parseInt(index) + 1;
    mxWindow.activeWindow = this;
    this.fireEvent(new mxEventObject(mxEvent.ACTIVATE, "previousWindow", edge));
  }
};
mxWindow.prototype.getElement = function() {
  return this.div;
};
mxWindow.prototype.fit = function() {
  mxUtils.fit(this.div);
};
mxWindow.prototype.isResizable = function() {
  return null != this.resize ? "none" != this.resize.style.display : false;
};
mxWindow.prototype.setResizable = function(resizable) {
  if (resizable) {
    if (null == this.resize) {
      this.resize = document.createElement("img");
      this.resize.style.position = "absolute";
      this.resize.style.bottom = "2px";
      this.resize.style.right = "2px";
      this.resize.setAttribute("src", this.resizeImage);
      this.resize.style.cursor = "nw-resize";
      var startX = null;
      var startY = null;
      var width = null;
      var height = null;
      var funct = mxUtils.bind(this, function(evt) {
        this.activate();
        startX = mxEvent.getClientX(evt);
        startY = mxEvent.getClientY(evt);
        width = this.div.offsetWidth;
        height = this.div.offsetHeight;
        mxEvent.addGestureListeners(document, null, dragHandler, dropHandler);
        this.fireEvent(new mxEventObject(mxEvent.RESIZE_START, "event", evt));
        mxEvent.consume(evt);
      });
      var dragHandler = mxUtils.bind(this, function(evt) {
        if (null != startX && null != startY) {
          var dx = mxEvent.getClientX(evt) - startX;
          var dy = mxEvent.getClientY(evt) - startY;
          this.setSize(width + dx, height + dy);
          this.fireEvent(new mxEventObject(mxEvent.RESIZE, "event", evt));
          mxEvent.consume(evt);
        }
      });
      var dropHandler = mxUtils.bind(this, function(evt) {
        if (null != startX) {
          if (null != startY) {
            startY = startX = null;
            mxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);
            this.fireEvent(new mxEventObject(mxEvent.RESIZE_END, "event", evt));
            mxEvent.consume(evt);
          }
        }
      });
      mxEvent.addGestureListeners(this.resize, funct, dragHandler, dropHandler);
      this.div.appendChild(this.resize);
    } else {
      this.resize.style.display = "inline";
    }
  } else {
    if (null != this.resize) {
      this.resize.style.display = "none";
    }
  }
};
mxWindow.prototype.setSize = function(width, height) {
  width = Math.max(this.minimumSize.width, width);
  height = Math.max(this.minimumSize.height, height);
  this.div.style.width = width + "px";
  this.div.style.height = height + "px";
  this.table.style.width = width + "px";
  this.table.style.height = height + "px";
  this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
};
mxWindow.prototype.setMinimizable = function(minimizable) {
  this.minimizeImg.style.display = minimizable ? "" : "none";
};
mxWindow.prototype.getMinimumSize = function() {
  return new mxRectangle(0, 0, 0, this.title.offsetHeight);
};
mxWindow.prototype.toggleMinimized = function(evt) {
  this.activate();
  if (this.minimized) {
    this.minimized = false;
    this.minimizeImg.setAttribute("src", this.minimizeImage);
    this.minimizeImg.setAttribute("title", "Minimize");
    this.contentWrapper.style.display = "";
    this.maximize.style.display = this.maxDisplay;
    this.div.style.height = this.height;
    this.table.style.height = this.height;
    if (null != this.resize) {
      this.resize.style.visibility = "";
    }
    this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", evt));
  } else {
    this.minimized = true;
    this.minimizeImg.setAttribute("src", this.normalizeImage);
    this.minimizeImg.setAttribute("title", "Normalize");
    this.contentWrapper.style.display = "none";
    this.maxDisplay = this.maximize.style.display;
    this.maximize.style.display = "none";
    this.height = this.table.style.height;
    var minSize = this.getMinimumSize();
    if (0 < minSize.height) {
      this.div.style.height = minSize.height + "px";
      this.table.style.height = minSize.height + "px";
    }
    if (0 < minSize.width) {
      this.div.style.width = minSize.width + "px";
      this.table.style.width = minSize.width + "px";
    }
    if (null != this.resize) {
      this.resize.style.visibility = "hidden";
    }
    this.fireEvent(new mxEventObject(mxEvent.MINIMIZE, "event", evt));
  }
};
mxWindow.prototype.installMinimizeHandler = function() {
  this.minimizeImg = document.createElement("img");
  this.minimizeImg.setAttribute("src", this.minimizeImage);
  this.minimizeImg.setAttribute("title", "Minimize");
  this.minimizeImg.style.cursor = "pointer";
  this.minimizeImg.style.marginLeft = "2px";
  this.minimizeImg.style.display = "none";
  this.buttons.appendChild(this.minimizeImg);
  this.minimized = false;
  this.height = this.maxDisplay = null;
  var funct = mxUtils.bind(this, function(evt) {
    this.toggleMinimized(evt);
    mxEvent.consume(evt);
  });
  mxEvent.addGestureListeners(this.minimizeImg, funct);
};
mxWindow.prototype.setMaximizable = function(maximizable) {
  this.maximize.style.display = maximizable ? "" : "none";
};
mxWindow.prototype.installMaximizeHandler = function() {
  this.maximize = document.createElement("img");
  this.maximize.setAttribute("src", this.maximizeImage);
  this.maximize.setAttribute("title", "Maximize");
  this.maximize.style.cursor = "default";
  this.maximize.style.marginLeft = "2px";
  this.maximize.style.cursor = "pointer";
  this.maximize.style.display = "none";
  this.buttons.appendChild(this.maximize);
  var a = false;
  var x = null;
  var y = null;
  var height = null;
  var width = null;
  var maxDisplay = null;
  var funct = mxUtils.bind(this, function(evt) {
    this.activate();
    if ("none" != this.maximize.style.display) {
      if (a) {
        a = false;
        this.maximize.setAttribute("src", this.maximizeImage);
        this.maximize.setAttribute("title", "Maximize");
        this.contentWrapper.style.display = "";
        this.minimizeImg.style.display = maxDisplay;
        this.div.style.left = x + "px";
        this.div.style.top = y + "px";
        this.div.style.height = height;
        this.div.style.width = width;
        style = mxUtils.getCurrentStyle(this.contentWrapper);
        if ("auto" == style.overflow || null != this.resize) {
          this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
        }
        this.table.style.height = height;
        this.table.style.width = width;
        if (null != this.resize) {
          this.resize.style.visibility = "";
        }
        this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", evt));
      } else {
        a = true;
        this.maximize.setAttribute("src", this.normalizeImage);
        this.maximize.setAttribute("title", "Normalize");
        this.contentWrapper.style.display = "";
        maxDisplay = this.minimizeImg.style.display;
        this.minimizeImg.style.display = "none";
        x = parseInt(this.div.style.left);
        y = parseInt(this.div.style.top);
        height = this.table.style.height;
        width = this.table.style.width;
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        style = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);
        this.div.style.width = document.body.clientWidth - 2 + "px";
        this.div.style.height = style - 2 + "px";
        this.table.style.width = document.body.clientWidth - 2 + "px";
        this.table.style.height = style - 2 + "px";
        if (null != this.resize) {
          this.resize.style.visibility = "hidden";
        }
        var style = mxUtils.getCurrentStyle(this.contentWrapper);
        if ("auto" == style.overflow || null != this.resize) {
          this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
        }
        this.fireEvent(new mxEventObject(mxEvent.MAXIMIZE, "event", evt));
      }
      mxEvent.consume(evt);
    }
  });
  mxEvent.addGestureListeners(this.maximize, funct);
  mxEvent.addListener(this.title, "dblclick", funct);
};
mxWindow.prototype.installMoveHandler = function() {
  this.title.style.cursor = "move";
  mxEvent.addGestureListeners(this.title, mxUtils.bind(this, function(evt) {
    var startY = mxEvent.getClientX(evt);
    var startX = mxEvent.getClientY(evt);
    var x = this.getX();
    var y = this.getY();
    var dragHandler = mxUtils.bind(this, function(evt) {
      var dx = mxEvent.getClientX(evt) - startY;
      var dy = mxEvent.getClientY(evt) - startX;
      this.setLocation(x + dx, y + dy);
      this.fireEvent(new mxEventObject(mxEvent.MOVE, "event", evt));
      mxEvent.consume(evt);
    });
    var dropHandler = mxUtils.bind(this, function(evt) {
      mxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);
      this.fireEvent(new mxEventObject(mxEvent.MOVE_END, "event", evt));
      mxEvent.consume(evt);
    });
    mxEvent.addGestureListeners(document, null, dragHandler, dropHandler);
    this.fireEvent(new mxEventObject(mxEvent.MOVE_START, "event", evt));
    mxEvent.consume(evt);
  }));
  if (mxClient.IS_POINTER) {
    this.title.style.touchAction = "none";
  }
};
mxWindow.prototype.setLocation = function(x, y) {
  this.div.style.left = x + "px";
  this.div.style.top = y + "px";
};
mxWindow.prototype.getX = function() {
  return parseInt(this.div.style.left);
};
mxWindow.prototype.getY = function() {
  return parseInt(this.div.style.top);
};
mxWindow.prototype.installCloseHandler = function() {
  this.closeImg = document.createElement("img");
  this.closeImg.setAttribute("src", this.closeImage);
  this.closeImg.setAttribute("title", "Close");
  this.closeImg.style.marginLeft = "2px";
  this.closeImg.style.cursor = "pointer";
  this.closeImg.style.display = "none";
  this.buttons.appendChild(this.closeImg);
  mxEvent.addGestureListeners(this.closeImg, mxUtils.bind(this, function(evt) {
    this.fireEvent(new mxEventObject(mxEvent.CLOSE, "event", evt));
    if (this.destroyOnClose) {
      this.destroy();
    } else {
      this.setVisible(false);
    }
    mxEvent.consume(evt);
  }));
};
mxWindow.prototype.setImage = function(image) {
  this.image = document.createElement("img");
  this.image.setAttribute("src", image);
  this.image.setAttribute("align", "left");
  this.image.style.marginRight = "4px";
  this.image.style.marginLeft = "0px";
  this.image.style.marginTop = "-2px";
  this.title.insertBefore(this.image, this.title.firstChild);
};
mxWindow.prototype.setClosable = function(visible) {
  this.closeImg.style.display = visible ? "" : "none";
};
mxWindow.prototype.isVisible = function() {
  return null != this.div ? "none" != this.div.style.display : false;
};
mxWindow.prototype.setVisible = function(visible) {
  if (null != this.div) {
    if (this.isVisible() != visible) {
      if (visible) {
        this.show();
      } else {
        this.hide();
      }
    } else {
      this.fireEvent(new mxEventObject(visible ? mxEvent.SHOW : mxEvent.HIDE));
    }
  }
};
mxWindow.prototype.show = function() {
  this.div.style.display = "";
  this.activate();
  if (!("auto" != mxUtils.getCurrentStyle(this.contentWrapper).overflow && null == this.resize)) {
    if (!("none" == this.contentWrapper.style.display)) {
      this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.SHOW));
};
mxWindow.prototype.hide = function() {
  this.div.style.display = "none";
  this.fireEvent(new mxEventObject(mxEvent.HIDE));
};
mxWindow.prototype.destroy = function() {
  this.fireEvent(new mxEventObject(mxEvent.DESTROY));
  if (null != this.div) {
    mxEvent.release(this.div);
    this.div.parentNode.removeChild(this.div);
    this.div = null;
  }
  this.contentWrapper = this.content = this.title = null;
};
function mxForm(className) {
  this.table = document.createElement("table");
  this.table.className = className;
  this.body = document.createElement("tbody");
  this.table.appendChild(this.body);
}
mxForm.prototype.table = null;
mxForm.prototype.body = false;
mxForm.prototype.getTable = function() {
  return this.table;
};
mxForm.prototype.addButtons = function(okFunct, cancelFunct) {
  var tr = document.createElement("tr");
  var td = document.createElement("td");
  tr.appendChild(td);
  td = document.createElement("td");
  var button = document.createElement("button");
  mxUtils.write(button, mxResources.get("ok") || "OK");
  td.appendChild(button);
  mxEvent.addListener(button, "click", function() {
    okFunct();
  });
  button = document.createElement("button");
  mxUtils.write(button, mxResources.get("cancel") || "Cancel");
  td.appendChild(button);
  mxEvent.addListener(button, "click", function() {
    cancelFunct();
  });
  tr.appendChild(td);
  this.body.appendChild(tr);
};
mxForm.prototype.addText = function(name, value, type) {
  var input = document.createElement("input");
  input.setAttribute("type", type || "text");
  input.value = value;
  return this.addField(name, input);
};
mxForm.prototype.addCheckbox = function(name, value) {
  var input = document.createElement("input");
  input.setAttribute("type", "checkbox");
  this.addField(name, input);
  if (value) {
    input.checked = true;
  }
  return input;
};
mxForm.prototype.addTextarea = function(name, value, rows) {
  var input = document.createElement("textarea");
  if (mxClient.IS_NS) {
    rows--;
  }
  input.setAttribute("rows", rows || 2);
  input.value = value;
  return this.addField(name, input);
};
mxForm.prototype.addCombo = function(name, isMultiSelect, size) {
  var select = document.createElement("select");
  if (null != size) {
    select.setAttribute("size", size);
  }
  if (isMultiSelect) {
    select.setAttribute("multiple", "true");
  }
  return this.addField(name, select);
};
mxForm.prototype.addOption = function(combo, label, value, isSelected) {
  var option = document.createElement("option");
  mxUtils.writeln(option, label);
  option.setAttribute("value", value);
  if (isSelected) {
    option.setAttribute("selected", isSelected);
  }
  combo.appendChild(option);
};
mxForm.prototype.addField = function(name, input) {
  var tr = document.createElement("tr");
  var td = document.createElement("td");
  mxUtils.write(td, name);
  tr.appendChild(td);
  td = document.createElement("td");
  td.appendChild(input);
  tr.appendChild(td);
  this.body.appendChild(tr);
  return input;
};
function mxImage(src, width, height, x, y) {
  this.src = src;
  this.width = null != width ? width : this.width;
  this.height = null != height ? height : this.height;
  this.x = null != x ? x : this.x;
  this.y = null != y ? y : this.y;
}
mxImage.prototype.src = null;
mxImage.prototype.width = 0;
mxImage.prototype.height = 0;
mxImage.prototype.x = 0;
mxImage.prototype.y = 0;
function mxDivResizer(div, container) {
  if ("div" == div.nodeName.toLowerCase()) {
    if (null == container) {
      container = window;
    }
    this.div = div;
    var style = mxUtils.getCurrentStyle(div);
    if (null != style) {
      this.resizeWidth = "auto" == style.width;
      this.resizeHeight = "auto" == style.height;
    }
    mxEvent.addListener(container, "resize", mxUtils.bind(this, function(flex) {
      if (!this.handlingResize) {
        this.handlingResize = true;
        this.resize();
        this.handlingResize = false;
      }
    }));
    this.resize();
  }
}
mxDivResizer.prototype.resizeWidth = true;
mxDivResizer.prototype.resizeHeight = true;
mxDivResizer.prototype.handlingResize = false;
mxDivResizer.prototype.resize = function() {
  var w = this.getDocumentWidth();
  var h = this.getDocumentHeight();
  var l = parseInt(this.div.style.left);
  var r = parseInt(this.div.style.right);
  var t = parseInt(this.div.style.top);
  var b = parseInt(this.div.style.bottom);
  if (this.resizeWidth) {
    if (!isNaN(l)) {
      if (!isNaN(r)) {
        if (0 <= l) {
          if (0 <= r) {
            if (0 < w - r - l) {
              this.div.style.width = w - r - l + "px";
            }
          }
        }
      }
    }
  }
  if (this.resizeHeight) {
    if (!isNaN(t)) {
      if (!isNaN(b)) {
        if (0 <= t) {
          if (0 <= b) {
            if (0 < h - t - b) {
              this.div.style.height = h - t - b + "px";
            }
          }
        }
      }
    }
  }
};
mxDivResizer.prototype.getDocumentWidth = function() {
  return document.body.clientWidth;
};
mxDivResizer.prototype.getDocumentHeight = function() {
  return document.body.clientHeight;
};
function mxDragSource(element, dropHandler) {
  this.element = element;
  this.dropHandler = dropHandler;
  mxEvent.addGestureListeners(element, mxUtils.bind(this, function(evt) {
    this.mouseDown(evt);
  }));
  mxEvent.addListener(element, "dragstart", function(evt) {
    mxEvent.consume(evt);
  });
  this.eventConsumer = function(sender, evt) {
    var evtName = evt.getProperty("eventName");
    var me = evt.getProperty("event");
    if (evtName != mxEvent.MOUSE_DOWN) {
      me.consume();
    }
  };
}
mxDragSource.prototype.element = null;
mxDragSource.prototype.dropHandler = null;
mxDragSource.prototype.dragOffset = null;
mxDragSource.prototype.dragElement = null;
mxDragSource.prototype.previewElement = null;
mxDragSource.prototype.previewOffset = null;
mxDragSource.prototype.enabled = true;
mxDragSource.prototype.currentGraph = null;
mxDragSource.prototype.currentDropTarget = null;
mxDragSource.prototype.currentPoint = null;
mxDragSource.prototype.currentGuide = null;
mxDragSource.prototype.currentHighlight = null;
mxDragSource.prototype.autoscroll = true;
mxDragSource.prototype.guidesEnabled = true;
mxDragSource.prototype.gridEnabled = true;
mxDragSource.prototype.highlightDropTargets = true;
mxDragSource.prototype.dragElementZIndex = 100;
mxDragSource.prototype.dragElementOpacity = 70;
mxDragSource.prototype.checkEventSource = true;
mxDragSource.prototype.isEnabled = function() {
  return this.enabled;
};
mxDragSource.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxDragSource.prototype.isGuidesEnabled = function() {
  return this.guidesEnabled;
};
mxDragSource.prototype.setGuidesEnabled = function(value) {
  this.guidesEnabled = value;
};
mxDragSource.prototype.isGridEnabled = function() {
  return this.gridEnabled;
};
mxDragSource.prototype.setGridEnabled = function(value) {
  this.gridEnabled = value;
};
mxDragSource.prototype.getGraphForEvent = function(evt) {
  return null;
};
mxDragSource.prototype.getDropTarget = function(graph, x, y, clone) {
  return graph.getCellAt(x, y);
};
mxDragSource.prototype.createDragElement = function(evt) {
  return this.element.cloneNode(true);
};
mxDragSource.prototype.createPreviewElement = function(graph) {
  return null;
};
mxDragSource.prototype.isActive = function() {
  return null != this.mouseMoveHandler;
};
mxDragSource.prototype.reset = function() {
  if (null != this.currentGraph) {
    this.dragExit(this.currentGraph);
    this.currentGraph = null;
  }
  this.removeDragElement();
  this.removeListeners();
  this.stopDrag();
};
mxDragSource.prototype.mouseDown = function(evt) {
  if (this.enabled) {
    if (!mxEvent.isConsumed(evt)) {
      if (null == this.mouseMoveHandler) {
        this.startDrag(evt);
        this.mouseMoveHandler = mxUtils.bind(this, this.mouseMove);
        this.mouseUpHandler = mxUtils.bind(this, this.mouseUp);
        mxEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
        if (mxClient.IS_TOUCH) {
          if (!mxEvent.isMouseEvent(evt)) {
            this.eventSource = mxEvent.getSource(evt);
            mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
          }
        }
      }
    }
  }
};
mxDragSource.prototype.startDrag = function(evt) {
  this.dragElement = this.createDragElement(evt);
  this.dragElement.style.position = "absolute";
  this.dragElement.style.zIndex = this.dragElementZIndex;
  mxUtils.setOpacity(this.dragElement, this.dragElementOpacity);
  if (this.checkEventSource) {
    if (mxClient.IS_SVG) {
      this.dragElement.style.pointerEvents = "none";
    }
  }
};
mxDragSource.prototype.stopDrag = function() {
  this.removeDragElement();
};
mxDragSource.prototype.removeDragElement = function() {
  if (null != this.dragElement) {
    if (null != this.dragElement.parentNode) {
      this.dragElement.parentNode.removeChild(this.dragElement);
    }
    this.dragElement = null;
  }
};
mxDragSource.prototype.getElementForEvent = function(evt) {
  return mxEvent.isTouchEvent(evt) || mxEvent.isPenEvent(evt) ? document.elementFromPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt)) : mxEvent.getSource(evt);
};
mxDragSource.prototype.graphContainsEvent = function(graph, evt) {
  var x = mxEvent.getClientX(evt);
  var y = mxEvent.getClientY(evt);
  var offset = mxUtils.getOffset(graph.container);
  var origin = mxUtils.getScrollOrigin();
  var elt = this.getElementForEvent(evt);
  if (this.checkEventSource) {
    for (;null != elt && elt != graph.container;) {
      elt = elt.parentNode;
    }
  }
  return null != elt && (x >= offset.x - origin.x && (y >= offset.y - origin.y && (x <= offset.x - origin.x + graph.container.offsetWidth && y <= offset.y - origin.y + graph.container.offsetHeight)));
};
mxDragSource.prototype.mouseMove = function(evt) {
  var graph = this.getGraphForEvent(evt);
  if (!(null == graph)) {
    if (!this.graphContainsEvent(graph, evt)) {
      graph = null;
    }
  }
  if (graph != this.currentGraph) {
    if (null != this.currentGraph) {
      this.dragExit(this.currentGraph, evt);
    }
    this.currentGraph = graph;
    if (null != this.currentGraph) {
      this.dragEnter(this.currentGraph, evt);
    }
  }
  if (null != this.currentGraph) {
    this.dragOver(this.currentGraph, evt);
  }
  if (null == this.dragElement || null != this.previewElement && "visible" == this.previewElement.style.visibility) {
    if (null != this.dragElement) {
      this.dragElement.style.visibility = "hidden";
    }
  } else {
    graph = mxEvent.getClientX(evt);
    var y = mxEvent.getClientY(evt);
    if (null == this.dragElement.parentNode) {
      document.body.appendChild(this.dragElement);
    }
    this.dragElement.style.visibility = "visible";
    if (null != this.dragOffset) {
      graph += this.dragOffset.x;
      y += this.dragOffset.y;
    }
    var offset = mxUtils.getDocumentScrollOrigin(document);
    this.dragElement.style.left = graph + offset.x + "px";
    this.dragElement.style.top = y + offset.y + "px";
  }
  mxEvent.consume(evt);
};
mxDragSource.prototype.mouseUp = function(evt) {
  if (null != this.currentGraph) {
    if (null != this.currentPoint && (null == this.previewElement || "hidden" != this.previewElement.style.visibility)) {
      var scale = this.currentGraph.view.scale;
      var tr = this.currentGraph.view.translate;
      this.drop(this.currentGraph, evt, this.currentDropTarget, this.currentPoint.x / scale - tr.x, this.currentPoint.y / scale - tr.y);
    }
    this.dragExit(this.currentGraph);
    this.currentGraph = null;
  }
  this.stopDrag();
  this.removeListeners();
  mxEvent.consume(evt);
};
mxDragSource.prototype.removeListeners = function() {
  if (null != this.eventSource) {
    mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
    this.eventSource = null;
  }
  mxEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
  this.mouseUpHandler = this.mouseMoveHandler = null;
};
mxDragSource.prototype.dragEnter = function(graph, evt) {
  graph.isMouseDown = true;
  graph.isMouseTrigger = mxEvent.isMouseEvent(evt);
  this.previewElement = this.createPreviewElement(graph);
  if (null != this.previewElement) {
    if (this.checkEventSource) {
      if (mxClient.IS_SVG) {
        this.previewElement.style.pointerEvents = "none";
      }
    }
  }
  if (this.isGuidesEnabled()) {
    if (null != this.previewElement) {
      this.currentGuide = new mxGuide(graph, graph.graphHandler.getGuideStates());
    }
  }
  if (this.highlightDropTargets) {
    this.currentHighlight = new mxCellHighlight(graph, mxConstants.DROP_TARGET_COLOR);
  }
  graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.eventConsumer);
};
mxDragSource.prototype.dragExit = function(graph, evt) {
  this.currentPoint = this.currentDropTarget = null;
  graph.isMouseDown = false;
  graph.removeListener(this.eventConsumer);
  if (null != this.previewElement) {
    if (null != this.previewElement.parentNode) {
      this.previewElement.parentNode.removeChild(this.previewElement);
    }
    this.previewElement = null;
  }
  if (null != this.currentGuide) {
    this.currentGuide.destroy();
    this.currentGuide = null;
  }
  if (null != this.currentHighlight) {
    this.currentHighlight.destroy();
    this.currentHighlight = null;
  }
};
mxDragSource.prototype.dragOver = function(graph, evt) {
  var y = mxUtils.getOffset(graph.container);
  var scale = mxUtils.getScrollOrigin(graph.container);
  var x = mxEvent.getClientX(evt) - y.x + scale.x - graph.panDx;
  y = mxEvent.getClientY(evt) - y.y + scale.y - graph.panDy;
  if (graph.autoScroll) {
    if (null == this.autoscroll || this.autoscroll) {
      graph.scrollPointToVisible(x, y, graph.autoExtend);
    }
  }
  if (null != this.currentHighlight) {
    if (graph.isDropEnabled()) {
      this.currentDropTarget = this.getDropTarget(graph, x, y, evt);
      scale = graph.getView().getState(this.currentDropTarget);
      this.currentHighlight.highlight(scale);
    }
  }
  if (null != this.previewElement) {
    if (null == this.previewElement.parentNode) {
      graph.container.appendChild(this.previewElement);
      this.previewElement.style.zIndex = "3";
      this.previewElement.style.position = "absolute";
    }
    var gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt);
    var h = true;
    if (null != this.currentGuide && this.currentGuide.isEnabledForEvent(evt)) {
      graph = parseInt(this.previewElement.style.width);
      h = parseInt(this.previewElement.style.height);
      graph = new mxRectangle(0, 0, graph, h);
      y = new mxPoint(x, y);
      y = this.currentGuide.move(graph, y, gridEnabled, true);
      h = false;
      x = y.x;
      y = y.y;
    } else {
      if (gridEnabled) {
        var scale = graph.view.scale;
        var tr = graph.view.translate;
        var off = graph.gridSize / 2;
        x = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;
        y = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;
      }
    }
    if (null != this.currentGuide) {
      if (h) {
        this.currentGuide.hide();
      }
    }
    if (null != this.previewOffset) {
      x += this.previewOffset.x;
      y += this.previewOffset.y;
    }
    this.previewElement.style.left = Math.round(x) + "px";
    this.previewElement.style.top = Math.round(y) + "px";
    this.previewElement.style.visibility = "visible";
  }
  this.currentPoint = new mxPoint(x, y);
};
mxDragSource.prototype.drop = function(graph, evt, dropTarget, x, y) {
  this.dropHandler.apply(this, arguments);
  if ("hidden" != graph.container.style.visibility) {
    graph.container.focus();
  }
};
function mxToolbar(container) {
  this.container = container;
}
mxToolbar.prototype = new mxEventSource;
mxToolbar.prototype.constructor = mxToolbar;
mxToolbar.prototype.container = null;
mxToolbar.prototype.enabled = true;
mxToolbar.prototype.noReset = false;
mxToolbar.prototype.updateDefaultMode = true;
mxToolbar.prototype.addItem = function(title, icon, funct, value, style, factoryMethod) {
  var img = document.createElement(null != icon ? "img" : "button");
  var initialClassName = style || (null != factoryMethod ? "mxToolbarMode" : "mxToolbarItem");
  img.className = initialClassName;
  img.setAttribute("src", icon);
  if (null != title) {
    if (null != icon) {
      img.setAttribute("title", title);
    } else {
      mxUtils.write(img, title);
    }
  }
  this.container.appendChild(img);
  if (null != funct) {
    mxEvent.addListener(img, "click", funct);
    if (mxClient.IS_TOUCH) {
      mxEvent.addListener(img, "touchend", funct);
    }
  }
  title = mxUtils.bind(this, function(flex) {
    if (null != value) {
      img.setAttribute("src", icon);
    } else {
      img.style.backgroundColor = "";
    }
  });
  mxEvent.addGestureListeners(img, mxUtils.bind(this, function(evt) {
    if (null != value) {
      img.setAttribute("src", value);
    } else {
      img.style.backgroundColor = "gray";
    }
    if (null != factoryMethod) {
      if (null == this.menu) {
        this.menu = new mxPopupMenu;
        this.menu.init();
      }
      var point = this.currentImg;
      if (this.menu.isMenuShowing()) {
        this.menu.hideMenu();
      }
      if (point != img) {
        this.currentImg = img;
        this.menu.factoryMethod = factoryMethod;
        point = new mxPoint(img.offsetLeft, img.offsetTop + img.offsetHeight);
        this.menu.popup(point.x, point.y, null, evt);
        if (this.menu.isMenuShowing()) {
          img.className = initialClassName + "Selected";
          this.menu.hideMenu = function() {
            mxPopupMenu.prototype.hideMenu.apply(this);
            img.className = initialClassName;
            this.currentImg = null;
          };
        }
      }
    }
  }), null, title);
  mxEvent.addListener(img, "mouseout", title);
  return img;
};
mxToolbar.prototype.addCombo = function(style) {
  var div = document.createElement("div");
  div.style.display = "inline";
  div.className = "mxToolbarComboContainer";
  var select = document.createElement("select");
  select.className = style || "mxToolbarCombo";
  div.appendChild(select);
  this.container.appendChild(div);
  return select;
};
mxToolbar.prototype.addActionCombo = function(title, style) {
  var select = document.createElement("select");
  select.className = style || "mxToolbarCombo";
  this.addOption(select, title, null);
  mxEvent.addListener(select, "change", function(evt) {
    var value = select.options[select.selectedIndex];
    select.selectedIndex = 0;
    if (null != value.funct) {
      value.funct(evt);
    }
  });
  this.container.appendChild(select);
  return select;
};
mxToolbar.prototype.addOption = function(combo, label, value) {
  var option = document.createElement("option");
  mxUtils.writeln(option, label);
  if ("function" == typeof value) {
    option.funct = value;
  } else {
    option.setAttribute("value", value);
  }
  combo.appendChild(option);
  return option;
};
mxToolbar.prototype.addSwitchMode = function(value, title, funct, pressedIcon, style) {
  var img = document.createElement("img");
  img.initialClassName = style || "mxToolbarMode";
  img.className = img.initialClassName;
  img.setAttribute("src", title);
  img.altIcon = pressedIcon;
  if (null != value) {
    img.setAttribute("title", value);
  }
  mxEvent.addListener(img, "click", mxUtils.bind(this, function(tmp) {
    tmp = this.selectedMode.altIcon;
    if (null != tmp) {
      this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
      this.selectedMode.setAttribute("src", tmp);
    } else {
      this.selectedMode.className = this.selectedMode.initialClassName;
    }
    if (this.updateDefaultMode) {
      this.defaultMode = img;
    }
    this.selectedMode = img;
    tmp = img.altIcon;
    if (null != tmp) {
      img.altIcon = img.getAttribute("src");
      img.setAttribute("src", tmp);
    } else {
      img.className = img.initialClassName + "Selected";
    }
    this.fireEvent(new mxEventObject(mxEvent.SELECT));
    funct();
  }));
  this.container.appendChild(img);
  if (null == this.defaultMode) {
    this.defaultMode = img;
    this.selectMode(img);
    funct();
  }
  return img;
};
mxToolbar.prototype.addMode = function(title, value, funct, pressedIcon, style, toggle) {
  toggle = null != toggle ? toggle : true;
  var img = document.createElement(null != value ? "img" : "button");
  img.initialClassName = style || "mxToolbarMode";
  img.className = img.initialClassName;
  img.setAttribute("src", value);
  img.altIcon = pressedIcon;
  if (null != title) {
    img.setAttribute("title", title);
  }
  if (this.enabled) {
    if (toggle) {
      mxEvent.addListener(img, "click", mxUtils.bind(this, function(flex) {
        this.selectMode(img, funct);
        this.noReset = false;
      }));
      mxEvent.addListener(img, "dblclick", mxUtils.bind(this, function(flex) {
        this.selectMode(img, funct);
        this.noReset = true;
      }));
      if (null == this.defaultMode) {
        this.defaultMode = img;
        this.defaultFunction = funct;
        this.selectMode(img, funct);
      }
    }
  }
  this.container.appendChild(img);
  return img;
};
mxToolbar.prototype.selectMode = function(domNode, funct) {
  if (this.selectedMode != domNode) {
    if (null != this.selectedMode) {
      var tmp = this.selectedMode.altIcon;
      if (null != tmp) {
        this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
        this.selectedMode.setAttribute("src", tmp);
      } else {
        this.selectedMode.className = this.selectedMode.initialClassName;
      }
    }
    this.selectedMode = domNode;
    tmp = this.selectedMode.altIcon;
    if (null != tmp) {
      this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
      this.selectedMode.setAttribute("src", tmp);
    } else {
      this.selectedMode.className = this.selectedMode.initialClassName + "Selected";
    }
    this.fireEvent(new mxEventObject(mxEvent.SELECT, "function", funct));
  }
};
mxToolbar.prototype.resetMode = function(forced) {
  if (!(!forced && this.noReset)) {
    if (!(this.selectedMode == this.defaultMode)) {
      this.selectMode(this.defaultMode, this.defaultFunction);
    }
  }
};
mxToolbar.prototype.addSeparator = function(icon) {
  return this.addItem(null, icon, null);
};
mxToolbar.prototype.addBreak = function() {
  mxUtils.br(this.container);
};
mxToolbar.prototype.addLine = function() {
  var hr = document.createElement("hr");
  hr.style.marginRight = "6px";
  hr.setAttribute("size", "1");
  this.container.appendChild(hr);
};
mxToolbar.prototype.destroy = function() {
  mxEvent.release(this.container);
  this.selectedMode = this.defaultFunction = this.defaultMode = this.container = null;
  if (null != this.menu) {
    this.menu.destroy();
  }
};
function mxUndoableEdit(source, significant) {
  this.source = source;
  this.changes = [];
  this.significant = null != significant ? significant : true;
}
mxUndoableEdit.prototype.source = null;
mxUndoableEdit.prototype.changes = null;
mxUndoableEdit.prototype.significant = null;
mxUndoableEdit.prototype.undone = false;
mxUndoableEdit.prototype.redone = false;
mxUndoableEdit.prototype.isEmpty = function() {
  return 0 == this.changes.length;
};
mxUndoableEdit.prototype.isSignificant = function() {
  return this.significant;
};
mxUndoableEdit.prototype.add = function(parent) {
  this.changes.push(parent);
};
mxUndoableEdit.prototype.notify = function() {
};
mxUndoableEdit.prototype.die = function() {
};
mxUndoableEdit.prototype.undo = function() {
  if (!this.undone) {
    this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
    for (var i = this.changes.length - 1;0 <= i;i--) {
      var change = this.changes[i];
      if (null != change.execute) {
        change.execute();
      } else {
        if (null != change.undo) {
          change.undo();
        }
      }
      this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
    }
    this.undone = true;
    this.redone = false;
    this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  this.notify();
};
mxUndoableEdit.prototype.redo = function() {
  if (!this.redone) {
    this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
    var count = this.changes.length;
    for (var i = 0;i < count;i++) {
      var change = this.changes[i];
      if (null != change.execute) {
        change.execute();
      } else {
        if (null != change.redo) {
          change.redo();
        }
      }
      this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
    }
    this.undone = false;
    this.redone = true;
    this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  this.notify();
};
function mxUndoManager(size) {
  this.size = null != size ? size : 100;
  this.clear();
}
mxUndoManager.prototype = new mxEventSource;
mxUndoManager.prototype.constructor = mxUndoManager;
mxUndoManager.prototype.size = null;
mxUndoManager.prototype.history = null;
mxUndoManager.prototype.indexOfNextAdd = 0;
mxUndoManager.prototype.isEmpty = function() {
  return 0 == this.history.length;
};
mxUndoManager.prototype.clear = function() {
  this.history = [];
  this.indexOfNextAdd = 0;
  this.fireEvent(new mxEventObject(mxEvent.CLEAR));
};
mxUndoManager.prototype.canUndo = function() {
  return 0 < this.indexOfNextAdd;
};
mxUndoManager.prototype.undo = function() {
  for (;0 < this.indexOfNextAdd;) {
    var edit = this.history[--this.indexOfNextAdd];
    edit.undo();
    if (edit.isSignificant()) {
      this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", edit));
      break;
    }
  }
};
mxUndoManager.prototype.canRedo = function() {
  return this.indexOfNextAdd < this.history.length;
};
mxUndoManager.prototype.redo = function() {
  for (var n = this.history.length;this.indexOfNextAdd < n;) {
    var edit = this.history[this.indexOfNextAdd++];
    edit.redo();
    if (edit.isSignificant()) {
      this.fireEvent(new mxEventObject(mxEvent.REDO, "edit", edit));
      break;
    }
  }
};
mxUndoManager.prototype.undoableEditHappened = function(undoableEdit) {
  this.trim();
  if (0 < this.size) {
    if (this.size == this.history.length) {
      this.history.shift();
    }
  }
  this.history.push(undoableEdit);
  this.indexOfNextAdd = this.history.length;
  this.fireEvent(new mxEventObject(mxEvent.ADD, "edit", undoableEdit));
};
mxUndoManager.prototype.trim = function() {
  if (this.history.length > this.indexOfNextAdd) {
    var edits = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd);
    for (var i = 0;i < edits.length;i++) {
      edits[i].die();
    }
  }
};
var mxUrlConverter = function() {
};
mxUrlConverter.prototype.enabled = true;
mxUrlConverter.prototype.baseUrl = null;
mxUrlConverter.prototype.baseDomain = null;
mxUrlConverter.prototype.updateBaseUrl = function() {
  this.baseDomain = location.protocol + "//" + location.host;
  this.baseUrl = this.baseDomain + location.pathname;
  var tmp = this.baseUrl.lastIndexOf("/");
  if (0 < tmp) {
    this.baseUrl = this.baseUrl.substring(0, tmp + 1);
  }
};
mxUrlConverter.prototype.isEnabled = function() {
  return this.enabled;
};
mxUrlConverter.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxUrlConverter.prototype.getBaseUrl = function() {
  return this.baseUrl;
};
mxUrlConverter.prototype.setBaseUrl = function(value) {
  this.baseUrl = value;
};
mxUrlConverter.prototype.getBaseDomain = function() {
  return this.baseDomain;
};
mxUrlConverter.prototype.setBaseDomain = function(value) {
  this.baseDomain = value;
};
mxUrlConverter.prototype.isRelativeUrl = function(url) {
  return null != url && ("//" != url.substring(0, 2) && ("http://" != url.substring(0, 7) && ("https://" != url.substring(0, 8) && ("data:image" != url.substring(0, 10) && "file://" != url.substring(0, 7)))));
};
mxUrlConverter.prototype.convert = function(url) {
  if (this.isEnabled()) {
    if (this.isRelativeUrl(url)) {
      if (null == this.getBaseUrl()) {
        this.updateBaseUrl();
      }
      url = "/" == url.charAt(0) ? this.getBaseDomain() + url : this.getBaseUrl() + url;
    }
  }
  return url;
};
function mxPanningManager(graph) {
  this.thread = null;
  this.active = false;
  this.dy = this.dx = this.t0y = this.t0x = this.tdy = this.tdx = 0;
  this.scrollbars = false;
  this.scrollTop = this.scrollLeft = 0;
  this.mouseListener = {
    mouseDown : function(cell, sender) {
    },
    mouseMove : function(sender, me) {
    },
    mouseUp : mxUtils.bind(this, function(flex, editor) {
      if (this.active) {
        this.stop();
      }
    })
  };
  graph.addMouseListener(this.mouseListener);
  this.mouseUpListener = mxUtils.bind(this, function() {
    if (this.active) {
      this.stop();
    }
  });
  mxEvent.addListener(document, "mouseup", this.mouseUpListener);
  var createThread = mxUtils.bind(this, function() {
    this.scrollbars = mxUtils.hasScrollbars(graph.container);
    this.scrollLeft = graph.container.scrollLeft;
    this.scrollTop = graph.container.scrollTop;
    return window.setInterval(mxUtils.bind(this, function() {
      this.tdx -= this.dx;
      this.tdy -= this.dy;
      if (this.scrollbars) {
        graph.panGraph(-graph.container.scrollLeft - Math.ceil(this.dx), -graph.container.scrollTop - Math.ceil(this.dy));
        graph.panDx = this.scrollLeft - graph.container.scrollLeft;
        graph.panDy = this.scrollTop - graph.container.scrollTop;
        graph.fireEvent(new mxEventObject(mxEvent.PAN));
      } else {
        graph.panGraph(this.getDx(), this.getDy());
      }
    }), this.delay);
  });
  this.isActive = function() {
    return active;
  };
  this.getDx = function() {
    return Math.round(this.tdx);
  };
  this.getDy = function() {
    return Math.round(this.tdy);
  };
  this.start = function() {
    this.t0x = graph.view.translate.x;
    this.t0y = graph.view.translate.y;
    this.active = true;
  };
  this.panTo = function(x, y, h, w) {
    if (!this.active) {
      this.start();
    }
    this.scrollLeft = graph.container.scrollLeft;
    this.scrollTop = graph.container.scrollTop;
    var c = graph.container;
    this.dx = x + (null != h ? h : 0) - c.scrollLeft - c.clientWidth;
    this.dx = 0 > this.dx && Math.abs(this.dx) < this.border ? this.border + this.dx : this.handleMouseOut ? Math.max(this.dx, 0) : 0;
    if (0 == this.dx) {
      this.dx = x - c.scrollLeft;
      this.dx = 0 < this.dx && this.dx < this.border ? this.dx - this.border : this.handleMouseOut ? Math.min(0, this.dx) : 0;
    }
    this.dy = y + (null != w ? w : 0) - c.scrollTop - c.clientHeight;
    this.dy = 0 > this.dy && Math.abs(this.dy) < this.border ? this.border + this.dy : this.handleMouseOut ? Math.max(this.dy, 0) : 0;
    if (0 == this.dy) {
      this.dy = y - c.scrollTop;
      this.dy = 0 < this.dy && this.dy < this.border ? this.dy - this.border : this.handleMouseOut ? Math.min(0, this.dy) : 0;
    }
    if (0 != this.dx || 0 != this.dy) {
      this.dx *= this.damper;
      this.dy *= this.damper;
      if (null == this.thread) {
        this.thread = createThread();
      }
    } else {
      if (null != this.thread) {
        window.clearInterval(this.thread);
        this.thread = null;
      }
    }
  };
  this.stop = function() {
    if (this.active) {
      if (this.active = false, null != this.thread && (window.clearInterval(this.thread), this.thread = null), this.tdy = this.tdx = 0, this.scrollbars) {
        graph.panDx = 0;
        graph.panDy = 0;
        graph.fireEvent(new mxEventObject(mxEvent.PAN));
      } else {
        var px = graph.panDx;
        var py = graph.panDy;
        if (0 != px || 0 != py) {
          graph.panGraph(0, 0);
          graph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);
        }
      }
    }
  };
  this.destroy = function() {
    graph.removeMouseListener(this.mouseListener);
    mxEvent.removeListener(document, "mouseup", this.mouseUpListener);
  };
}
mxPanningManager.prototype.damper = 1 / 6;
mxPanningManager.prototype.delay = 10;
mxPanningManager.prototype.handleMouseOut = true;
mxPanningManager.prototype.border = 0;
function mxPopupMenu(factoryMethod) {
  this.factoryMethod = factoryMethod;
  if (null != factoryMethod) {
    this.init();
  }
}
mxPopupMenu.prototype = new mxEventSource;
mxPopupMenu.prototype.constructor = mxPopupMenu;
mxPopupMenu.prototype.submenuImage = mxClient.imageBasePath + "/submenu.gif";
mxPopupMenu.prototype.zIndex = 10006;
mxPopupMenu.prototype.factoryMethod = null;
mxPopupMenu.prototype.useLeftButtonForPopup = false;
mxPopupMenu.prototype.enabled = true;
mxPopupMenu.prototype.itemCount = 0;
mxPopupMenu.prototype.autoExpand = false;
mxPopupMenu.prototype.smartSeparators = false;
mxPopupMenu.prototype.labels = true;
mxPopupMenu.prototype.init = function() {
  this.table = document.createElement("table");
  this.table.className = "mxPopupMenu";
  this.tbody = document.createElement("tbody");
  this.table.appendChild(this.tbody);
  this.div = document.createElement("div");
  this.div.className = "mxPopupMenu";
  this.div.style.display = "inline";
  this.div.style.zIndex = this.zIndex;
  this.div.appendChild(this.table);
  mxEvent.disableContextMenu(this.div);
};
mxPopupMenu.prototype.isEnabled = function() {
  return this.enabled;
};
mxPopupMenu.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxPopupMenu.prototype.isPopupTrigger = function(me) {
  return me.isPopupTrigger() || this.useLeftButtonForPopup && mxEvent.isLeftMouseButton(me.getEvent());
};
mxPopupMenu.prototype.addItem = function(col3, div, funct, parent, iconCls, noHover, pressedIcon, image) {
  parent = parent || this;
  this.itemCount++;
  if (parent.willAddSeparator) {
    if (parent.containsItems) {
      this.addSeparator(parent, true);
    }
    parent.willAddSeparator = false;
  }
  parent.containsItems = true;
  var tr = document.createElement("tr");
  tr.className = "mxPopupMenuItem";
  var col2 = document.createElement("td");
  col2.className = "mxPopupMenuIcon";
  if (null != div) {
    iconCls = document.createElement("img");
    iconCls.src = div;
    col2.appendChild(iconCls);
  } else {
    if (null != iconCls) {
      div = document.createElement("div");
      div.className = iconCls;
      col2.appendChild(div);
    }
  }
  tr.appendChild(col2);
  if (this.labels) {
    col2 = document.createElement("td");
    col2.className = "mxPopupMenuItem" + (null == noHover || noHover ? "" : " mxDisabled");
    mxUtils.write(col2, col3);
    col2.align = "left";
    tr.appendChild(col2);
    col3 = document.createElement("td");
    col3.className = "mxPopupMenuItem" + (null == noHover || noHover ? "" : " mxDisabled");
    col3.style.paddingRight = "6px";
    col3.style.textAlign = "right";
    tr.appendChild(col3);
    if (null == parent.div) {
      this.createSubmenu(parent);
    }
  }
  parent.tbody.appendChild(tr);
  if (0 != pressedIcon && 0 != noHover) {
    var currentSelection = null;
    mxEvent.addGestureListeners(tr, mxUtils.bind(this, function(evt) {
      this.eventReceiver = tr;
      if (parent.activeRow != tr) {
        if (parent.activeRow != parent) {
          if (null != parent.activeRow) {
            if (null != parent.activeRow.div.parentNode) {
              this.hideSubmenu(parent);
            }
          }
          if (null != tr.div) {
            this.showSubmenu(parent, tr);
            parent.activeRow = tr;
          }
        }
      }
      if (null != document.selection) {
        if (8 == document.documentMode) {
          currentSelection = document.selection.createRange();
        }
      }
      mxEvent.consume(evt);
    }), mxUtils.bind(this, function(flex) {
      if (parent.activeRow != tr) {
        if (parent.activeRow != parent) {
          if (null != parent.activeRow) {
            if (null != parent.activeRow.div.parentNode) {
              this.hideSubmenu(parent);
            }
          }
          if (this.autoExpand) {
            if (null != tr.div) {
              this.showSubmenu(parent, tr);
              parent.activeRow = tr;
            }
          }
        }
      }
      if (!image) {
        tr.className = "mxPopupMenuItemHover";
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.eventReceiver == tr) {
        if (parent.activeRow != tr) {
          this.hideMenu();
        }
        if (null != currentSelection) {
          try {
            currentSelection.select();
          } catch (q) {
          }
          currentSelection = null;
        }
        if (null != funct) {
          funct(evt);
        }
      }
      this.eventReceiver = null;
      mxEvent.consume(evt);
    }));
    if (!image) {
      mxEvent.addListener(tr, "mouseout", mxUtils.bind(this, function(flex) {
        tr.className = "mxPopupMenuItem";
      }));
    }
  }
  return tr;
};
mxPopupMenu.prototype.addCheckmark = function(node, img) {
  node = node.firstChild.nextSibling;
  node.style.backgroundImage = "url('" + img + "')";
  node.style.backgroundRepeat = "no-repeat";
  node.style.backgroundPosition = "2px 50%";
};
mxPopupMenu.prototype.createSubmenu = function(parent) {
  parent.table = document.createElement("table");
  parent.table.className = "mxPopupMenu";
  parent.tbody = document.createElement("tbody");
  parent.table.appendChild(parent.tbody);
  parent.div = document.createElement("div");
  parent.div.className = "mxPopupMenu";
  parent.div.style.position = "absolute";
  parent.div.style.display = "inline";
  parent.div.style.zIndex = this.zIndex;
  parent.div.appendChild(parent.table);
  var img = document.createElement("img");
  img.setAttribute("src", this.submenuImage);
  td = parent.firstChild.nextSibling.nextSibling;
  td.appendChild(img);
};
mxPopupMenu.prototype.showSubmenu = function(parent, row) {
  if (null != row.div) {
    row.div.style.left = parent.div.offsetLeft + row.offsetLeft + row.offsetWidth - 1 + "px";
    row.div.style.top = parent.div.offsetTop + row.offsetTop + "px";
    document.body.appendChild(row.div);
    var left = parseInt(row.div.offsetLeft);
    var width = parseInt(row.div.offsetWidth);
    var offset = mxUtils.getDocumentScrollOrigin(document);
    var d = document.documentElement;
    if (left + width > offset.x + (document.body.clientWidth || d.clientWidth)) {
      row.div.style.left = Math.max(0, parent.div.offsetLeft - width + (mxClient.IS_IE ? 6 : -6)) + "px";
    }
    row.div.style.overflowY = "auto";
    row.div.style.overflowX = "hidden";
    row.div.style.maxHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight) - 10 + "px";
    mxUtils.fit(row.div);
  }
};
mxPopupMenu.prototype.addSeparator = function(parent, force) {
  parent = parent || this;
  if (this.smartSeparators && !force) {
    parent.willAddSeparator = true;
  } else {
    if (null != parent.tbody) {
      parent.willAddSeparator = false;
      force = document.createElement("tr");
      var col2 = document.createElement("td");
      col2.className = "mxPopupMenuIcon";
      col2.style.padding = "0 0 0 0px";
      force.appendChild(col2);
      col2 = document.createElement("td");
      col2.style.padding = "0 0 0 0px";
      col2.setAttribute("colSpan", "2");
      var hr = document.createElement("hr");
      hr.setAttribute("size", "1");
      col2.appendChild(hr);
      force.appendChild(col2);
      parent.tbody.appendChild(force);
    }
  }
};
mxPopupMenu.prototype.popup = function(x, y, cell, evt) {
  if (null != this.div && (null != this.tbody && null != this.factoryMethod)) {
    this.div.style.left = x + "px";
    for (this.div.style.top = y + "px";null != this.tbody.firstChild;) {
      mxEvent.release(this.tbody.firstChild);
      this.tbody.removeChild(this.tbody.firstChild);
    }
    this.itemCount = 0;
    this.factoryMethod(this, cell, evt);
    if (0 < this.itemCount) {
      this.showMenu();
      this.fireEvent(new mxEventObject(mxEvent.SHOW));
    }
  }
};
mxPopupMenu.prototype.isMenuShowing = function() {
  return null != this.div && this.div.parentNode == document.body;
};
mxPopupMenu.prototype.showMenu = function() {
  if (9 <= document.documentMode) {
    this.div.style.filter = "none";
  }
  document.body.appendChild(this.div);
  mxUtils.fit(this.div);
};
mxPopupMenu.prototype.hideMenu = function() {
  if (null != this.div) {
    if (null != this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
    this.hideSubmenu(this);
    this.containsItems = false;
    this.fireEvent(new mxEventObject(mxEvent.HIDE));
  }
};
mxPopupMenu.prototype.hideSubmenu = function(parent) {
  if (null != parent.activeRow) {
    this.hideSubmenu(parent.activeRow);
    if (null != parent.activeRow.div.parentNode) {
      parent.activeRow.div.parentNode.removeChild(parent.activeRow.div);
    }
    parent.activeRow = null;
  }
};
mxPopupMenu.prototype.destroy = function() {
  if (null != this.div) {
    mxEvent.release(this.div);
    if (null != this.div.parentNode) {
      this.div.parentNode.removeChild(this.div);
    }
    this.div = null;
  }
};
function mxAutoSaveManager(graph) {
  this.changeHandler = mxUtils.bind(this, function(flex, evt) {
    if (this.isEnabled()) {
      this.graphModelChanged(evt.getProperty("edit").changes);
    }
  });
  this.setGraph(graph);
}
mxAutoSaveManager.prototype = new mxEventSource;
mxAutoSaveManager.prototype.constructor = mxAutoSaveManager;
mxAutoSaveManager.prototype.graph = null;
mxAutoSaveManager.prototype.autoSaveDelay = 10;
mxAutoSaveManager.prototype.autoSaveThrottle = 2;
mxAutoSaveManager.prototype.autoSaveThreshold = 5;
mxAutoSaveManager.prototype.ignoredChanges = 0;
mxAutoSaveManager.prototype.lastSnapshot = 0;
mxAutoSaveManager.prototype.enabled = true;
mxAutoSaveManager.prototype.changeHandler = null;
mxAutoSaveManager.prototype.isEnabled = function() {
  return this.enabled;
};
mxAutoSaveManager.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxAutoSaveManager.prototype.setGraph = function(graph) {
  if (null != this.graph) {
    this.graph.getModel().removeListener(this.changeHandler);
  }
  this.graph = graph;
  if (null != this.graph) {
    this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
  }
};
mxAutoSaveManager.prototype.save = function() {
};
mxAutoSaveManager.prototype.graphModelChanged = function(dt) {
  dt = ((new Date).getTime() - this.lastSnapshot) / 1E3;
  if (dt > this.autoSaveDelay || this.ignoredChanges >= this.autoSaveThreshold && dt > this.autoSaveThrottle) {
    this.save();
    this.reset();
  } else {
    this.ignoredChanges++;
  }
};
mxAutoSaveManager.prototype.reset = function() {
  this.lastSnapshot = (new Date).getTime();
  this.ignoredChanges = 0;
};
mxAutoSaveManager.prototype.destroy = function() {
  this.setGraph(null);
};
function mxAnimation(delay) {
  this.delay = null != delay ? delay : 20;
}
mxAnimation.prototype = new mxEventSource;
mxAnimation.prototype.constructor = mxAnimation;
mxAnimation.prototype.delay = null;
mxAnimation.prototype.thread = null;
mxAnimation.prototype.isRunning = function() {
  return null != this.thread;
};
mxAnimation.prototype.startAnimation = function() {
  if (null == this.thread) {
    this.thread = window.setInterval(mxUtils.bind(this, this.updateAnimation), this.delay);
  }
};
mxAnimation.prototype.updateAnimation = function() {
  this.fireEvent(new mxEventObject(mxEvent.EXECUTE));
};
mxAnimation.prototype.stopAnimation = function() {
  if (null != this.thread) {
    window.clearInterval(this.thread);
    this.thread = null;
    this.fireEvent(new mxEventObject(mxEvent.DONE));
  }
};
function mxMorphing(graph, steps, ease, delay) {
  mxAnimation.call(this, delay);
  this.graph = graph;
  this.steps = null != steps ? steps : 6;
  this.ease = null != ease ? ease : 1.5;
}
mxMorphing.prototype = new mxAnimation;
mxMorphing.prototype.constructor = mxMorphing;
mxMorphing.prototype.graph = null;
mxMorphing.prototype.steps = null;
mxMorphing.prototype.step = 0;
mxMorphing.prototype.ease = null;
mxMorphing.prototype.cells = null;
mxMorphing.prototype.updateAnimation = function() {
  mxAnimation.prototype.updateAnimation.apply(this, arguments);
  var move = new mxCellStatePreview(this.graph);
  if (null != this.cells) {
    for (var i = 0;i < this.cells.length;i++) {
      this.animateCell(this.cells[i], move, false);
    }
  } else {
    this.animateCell(this.graph.getModel().getRoot(), move, true);
  }
  this.show(move);
  if (move.isEmpty() || this.step++ >= this.steps) {
    this.stopAnimation();
  }
};
mxMorphing.prototype.show = function(move) {
  move.show();
};
mxMorphing.prototype.animateCell = function(cell, move, recurse) {
  var state = this.graph.getView().getState(cell);
  var delta = null;
  if (null != state && (delta = this.getDelta(state), this.graph.getModel().isVertex(cell) && (0 != delta.x || 0 != delta.y))) {
    var spacing = this.graph.view.getTranslate();
    var scale = this.graph.view.getScale();
    delta.x += spacing.x * scale;
    delta.y += spacing.y * scale;
    move.moveState(state, -delta.x / this.ease, -delta.y / this.ease);
  }
  if (recurse && !this.stopRecursion(state, delta)) {
    state = this.graph.getModel().getChildCount(cell);
    for (delta = 0;delta < state;delta++) {
      this.animateCell(this.graph.getModel().getChildAt(cell, delta), move, recurse);
    }
  }
};
mxMorphing.prototype.stopRecursion = function(state, delta) {
  return null != delta && (0 != delta.x || 0 != delta.y);
};
mxMorphing.prototype.getDelta = function(state) {
  var origin = this.getOriginForCell(state.cell);
  var tr = this.graph.getView().getTranslate();
  var scale = this.graph.getView().getScale();
  return new mxPoint((origin.x - (state.x / scale - tr.x)) * scale, (origin.y - (state.y / scale - tr.y)) * scale);
};
mxMorphing.prototype.getOriginForCell = function(cell) {
  var result = null;
  if (null != cell) {
    var parent = this.graph.getModel().getParent(cell);
    cell = this.graph.getCellGeometry(cell);
    result = this.getOriginForCell(parent);
    if (null != cell) {
      if (cell.relative) {
        parent = this.graph.getCellGeometry(parent);
        if (null != parent) {
          result.x += cell.x * parent.width;
          result.y += cell.y * parent.height;
        }
      } else {
        result.x += cell.x;
        result.y += cell.y;
      }
    }
  }
  if (null == result) {
    result = this.graph.view.getTranslate();
    result = new mxPoint(-result.x, -result.y);
  }
  return result;
};
function mxImageBundle(alt) {
  this.images = [];
  this.alt = null != alt ? alt : false;
}
mxImageBundle.prototype.images = null;
mxImageBundle.prototype.alt = null;
mxImageBundle.prototype.putImage = function(key, value, fallback) {
  this.images[key] = {
    value : value,
    fallback : fallback
  };
};
mxImageBundle.prototype.getImage = function(state) {
  var result = null;
  if (null != state) {
    state = this.images[state];
    if (null != state) {
      result = this.alt ? state.fallback : state.value;
    }
  }
  return result;
};
function mxImageExport() {
}
mxImageExport.prototype.includeOverlays = false;
mxImageExport.prototype.drawState = function(state, canvas) {
  if (null != state) {
    this.visitStatesRecursive(state, canvas, mxUtils.bind(this, function() {
      this.drawCellState.apply(this, arguments);
    }));
    if (this.includeOverlays) {
      this.visitStatesRecursive(state, canvas, mxUtils.bind(this, function() {
        this.drawOverlays.apply(this, arguments);
      }));
    }
  }
};
mxImageExport.prototype.visitStatesRecursive = function(state, canvas, visitor) {
  if (null != state) {
    visitor(state, canvas);
    var graph = state.view.graph;
    var childCount = graph.model.getChildCount(state.cell);
    for (var i = 0;i < childCount;i++) {
      var childState = graph.view.getState(graph.model.getChildAt(state.cell, i));
      this.visitStatesRecursive(childState, canvas, visitor);
    }
  }
};
mxImageExport.prototype.getLinkForCellState = function(state, canvas) {
  return null;
};
mxImageExport.prototype.getLinkTargetForCellState = function(state, canvas) {
  return null;
};
mxImageExport.prototype.drawCellState = function(state, canvas) {
  var link = this.getLinkForCellState(state, canvas);
  if (null != link) {
    canvas.setLink(link, this.getLinkTargetForCellState(state, canvas));
  }
  this.drawShape(state, canvas);
  this.drawText(state, canvas);
  if (null != link) {
    canvas.setLink(null);
  }
};
mxImageExport.prototype.drawShape = function(state, canvas) {
  if (state.shape instanceof mxShape) {
    this.doDrawShape(state.shape, canvas);
  }
};
mxImageExport.prototype.drawText = function(state, canvas) {
  this.doDrawShape(state.text, canvas);
};
mxImageExport.prototype.doDrawShape = function(shape, canvas) {
  if (null != shape) {
    if (shape.checkBounds()) {
      canvas.save();
      shape.beforePaint(canvas);
      shape.paint(canvas);
      shape.afterPaint(canvas);
      canvas.restore();
    }
  }
};
mxImageExport.prototype.drawOverlays = function(state, canvas) {
  if (null != state.overlays) {
    state.overlays.visit(function(flex, shape) {
      if (shape instanceof mxShape) {
        shape.paint(canvas);
      }
    });
  }
};
function mxAbstractCanvas2D() {
  this.converter = this.createUrlConverter();
  this.reset();
}
mxAbstractCanvas2D.prototype.state = null;
mxAbstractCanvas2D.prototype.states = null;
mxAbstractCanvas2D.prototype.path = null;
mxAbstractCanvas2D.prototype.rotateHtml = true;
mxAbstractCanvas2D.prototype.lastX = 0;
mxAbstractCanvas2D.prototype.lastY = 0;
mxAbstractCanvas2D.prototype.moveOp = "M";
mxAbstractCanvas2D.prototype.lineOp = "L";
mxAbstractCanvas2D.prototype.quadOp = "Q";
mxAbstractCanvas2D.prototype.curveOp = "C";
mxAbstractCanvas2D.prototype.closeOp = "Z";
mxAbstractCanvas2D.prototype.pointerEvents = false;
mxAbstractCanvas2D.prototype.createUrlConverter = function() {
  return new mxUrlConverter;
};
mxAbstractCanvas2D.prototype.reset = function() {
  this.state = this.createState();
  this.states = [];
};
mxAbstractCanvas2D.prototype.createState = function() {
  return{
    dx : 0,
    dy : 0,
    scale : 1,
    alpha : 1,
    fillAlpha : 1,
    strokeAlpha : 1,
    fillColor : null,
    gradientFillAlpha : 1,
    gradientColor : null,
    gradientAlpha : 1,
    gradientDirection : null,
    strokeColor : null,
    strokeWidth : 1,
    dashed : false,
    dashPattern : "3 3",
    fixDash : false,
    lineCap : "flat",
    lineJoin : "miter",
    miterLimit : 10,
    fontColor : "#000000",
    fontBackgroundColor : null,
    fontBorderColor : null,
    fontSize : mxConstants.DEFAULT_FONTSIZE,
    fontFamily : mxConstants.DEFAULT_FONTFAMILY,
    fontStyle : 0,
    shadow : false,
    shadowColor : mxConstants.SHADOWCOLOR,
    shadowAlpha : mxConstants.SHADOW_OPACITY,
    shadowDx : mxConstants.SHADOW_OFFSET_X,
    shadowDy : mxConstants.SHADOW_OFFSET_Y,
    rotation : 0,
    rotationCx : 0,
    rotationCy : 0
  };
};
mxAbstractCanvas2D.prototype.format = function(value) {
  return Math.round(parseFloat(value));
};
mxAbstractCanvas2D.prototype.addOp = function() {
  if (null != this.path && (this.path.push(arguments[0]), 2 < arguments.length)) {
    var s = this.state;
    for (var i = 2;i < arguments.length;i += 2) {
      this.lastX = arguments[i - 1];
      this.lastY = arguments[i];
      this.path.push(this.format((this.lastX + s.dx) * s.scale));
      this.path.push(this.format((this.lastY + s.dy) * s.scale));
    }
  }
};
mxAbstractCanvas2D.prototype.rotatePoint = function(x, y, rad, cx, cy) {
  rad *= Math.PI / 180;
  return mxUtils.getRotatedPoint(new mxPoint(x, y), Math.cos(rad), Math.sin(rad), new mxPoint(cx, cy));
};
mxAbstractCanvas2D.prototype.save = function() {
  this.states.push(this.state);
  this.state = mxUtils.clone(this.state);
};
mxAbstractCanvas2D.prototype.restore = function() {
  if (0 < this.states.length) {
    this.state = this.states.pop();
  }
};
mxAbstractCanvas2D.prototype.setLink = function(link, flex) {
};
mxAbstractCanvas2D.prototype.scale = function(x) {
  this.state.scale *= x;
  this.state.strokeWidth *= x;
};
mxAbstractCanvas2D.prototype.translate = function(x, y) {
  this.state.dx += x;
  this.state.dy += y;
};
mxAbstractCanvas2D.prototype.rotate = function(angle, flipV, cy, theta, flipH) {
};
mxAbstractCanvas2D.prototype.setAlpha = function(value) {
  this.state.alpha = value;
};
mxAbstractCanvas2D.prototype.setFillAlpha = function(value) {
  this.state.fillAlpha = value;
};
mxAbstractCanvas2D.prototype.setStrokeAlpha = function(value) {
  this.state.strokeAlpha = value;
};
mxAbstractCanvas2D.prototype.setFillColor = function(fill) {
  if (fill == mxConstants.NONE) {
    fill = null;
  }
  this.state.fillColor = fill;
  this.state.gradientColor = null;
};
mxAbstractCanvas2D.prototype.setFillStyle = function(value) {
  if (value == mxConstants.NONE) {
    value = null;
  }
  this.state.fillStyle = value;
};
mxAbstractCanvas2D.prototype.setGradient = function(color1, color2, s, y, w, h, direction, alpha1, alpha2) {
  s = this.state;
  s.fillColor = color1;
  s.gradientFillAlpha = null != alpha1 ? alpha1 : 1;
  s.gradientColor = color2;
  s.gradientAlpha = null != alpha2 ? alpha2 : 1;
  s.gradientDirection = direction;
};
mxAbstractCanvas2D.prototype.setStrokeColor = function(value) {
  if (value == mxConstants.NONE) {
    value = null;
  }
  this.state.strokeColor = value;
};
mxAbstractCanvas2D.prototype.setStrokeWidth = function(value) {
  this.state.strokeWidth = value;
};
mxAbstractCanvas2D.prototype.setDashed = function(value, fixDash) {
  this.state.dashed = value;
  this.state.fixDash = fixDash;
};
mxAbstractCanvas2D.prototype.setDashPattern = function(value) {
  this.state.dashPattern = value;
};
mxAbstractCanvas2D.prototype.setLineCap = function(value) {
  this.state.lineCap = value;
};
mxAbstractCanvas2D.prototype.setLineJoin = function(value) {
  this.state.lineJoin = value;
};
mxAbstractCanvas2D.prototype.setMiterLimit = function(index) {
  this.state.miterLimit = index;
};
mxAbstractCanvas2D.prototype.setFontColor = function(value) {
  if (value == mxConstants.NONE) {
    value = null;
  }
  this.state.fontColor = value;
};
mxAbstractCanvas2D.prototype.setFontBackgroundColor = function(value) {
  if (value == mxConstants.NONE) {
    value = null;
  }
  this.state.fontBackgroundColor = value;
};
mxAbstractCanvas2D.prototype.setFontBorderColor = function(value) {
  if (value == mxConstants.NONE) {
    value = null;
  }
  this.state.fontBorderColor = value;
};
mxAbstractCanvas2D.prototype.setFontSize = function(value) {
  this.state.fontSize = parseFloat(value);
};
mxAbstractCanvas2D.prototype.setFontFamily = function(value) {
  this.state.fontFamily = value;
};
mxAbstractCanvas2D.prototype.setFontStyle = function(value) {
  if (null == value) {
    value = 0;
  }
  this.state.fontStyle = value;
};
mxAbstractCanvas2D.prototype.setShadow = function(layer) {
  this.state.shadow = layer;
};
mxAbstractCanvas2D.prototype.setShadowColor = function(value) {
  if (value == mxConstants.NONE) {
    value = null;
  }
  this.state.shadowColor = value;
};
mxAbstractCanvas2D.prototype.setShadowAlpha = function(value) {
  this.state.shadowAlpha = value;
};
mxAbstractCanvas2D.prototype.setShadowOffset = function(dx, dy) {
  this.state.shadowDx = dx;
  this.state.shadowDy = dy;
};
mxAbstractCanvas2D.prototype.begin = function() {
  this.lastY = this.lastX = 0;
  this.path = [];
};
mxAbstractCanvas2D.prototype.moveTo = function(value, y2) {
  this.addOp(this.moveOp, value, y2);
};
mxAbstractCanvas2D.prototype.lineTo = function(value, y2) {
  this.addOp(this.lineOp, value, y2);
};
mxAbstractCanvas2D.prototype.quadTo = function(value, y1, x2, y2) {
  this.addOp(this.quadOp, value, y1, x2, y2);
};
mxAbstractCanvas2D.prototype.curveTo = function(value, y1, w, y2, x3, x2) {
  this.addOp(this.curveOp, value, y1, w, y2, x3, x2);
};
mxAbstractCanvas2D.prototype.arcTo = function(curves, i, angle, largeArcFlag, sweepFlag, x, y) {
  curves = mxUtils.arcToCurves(this.lastX, this.lastY, curves, i, angle, largeArcFlag, sweepFlag, x, y);
  if (null != curves) {
    for (i = 0;i < curves.length;i += 6) {
      this.curveTo(curves[i], curves[i + 1], curves[i + 2], curves[i + 3], curves[i + 4], curves[i + 5]);
    }
  }
};
mxAbstractCanvas2D.prototype.close = function(x1, y2, x2, y1, x3, y3) {
  this.addOp(this.closeOp);
};
mxAbstractCanvas2D.prototype.end = function() {
};
function mxXmlCanvas2D(root) {
  mxAbstractCanvas2D.call(this);
  this.root = root;
  this.writeDefaults();
}
mxUtils.extend(mxXmlCanvas2D, mxAbstractCanvas2D);
mxXmlCanvas2D.prototype.textEnabled = true;
mxXmlCanvas2D.prototype.compressed = true;
mxXmlCanvas2D.prototype.writeDefaults = function() {
  var elem = this.createElement("fontfamily");
  elem.setAttribute("family", mxConstants.DEFAULT_FONTFAMILY);
  this.root.appendChild(elem);
  elem = this.createElement("fontsize");
  elem.setAttribute("size", mxConstants.DEFAULT_FONTSIZE);
  this.root.appendChild(elem);
  elem = this.createElement("shadowcolor");
  elem.setAttribute("color", mxConstants.SHADOWCOLOR);
  this.root.appendChild(elem);
  elem = this.createElement("shadowalpha");
  elem.setAttribute("alpha", mxConstants.SHADOW_OPACITY);
  this.root.appendChild(elem);
  elem = this.createElement("shadowoffset");
  elem.setAttribute("dx", mxConstants.SHADOW_OFFSET_X);
  elem.setAttribute("dy", mxConstants.SHADOW_OFFSET_Y);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.format = function(value) {
  return parseFloat(parseFloat(value).toFixed(2));
};
mxXmlCanvas2D.prototype.createElement = function(name) {
  return this.root.ownerDocument.createElement(name);
};
mxXmlCanvas2D.prototype.save = function() {
  if (this.compressed) {
    mxAbstractCanvas2D.prototype.save.apply(this, arguments);
  }
  this.root.appendChild(this.createElement("save"));
};
mxXmlCanvas2D.prototype.restore = function() {
  if (this.compressed) {
    mxAbstractCanvas2D.prototype.restore.apply(this, arguments);
  }
  this.root.appendChild(this.createElement("restore"));
};
mxXmlCanvas2D.prototype.scale = function(x) {
  var elem = this.createElement("scale");
  elem.setAttribute("scale", x);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.translate = function(x, y) {
  var elem = this.createElement("translate");
  elem.setAttribute("dx", this.format(x));
  elem.setAttribute("dy", this.format(y));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.rotate = function(cx, flipH, flipV, cy, value) {
  var elem = this.createElement("rotate");
  if (0 != cx || (flipH || flipV)) {
    elem.setAttribute("theta", this.format(cx));
    elem.setAttribute("flipH", flipH ? "1" : "0");
    elem.setAttribute("flipV", flipV ? "1" : "0");
    elem.setAttribute("cx", this.format(cy));
    elem.setAttribute("cy", this.format(value));
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setAlpha = function(value) {
  if (this.compressed) {
    if (this.state.alpha == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);
  }
  var elem = this.createElement("alpha");
  elem.setAttribute("alpha", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setFillAlpha = function(value) {
  if (this.compressed) {
    if (this.state.fillAlpha == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setFillAlpha.apply(this, arguments);
  }
  var elem = this.createElement("fillalpha");
  elem.setAttribute("alpha", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setStrokeAlpha = function(value) {
  if (this.compressed) {
    if (this.state.strokeAlpha == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeAlpha.apply(this, arguments);
  }
  var elem = this.createElement("strokealpha");
  elem.setAttribute("alpha", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setFillColor = function(value) {
  if (value == mxConstants.NONE) {
    value = null;
  }
  if (this.compressed) {
    if (this.state.fillColor == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setFillColor.apply(this, arguments);
  }
  var elem = this.createElement("fillcolor");
  elem.setAttribute("color", null != value ? value : mxConstants.NONE);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setGradient = function(src, str, x, y, h, value, dx, dy, w) {
  if (null != src && null != str) {
    mxAbstractCanvas2D.prototype.setGradient.apply(this, arguments);
    var elem = this.createElement("gradient");
    elem.setAttribute("c1", src);
    elem.setAttribute("c2", str);
    elem.setAttribute("x", this.format(x));
    elem.setAttribute("y", this.format(y));
    elem.setAttribute("w", this.format(h));
    elem.setAttribute("h", this.format(value));
    if (null != dx) {
      elem.setAttribute("direction", dx);
    }
    if (null != dy) {
      elem.setAttribute("alpha1", dy);
    }
    if (null != w) {
      elem.setAttribute("alpha2", w);
    }
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setStrokeColor = function(value) {
  if (value == mxConstants.NONE) {
    value = null;
  }
  if (this.compressed) {
    if (this.state.strokeColor == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeColor.apply(this, arguments);
  }
  var elem = this.createElement("strokecolor");
  elem.setAttribute("color", null != value ? value : mxConstants.NONE);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setStrokeWidth = function(value) {
  if (this.compressed) {
    if (this.state.strokeWidth == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setStrokeWidth.apply(this, arguments);
  }
  var elem = this.createElement("strokewidth");
  elem.setAttribute("width", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setDashed = function(value, fixDash) {
  if (this.compressed) {
    if (this.state.dashed == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setDashed.apply(this, arguments);
  }
  var elem = this.createElement("dashed");
  elem.setAttribute("dashed", value ? "1" : "0");
  if (null != fixDash) {
    elem.setAttribute("fixDash", fixDash ? "1" : "0");
  }
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setDashPattern = function(value) {
  if (this.compressed) {
    if (this.state.dashPattern == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setDashPattern.apply(this, arguments);
  }
  var elem = this.createElement("dashpattern");
  elem.setAttribute("pattern", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setLineCap = function(value) {
  if (this.compressed) {
    if (this.state.lineCap == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setLineCap.apply(this, arguments);
  }
  var elem = this.createElement("linecap");
  elem.setAttribute("cap", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setLineJoin = function(value) {
  if (this.compressed) {
    if (this.state.lineJoin == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setLineJoin.apply(this, arguments);
  }
  var elem = this.createElement("linejoin");
  elem.setAttribute("join", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setMiterLimit = function(value) {
  if (this.compressed) {
    if (this.state.miterLimit == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setMiterLimit.apply(this, arguments);
  }
  var elem = this.createElement("miterlimit");
  elem.setAttribute("limit", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setFontColor = function(value) {
  if (this.textEnabled) {
    if (value == mxConstants.NONE) {
      value = null;
    }
    if (this.compressed) {
      if (this.state.fontColor == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontColor.apply(this, arguments);
    }
    var elem = this.createElement("fontcolor");
    elem.setAttribute("color", null != value ? value : mxConstants.NONE);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontBackgroundColor = function(value) {
  if (this.textEnabled) {
    if (value == mxConstants.NONE) {
      value = null;
    }
    if (this.compressed) {
      if (this.state.fontBackgroundColor == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontBackgroundColor.apply(this, arguments);
    }
    var elem = this.createElement("fontbackgroundcolor");
    elem.setAttribute("color", null != value ? value : mxConstants.NONE);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontBorderColor = function(value) {
  if (this.textEnabled) {
    if (value == mxConstants.NONE) {
      value = null;
    }
    if (this.compressed) {
      if (this.state.fontBorderColor == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontBorderColor.apply(this, arguments);
    }
    var elem = this.createElement("fontbordercolor");
    elem.setAttribute("color", null != value ? value : mxConstants.NONE);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontSize = function(value) {
  if (this.textEnabled) {
    if (this.compressed) {
      if (this.state.fontSize == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontSize.apply(this, arguments);
    }
    var elem = this.createElement("fontsize");
    elem.setAttribute("size", value);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontFamily = function(value) {
  if (this.textEnabled) {
    if (this.compressed) {
      if (this.state.fontFamily == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontFamily.apply(this, arguments);
    }
    var elem = this.createElement("fontfamily");
    elem.setAttribute("family", value);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setFontStyle = function(value) {
  if (this.textEnabled) {
    if (null == value) {
      value = 0;
    }
    if (this.compressed) {
      if (this.state.fontStyle == value) {
        return;
      }
      mxAbstractCanvas2D.prototype.setFontStyle.apply(this, arguments);
    }
    var elem = this.createElement("fontstyle");
    elem.setAttribute("style", value);
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.setShadow = function(value) {
  if (this.compressed) {
    if (this.state.shadow == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadow.apply(this, arguments);
  }
  var elem = this.createElement("shadow");
  elem.setAttribute("enabled", value ? "1" : "0");
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setShadowColor = function(value) {
  if (this.compressed) {
    if (value == mxConstants.NONE) {
      value = null;
    }
    if (this.state.shadowColor == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowColor.apply(this, arguments);
  }
  var elem = this.createElement("shadowcolor");
  elem.setAttribute("color", null != value ? value : mxConstants.NONE);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setShadowAlpha = function(value) {
  if (this.compressed) {
    if (this.state.shadowAlpha == value) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowAlpha.apply(this, arguments);
  }
  var elem = this.createElement("shadowalpha");
  elem.setAttribute("alpha", value);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.setShadowOffset = function(dx, dy) {
  if (this.compressed) {
    if (this.state.shadowDx == dx && this.state.shadowDy == dy) {
      return;
    }
    mxAbstractCanvas2D.prototype.setShadowOffset.apply(this, arguments);
  }
  var elem = this.createElement("shadowoffset");
  elem.setAttribute("dx", dx);
  elem.setAttribute("dy", dy);
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.rect = function(x, y, w, h) {
  var elem = this.createElement("rect");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  elem.setAttribute("w", this.format(w));
  elem.setAttribute("h", this.format(h));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.roundrect = function(dx, y, w, h, dy, value) {
  var elem = this.createElement("roundrect");
  elem.setAttribute("x", this.format(dx));
  elem.setAttribute("y", this.format(y));
  elem.setAttribute("w", this.format(w));
  elem.setAttribute("h", this.format(h));
  elem.setAttribute("dx", this.format(dy));
  elem.setAttribute("dy", this.format(value));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.ellipse = function(x, y, w, h) {
  var elem = this.createElement("ellipse");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  elem.setAttribute("w", this.format(w));
  elem.setAttribute("h", this.format(h));
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.image = function(x, y, w, h, src, value, layer, connectingEdge) {
  src = this.converter.convert(src);
  var elem = this.createElement("image");
  elem.setAttribute("x", this.format(x));
  elem.setAttribute("y", this.format(y));
  elem.setAttribute("w", this.format(w));
  elem.setAttribute("h", this.format(h));
  elem.setAttribute("src", src);
  elem.setAttribute("aspect", value ? "1" : "0");
  elem.setAttribute("flipH", layer ? "1" : "0");
  elem.setAttribute("flipV", connectingEdge ? "1" : "0");
  this.root.appendChild(elem);
};
mxXmlCanvas2D.prototype.begin = function() {
  this.root.appendChild(this.createElement("begin"));
  this.lastY = this.lastX = 0;
};
mxXmlCanvas2D.prototype.moveTo = function(value, y2) {
  var elem = this.createElement("move");
  elem.setAttribute("x", this.format(value));
  elem.setAttribute("y", this.format(y2));
  this.root.appendChild(elem);
  this.lastX = value;
  this.lastY = y2;
};
mxXmlCanvas2D.prototype.lineTo = function(value, y2) {
  var elem = this.createElement("line");
  elem.setAttribute("x", this.format(value));
  elem.setAttribute("y", this.format(y2));
  this.root.appendChild(elem);
  this.lastX = value;
  this.lastY = y2;
};
mxXmlCanvas2D.prototype.quadTo = function(y1, x2, y2, value) {
  var elem = this.createElement("quad");
  elem.setAttribute("x1", this.format(y1));
  elem.setAttribute("y1", this.format(x2));
  elem.setAttribute("x2", this.format(y2));
  elem.setAttribute("y2", this.format(value));
  this.root.appendChild(elem);
  this.lastX = y2;
  this.lastY = value;
};
mxXmlCanvas2D.prototype.curveTo = function(w, y2, y1, value, x2, dy) {
  var elem = this.createElement("curve");
  elem.setAttribute("x1", this.format(w));
  elem.setAttribute("y1", this.format(y2));
  elem.setAttribute("x2", this.format(y1));
  elem.setAttribute("y2", this.format(value));
  elem.setAttribute("x3", this.format(x2));
  elem.setAttribute("y3", this.format(dy));
  this.root.appendChild(elem);
  this.lastX = x2;
  this.lastY = dy;
};
mxXmlCanvas2D.prototype.close = function() {
  this.root.appendChild(this.createElement("close"));
};
mxXmlCanvas2D.prototype.text = function(x, y, value, dx, str, src, w, clip, format, dy, wrap, h, dir) {
  if (this.textEnabled && null != str) {
    if (mxUtils.isNode(str)) {
      str = mxUtils.getOuterHtml(str);
    }
    var elem = this.createElement("text");
    elem.setAttribute("x", this.format(x));
    elem.setAttribute("y", this.format(y));
    elem.setAttribute("w", this.format(value));
    elem.setAttribute("h", this.format(dx));
    elem.setAttribute("str", str);
    if (null != src) {
      elem.setAttribute("align", src);
    }
    if (null != w) {
      elem.setAttribute("valign", w);
    }
    elem.setAttribute("wrap", clip ? "1" : "0");
    if (null == format) {
      format = "";
    }
    elem.setAttribute("format", format);
    if (null != dy) {
      elem.setAttribute("overflow", dy);
    }
    if (null != wrap) {
      elem.setAttribute("clip", wrap ? "1" : "0");
    }
    if (null != h) {
      elem.setAttribute("rotation", h);
    }
    if (null != dir) {
      elem.setAttribute("dir", dir);
    }
    this.root.appendChild(elem);
  }
};
mxXmlCanvas2D.prototype.stroke = function() {
  this.root.appendChild(this.createElement("stroke"));
};
mxXmlCanvas2D.prototype.fill = function() {
  this.root.appendChild(this.createElement("fill"));
};
mxXmlCanvas2D.prototype.fillAndStroke = function() {
  this.root.appendChild(this.createElement("fillstroke"));
};
function mxSvgCanvas2D(node, svg) {
  mxAbstractCanvas2D.call(this);
  this.root = node;
  this.gradients = [];
  this.fillPatterns = [];
  this.defs = null;
  this.styleEnabled = null != svg ? svg : false;
  svg = null;
  if (node.ownerDocument != document) {
    for (;null != node && "svg" != node.nodeName;) {
      node = node.parentNode;
    }
    svg = node;
  }
  if (null != svg) {
    if (0 < svg.getElementsByTagName("defs").length) {
      this.defs = svg.getElementsByTagName("defs")[0];
    }
    if (null == this.defs) {
      this.defs = this.createElement("defs");
      if (null != svg.firstChild) {
        svg.insertBefore(this.defs, svg.firstChild);
      } else {
        svg.appendChild(this.defs);
      }
    }
    if (this.styleEnabled) {
      this.defs.appendChild(this.createStyle());
    }
  }
}
mxUtils.extend(mxSvgCanvas2D, mxAbstractCanvas2D);
(function() {
  mxSvgCanvas2D.prototype.useDomParser = !mxClient.IS_IE && ("function" === typeof DOMParser && "function" === typeof XMLSerializer);
  if (mxSvgCanvas2D.prototype.useDomParser) {
    try {
      var doc = (new DOMParser).parseFromString("test text", "text/html");
      mxSvgCanvas2D.prototype.useDomParser = null != doc;
    } catch (b) {
      mxSvgCanvas2D.prototype.useDomParser = false;
    }
  }
  mxSvgCanvas2D.prototype.useAbsoluteIds = !mxClient.IS_CHROMEAPP && (!mxClient.IS_IE && (!mxClient.IS_IE11 && (!mxClient.IS_EDGE && 0 < document.getElementsByTagName("base").length)));
})();
mxSvgCanvas2D.prototype.node = null;
mxSvgCanvas2D.prototype.matchHtmlAlignment = true;
mxSvgCanvas2D.prototype.textEnabled = true;
mxSvgCanvas2D.prototype.foEnabled = true;
mxSvgCanvas2D.prototype.foAltText = "[Object]";
mxSvgCanvas2D.prototype.foOffset = 0;
mxSvgCanvas2D.prototype.textOffset = 0;
mxSvgCanvas2D.prototype.imageOffset = 0;
mxSvgCanvas2D.prototype.strokeTolerance = 0;
mxSvgCanvas2D.prototype.minStrokeWidth = 1;
mxSvgCanvas2D.prototype.refCount = 0;
mxSvgCanvas2D.prototype.lineHeightCorrection = 1;
mxSvgCanvas2D.prototype.pointerEventsValue = "all";
mxSvgCanvas2D.prototype.fontMetricsPadding = 10;
mxSvgCanvas2D.prototype.foreignObjectPadding = 2;
mxSvgCanvas2D.prototype.cacheOffsetSize = true;
mxSvgCanvas2D.prototype.setCssText = function(fo, value) {
  if (mxClient.IS_IE || mxClient.IS_IE11) {
    fo.setAttribute("style", value);
  } else {
    mxUtils.setCssText(fo.style, value);
  }
};
mxSvgCanvas2D.prototype.format = function(value) {
  return parseFloat(parseFloat(value).toFixed(2));
};
mxSvgCanvas2D.prototype.getBaseUrl = function() {
  var href = window.location.href;
  var hash = href.lastIndexOf("#");
  if (0 < hash) {
    href = href.substring(0, hash);
  }
  return href;
};
mxSvgCanvas2D.prototype.reset = function() {
  mxAbstractCanvas2D.prototype.reset.apply(this, arguments);
  this.gradients = [];
  this.fillPatterns = [];
};
mxSvgCanvas2D.prototype.createStyle = function(style) {
  style = this.createElement("style");
  style.setAttribute("type", "text/css");
  mxUtils.write(style, "svg{font-family:" + mxConstants.DEFAULT_FONTFAMILY + ";font-size:" + mxConstants.DEFAULT_FONTSIZE + ";fill:none;stroke-miterlimit:10}");
  return style;
};
mxSvgCanvas2D.prototype.createElement = function(name, namespace) {
  if (null != this.root.ownerDocument.createElementNS) {
    return this.root.ownerDocument.createElementNS(namespace || mxConstants.NS_SVG, name);
  }
  name = this.root.ownerDocument.createElement(name);
  if (null != namespace) {
    name.setAttribute("xmlns", namespace);
  }
  return name;
};
mxSvgCanvas2D.prototype.getAlternateText = function(fo, x, y, state, h, str, align, valign, wrap, format, overflow, clip, rotation) {
  return null != str ? this.foAltText : null;
};
mxSvgCanvas2D.prototype.createAlternateContent = function(fo, x, y, s, h, str, alt, valign, wrap, format, overflow, clip, rotation) {
  fo = this.getAlternateText(fo, x, y, s, h, str, alt, valign, wrap, format, overflow, clip, rotation);
  s = this.state;
  return null != fo && 0 < s.fontSize ? (valign = valign == mxConstants.ALIGN_TOP ? 1 : valign == mxConstants.ALIGN_BOTTOM ? 0 : 0.3, h = alt == mxConstants.ALIGN_RIGHT ? "end" : alt == mxConstants.ALIGN_LEFT ? "start" : "middle", alt = this.createElement("text"), alt.setAttribute("x", Math.round(x + s.dx)), alt.setAttribute("y", Math.round(y + s.dy + valign * s.fontSize)), alt.setAttribute("fill", s.fontColor || "black"), alt.setAttribute("font-family", s.fontFamily), alt.setAttribute("font-size",
  Math.round(s.fontSize) + "px"), "start" != h && alt.setAttribute("text-anchor", h), (s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && alt.setAttribute("font-weight", "bold"), (s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && alt.setAttribute("font-style", "italic"), x = [], (s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && x.push("underline"), (s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && x.push("line-through"),
  0 < x.length && alt.setAttribute("text-decoration", x.join(" ")), mxUtils.write(alt, fo), alt) : null;
};
mxSvgCanvas2D.prototype.createGradientId = function(start, end, alpha1, alpha2, direction) {
  start = mxUtils.rgba2hex(start);
  if ("#" == start.charAt(0)) {
    start = start.substring(1);
  }
  end = mxUtils.rgba2hex(end);
  if ("#" == end.charAt(0)) {
    end = end.substring(1);
  }
  start = start.toLowerCase() + "-" + alpha1;
  end = end.toLowerCase() + "-" + alpha2;
  alpha1 = null;
  if (null == direction || direction == mxConstants.DIRECTION_SOUTH) {
    alpha1 = "s";
  } else {
    if (direction == mxConstants.DIRECTION_EAST) {
      alpha1 = "e";
    } else {
      if (direction == mxConstants.DIRECTION_RADIAL) {
        alpha1 = "r";
      } else {
        alpha2 = start;
        start = end;
        end = alpha2;
        if (direction == mxConstants.DIRECTION_NORTH) {
          alpha1 = "s";
        } else {
          if (direction == mxConstants.DIRECTION_WEST) {
            alpha1 = "e";
          }
        }
      }
    }
  }
  return "mx-gradient-" + start + "-" + end + "-" + alpha1;
};
mxSvgCanvas2D.prototype.getSvgGradient = function(start, end, alpha1, alpha2, direction) {
  var id = this.createGradientId(start, end, alpha1, alpha2, direction);
  var gradient = this.gradients[id];
  if (null == gradient) {
    var svg = this.root.ownerSVGElement;
    var counter = 0;
    var tmpId = id + "-" + counter;
    if (null != svg) {
      for (gradient = svg.ownerDocument.getElementById(tmpId);null != gradient && gradient.ownerSVGElement != svg;) {
        tmpId = id + "-" + counter++;
        gradient = svg.ownerDocument.getElementById(tmpId);
      }
    } else {
      tmpId = "id" + ++this.refCount;
    }
    if (null == gradient) {
      gradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);
      gradient.setAttribute("id", tmpId);
      if (null != this.defs) {
        this.defs.appendChild(gradient);
      } else {
        svg.appendChild(gradient);
      }
    }
    this.gradients[id] = gradient;
  }
  return gradient.getAttribute("id");
};
mxSvgCanvas2D.prototype.createSvgGradient = function(start, end, alpha1, alpha2, direction) {
  var gradient = this.createElement(direction == mxConstants.DIRECTION_RADIAL ? "radialGradient" : "linearGradient");
  gradient.setAttribute("x1", "0%");
  gradient.setAttribute("y1", "0%");
  gradient.setAttribute("x2", "0%");
  gradient.setAttribute("y2", "0%");
  if (null == direction || direction == mxConstants.DIRECTION_SOUTH) {
    gradient.setAttribute("y2", "100%");
  } else {
    if (direction == mxConstants.DIRECTION_EAST) {
      gradient.setAttribute("x2", "100%");
    } else {
      if (direction == mxConstants.DIRECTION_NORTH) {
        gradient.setAttribute("y1", "100%");
      } else {
        if (direction == mxConstants.DIRECTION_WEST) {
          gradient.setAttribute("x1", "100%");
        }
      }
    }
  }
  direction = this.createElement("stop");
  direction.setAttribute("offset", "0%");
  direction.style.stopColor = start;
  direction.style.stopOpacity = alpha1;
  gradient.appendChild(direction);
  direction = this.createElement("stop");
  direction.setAttribute("offset", "100%");
  direction.style.stopColor = end;
  direction.style.stopOpacity = alpha2;
  gradient.appendChild(direction);
  return gradient;
};
mxSvgCanvas2D.prototype.createFillPatternId = function(willCollapse, y, str) {
  str = mxUtils.rgba2hex(str);
  if ("#" == str.charAt(0)) {
    str = str.substring(1);
  }
  return("mx-pattern-" + willCollapse + "-" + y + "-" + str).toLowerCase();
};
mxSvgCanvas2D.prototype.getFillPattern = function(willCollapse, y, str, value) {
  var id = this.createFillPatternId(willCollapse, y, str);
  var gradient = this.fillPatterns[id];
  if (null == gradient) {
    var svg = this.root.ownerSVGElement;
    var counter = 0;
    var tmpId = id + "-" + counter;
    if (null != svg) {
      for (gradient = svg.ownerDocument.getElementById(tmpId);null != gradient && gradient.ownerSVGElement != svg;) {
        tmpId = id + "-" + counter++;
        gradient = svg.ownerDocument.getElementById(tmpId);
      }
    } else {
      tmpId = "id" + ++this.refCount;
    }
    if (null == gradient) {
      switch(willCollapse) {
        case "hatch":
          gradient = this.createHatchPattern(y, str, value);
          break;
        case "dots":
          gradient = this.createDotsPattern(y, str, value);
          break;
        case "cross-hatch":
          gradient = this.createCrossHatchPattern(y, str, value);
          break;
        case "dashed":
          gradient = this.createDashedPattern(y, str, value);
          break;
        case "zigzag":
        ;
        case "zigzag-line":
          gradient = this.createZigZagLinePattern(y, str, value);
          break;
        default:
          return "ERROR";
      }
      gradient.setAttribute("id", tmpId);
      if (null != this.defs) {
        this.defs.appendChild(gradient);
      } else {
        svg.appendChild(gradient);
      }
    }
    this.fillPatterns[id] = gradient;
  }
  return gradient.getAttribute("id");
};
mxSvgCanvas2D.prototype.createHatchPattern = function(y, str, value) {
  y = 1.5 * y * value;
  value = this.format((10 + y) * value);
  var n = this.createElement("pattern");
  n.setAttribute("patternUnits", "userSpaceOnUse");
  n.setAttribute("width", value);
  n.setAttribute("height", value);
  n.setAttribute("x", "0");
  n.setAttribute("y", "0");
  n.setAttribute("patternTransform", "rotate(45)");
  var elem = this.createElement("line");
  elem.setAttribute("x1", "0");
  elem.setAttribute("y1", "0");
  elem.setAttribute("x2", "0");
  elem.setAttribute("y2", value);
  elem.setAttribute("stroke", str);
  elem.setAttribute("stroke-width", y);
  n.appendChild(elem);
  return n;
};
mxSvgCanvas2D.prototype.createDashedPattern = function(y, str, value) {
  y = 1.5 * y * value;
  value = this.format((10 + y) * value);
  var n = this.createElement("pattern");
  n.setAttribute("patternUnits", "userSpaceOnUse");
  n.setAttribute("width", value);
  n.setAttribute("height", value);
  n.setAttribute("x", "0");
  n.setAttribute("y", "0");
  n.setAttribute("patternTransform", "rotate(45)");
  var elem = this.createElement("line");
  elem.setAttribute("x1", "0");
  elem.setAttribute("y1", value / 4);
  elem.setAttribute("x2", "0");
  elem.setAttribute("y2", 3 * value / 4);
  elem.setAttribute("stroke", str);
  elem.setAttribute("stroke-width", y);
  n.appendChild(elem);
  return n;
};
mxSvgCanvas2D.prototype.createZigZagLinePattern = function(y, str, value) {
  y = 1.5 * y * value;
  value = this.format((10 + y) * value);
  var n = this.createElement("pattern");
  n.setAttribute("patternUnits", "userSpaceOnUse");
  n.setAttribute("width", value);
  n.setAttribute("height", value);
  n.setAttribute("x", "0");
  n.setAttribute("y", "0");
  n.setAttribute("patternTransform", "rotate(45)");
  var rect = this.createElement("path");
  var f = value / 4;
  var g = 3 * value / 4;
  rect.setAttribute("d", "M " + f + " 0 L " + g + " 0 L " + f + " " + value + " L " + g + " " + value);
  rect.setAttribute("stroke", str);
  rect.setAttribute("stroke-width", y);
  rect.setAttribute("fill", "none");
  n.appendChild(rect);
  return n;
};
mxSvgCanvas2D.prototype.createCrossHatchPattern = function(y, str, value) {
  y = 0.5 * y * value;
  value = this.format(1.5 * (10 + y) * value);
  var n = this.createElement("pattern");
  n.setAttribute("patternUnits", "userSpaceOnUse");
  n.setAttribute("width", value);
  n.setAttribute("height", value);
  n.setAttribute("x", "0");
  n.setAttribute("y", "0");
  n.setAttribute("patternTransform", "rotate(45)");
  var rect = this.createElement("rect");
  rect.setAttribute("x", 0);
  rect.setAttribute("y", 0);
  rect.setAttribute("width", value);
  rect.setAttribute("height", value);
  rect.setAttribute("stroke", str);
  rect.setAttribute("stroke-width", y);
  rect.setAttribute("fill", "none");
  n.appendChild(rect);
  return n;
};
mxSvgCanvas2D.prototype.createDotsPattern = function(y, str, rect) {
  y = this.format((10 + y) * rect);
  rect = this.createElement("pattern");
  rect.setAttribute("patternUnits", "userSpaceOnUse");
  rect.setAttribute("width", y);
  rect.setAttribute("height", y);
  rect.setAttribute("x", "0");
  rect.setAttribute("y", "0");
  var n = this.createElement("circle");
  n.setAttribute("cx", y / 2);
  n.setAttribute("cy", y / 2);
  n.setAttribute("r", y / 4);
  n.setAttribute("stroke", "none");
  n.setAttribute("fill", str);
  rect.appendChild(n);
  return rect;
};
mxSvgCanvas2D.prototype.addNode = function(filled, stroked) {
  var node = this.node;
  var s = this.state;
  if (null != node) {
    if ("path" == node.nodeName) {
      if (null != this.path && 0 < this.path.length) {
        node.setAttribute("d", this.path.join(" "));
      } else {
        return;
      }
    }
    if (filled && null != s.fillColor) {
      this.updateFill();
    } else {
      if (!this.styleEnabled) {
        if ("ellipse" == node.nodeName && mxClient.IS_FF) {
          node.setAttribute("fill", "transparent");
        } else {
          node.setAttribute("fill", "none");
        }
        filled = false;
      }
    }
    if (stroked && null != s.strokeColor) {
      this.updateStroke();
    } else {
      if (!this.styleEnabled) {
        node.setAttribute("stroke", "none");
      }
    }
    if (null != s.transform) {
      if (0 < s.transform.length) {
        node.setAttribute("transform", s.transform);
      }
    }
    if (this.pointerEvents) {
      node.setAttribute("pointer-events", this.pointerEventsValue);
    } else {
      if (!this.pointerEvents) {
        if (!(null != this.originalRoot)) {
          node.setAttribute("pointer-events", "none");
        }
      }
    }
    if (s.shadow) {
      this.root.appendChild(this.createShadow(node));
    }
    if (0 < this.strokeTolerance) {
      if (!filled || null == s.fillColor) {
        this.addTolerance(node);
      }
    }
    if ("rect" != node.nodeName && ("path" != node.nodeName && "ellipse" != node.nodeName) || ("none" != node.getAttribute("fill") && "transparent" != node.getAttribute("fill") || ("none" != node.getAttribute("stroke") || "none" != node.getAttribute("pointer-events")))) {
      this.root.appendChild(node);
    }
    this.node = null;
  }
};
mxSvgCanvas2D.prototype.addTolerance = function(node) {
  this.root.appendChild(this.createTolerance(node));
};
mxSvgCanvas2D.prototype.updateFill = function() {
  var s = this.state;
  if (1 > s.alpha || 1 > s.fillAlpha) {
    this.node.setAttribute("fill-opacity", s.alpha * s.fillAlpha);
  }
  var b = false;
  if (null != s.fillColor) {
    if (null != s.gradientColor && s.gradientColor != mxConstants.NONE) {
      b = true;
      var id = this.getSvgGradient(String(s.fillColor), String(s.gradientColor), s.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);
      if (this.root.ownerDocument == document && this.useAbsoluteIds) {
        var value = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
        value = "url(" + value + "#" + id + ")";
      } else {
        value = "url(#" + id + ")";
      }
    } else {
      value = String(s.fillColor).toLowerCase();
    }
  }
  if (b || (null == s.fillStyle || ("auto" == s.fillStyle || "solid" == s.fillStyle))) {
    this.node.setAttribute("fill", value);
  } else {
    s = this.getFillPattern(s.fillStyle, this.getCurrentStrokeWidth(), value, s.scale);
    if (this.root.ownerDocument == document && this.useAbsoluteIds) {
      value = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
      this.node.setAttribute("fill", "url(" + value + "#" + s + ")");
    } else {
      this.node.setAttribute("fill", "url(#" + s + ")");
    }
  }
};
mxSvgCanvas2D.prototype.getCurrentStrokeWidth = function() {
  return Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));
};
mxSvgCanvas2D.prototype.updateStroke = function() {
  var s = this.state;
  this.node.setAttribute("stroke", String(s.strokeColor).toLowerCase());
  if (1 > s.alpha || 1 > s.strokeAlpha) {
    this.node.setAttribute("stroke-opacity", s.alpha * s.strokeAlpha);
  }
  var value = this.getCurrentStrokeWidth();
  if (1 != value) {
    this.node.setAttribute("stroke-width", value);
  }
  if ("path" == this.node.nodeName) {
    this.updateStrokeAttributes();
  }
  if (s.dashed) {
    this.node.setAttribute("stroke-dasharray", this.createDashPattern((s.fixDash ? 1 : s.strokeWidth) * s.scale));
  }
};
mxSvgCanvas2D.prototype.updateStrokeAttributes = function() {
  var s = this.state;
  if (null != s.lineJoin) {
    if ("miter" != s.lineJoin) {
      this.node.setAttribute("stroke-linejoin", s.lineJoin);
    }
  }
  if (null != s.lineCap) {
    var value = s.lineCap;
    if ("flat" == value) {
      value = "butt";
    }
    if ("butt" != value) {
      this.node.setAttribute("stroke-linecap", value);
    }
  }
  if (!(null == s.miterLimit)) {
    if (!(this.styleEnabled && 10 == s.miterLimit)) {
      this.node.setAttribute("stroke-miterlimit", s.miterLimit);
    }
  }
};
mxSvgCanvas2D.prototype.createDashPattern = function(scale) {
  var pat = [];
  if ("string" === typeof this.state.dashPattern) {
    var dash = this.state.dashPattern.split(" ");
    if (0 < dash.length) {
      for (var i = 0;i < dash.length;i++) {
        pat[i] = Number(dash[i]) * scale;
      }
    }
  }
  return pat.join(" ");
};
mxSvgCanvas2D.prototype.createTolerance = function(node) {
  node = node.cloneNode(true);
  var value = parseFloat(node.getAttribute("stroke-width") || 1) + this.strokeTolerance;
  node.setAttribute("pointer-events", "stroke");
  node.setAttribute("visibility", "hidden");
  node.removeAttribute("stroke-dasharray");
  node.setAttribute("stroke-width", value);
  node.setAttribute("fill", "none");
  node.setAttribute("stroke", mxClient.IS_OT ? "none" : "white");
  return node;
};
mxSvgCanvas2D.prototype.createShadow = function(shadow) {
  shadow = shadow.cloneNode(true);
  var s = this.state;
  if (!("none" == shadow.getAttribute("fill"))) {
    if (!(mxClient.IS_FF && "transparent" == shadow.getAttribute("fill"))) {
      shadow.setAttribute("fill", s.shadowColor);
    }
  }
  if ("none" != shadow.getAttribute("stroke")) {
    shadow.setAttribute("stroke", s.shadowColor);
  }
  shadow.setAttribute("transform", "translate(" + this.format(s.shadowDx * s.scale) + "," + this.format(s.shadowDy * s.scale) + ")" + (s.transform || ""));
  shadow.setAttribute("opacity", s.shadowAlpha);
  return shadow;
};
mxSvgCanvas2D.prototype.setLink = function(link, value) {
  if (null == link) {
    this.root = this.originalRoot;
  } else {
    this.originalRoot = this.root;
    var node = this.createElement("a");
    if (null == node.setAttributeNS || this.root.ownerDocument != document && null == document.documentMode) {
      node.setAttribute("xlink:href", link);
    } else {
      node.setAttributeNS(mxConstants.NS_XLINK, "xlink:href", link);
    }
    if (null != value) {
      node.setAttribute("target", value);
    }
    this.root.appendChild(node);
    this.root = node;
  }
};
mxSvgCanvas2D.prototype.rotate = function(value, flipH, flipV, cx, cy) {
  if (0 != value || (flipH || flipV)) {
    var s = this.state;
    cx += s.dx;
    cy += s.dy;
    cx *= s.scale;
    cy *= s.scale;
    s.transform = s.transform || "";
    if (flipH && flipV) {
      value += 180;
    } else {
      if (flipH != flipV) {
        var tx = flipH ? cx : 0;
        var sx = flipH ? -1 : 1;
        var ty = flipV ? cy : 0;
        var sy = flipV ? -1 : 1;
        s.transform += "translate(" + this.format(tx) + "," + this.format(ty) + ")scale(" + this.format(sx) + "," + this.format(sy) + ")translate(" + this.format(-tx) + "," + this.format(-ty) + ")";
      }
    }
    if (flipH ? !flipV : flipV) {
      value *= -1;
    }
    if (0 != value) {
      s.transform += "rotate(" + this.format(value) + "," + this.format(cx) + "," + this.format(cy) + ")";
    }
    s.rotation += value;
    s.rotationCx = cx;
    s.rotationCy = cy;
  }
};
mxSvgCanvas2D.prototype.begin = function() {
  mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
  this.node = this.createElement("path");
};
mxSvgCanvas2D.prototype.rect = function(x, y, w, h) {
  var s = this.state;
  var n = this.createElement("rect");
  n.setAttribute("x", this.format((x + s.dx) * s.scale));
  n.setAttribute("y", this.format((y + s.dy) * s.scale));
  n.setAttribute("width", this.format(w * s.scale));
  n.setAttribute("height", this.format(h * s.scale));
  this.node = n;
};
mxSvgCanvas2D.prototype.roundrect = function(x, y, w, h, dx, dy) {
  this.rect(x, y, w, h);
  if (0 < dx) {
    this.node.setAttribute("rx", this.format(dx * this.state.scale));
  }
  if (0 < dy) {
    this.node.setAttribute("ry", this.format(dy * this.state.scale));
  }
};
mxSvgCanvas2D.prototype.ellipse = function(x, y, w, h) {
  var s = this.state;
  var n = this.createElement("ellipse");
  n.setAttribute("cx", this.format((x + w / 2 + s.dx) * s.scale));
  n.setAttribute("cy", this.format((y + h / 2 + s.dy) * s.scale));
  n.setAttribute("rx", w / 2 * s.scale);
  n.setAttribute("ry", h / 2 * s.scale);
  this.node = n;
};
mxSvgCanvas2D.prototype.image = function(x, y, w, h, src, layer, connectingEdge, isConnect, color) {
  src = this.converter.convert(src);
  layer = null != layer ? layer : true;
  connectingEdge = null != connectingEdge ? connectingEdge : false;
  isConnect = null != isConnect ? isConnect : false;
  var s = this.state;
  x += s.dx;
  y += s.dy;
  var node = this.createElement("image");
  node.setAttribute("x", this.format(x * s.scale) + this.imageOffset);
  node.setAttribute("y", this.format(y * s.scale) + this.imageOffset);
  node.setAttribute("width", this.format(w * s.scale));
  node.setAttribute("height", this.format(h * s.scale));
  if (null == node.setAttributeNS) {
    node.setAttribute("xlink:href", src);
  } else {
    node.setAttributeNS(mxConstants.NS_XLINK, "xlink:href", src);
  }
  if (!layer) {
    node.setAttribute("preserveAspectRatio", "none");
  }
  if (1 > s.alpha || 1 > s.fillAlpha) {
    node.setAttribute("opacity", s.alpha * s.fillAlpha);
  }
  src = this.state.transform || "";
  if (connectingEdge || isConnect) {
    var p = layer = 1;
    var dy = 0;
    var dx = 0;
    if (connectingEdge) {
      layer = -1;
      dy = -w - 2 * x;
    }
    if (isConnect) {
      p = -1;
      dx = -h - 2 * y;
    }
    src += "scale(" + layer + "," + p + ")translate(" + dy * s.scale + "," + dx * s.scale + ")";
  }
  if (0 < src.length) {
    node.setAttribute("transform", src);
  }
  if (!this.pointerEvents) {
    node.setAttribute("pointer-events", "none");
  }
  if (null != color) {
    this.processClipPath(node, color, new mxRectangle(x, y, w, h));
  }
  this.root.appendChild(node);
};
mxSvgCanvas2D.prototype.processClipPath = function(node, y, size) {
  try {
    var child = this.createElement("clipPath");
    child.setAttribute("id", this.createClipPathId(y));
    child.setAttribute("clipPathUnits", "objectBoundingBox");
    var bounds = this.appendClipPath(child, y, size);
    if (null != bounds) {
      var pgeo = this.state;
      node.setAttribute("x", size.x * pgeo.scale - size.width * pgeo.scale * bounds.x / bounds.width + this.imageOffset);
      node.setAttribute("y", size.y * pgeo.scale - size.height * pgeo.scale * bounds.y / bounds.height + this.imageOffset);
      node.setAttribute("width", size.width * pgeo.scale / bounds.width);
      node.setAttribute("height", size.height * pgeo.scale / bounds.height);
    }
    this.setClip(node, child);
  } catch (g) {
  }
};
mxSvgCanvas2D.prototype.convertHtml = function(val) {
  if (this.useDomParser) {
    var doc = (new DOMParser).parseFromString(val, "text/html");
    if (null != doc) {
      val = (new XMLSerializer).serializeToString(doc.body);
      if ("<body" == val.substring(0, 5)) {
        val = val.substring(val.indexOf(">", 5) + 1);
      }
      if ("</body>" == val.substring(val.length - 7, val.length)) {
        val = val.substring(0, val.length - 7);
      }
    }
  } else {
    if (null != document.implementation && null != document.implementation.createDocument) {
      doc = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", null);
      var xb = doc.createElement("body");
      doc.documentElement.appendChild(xb);
      var div = document.createElement("div");
      div.innerHTML = val;
      for (val = div.firstChild;null != val;) {
        div = val.nextSibling;
        xb.appendChild(doc.adoptNode(val));
        val = div;
      }
      return xb.innerHTML;
    }
    doc = document.createElement("textarea");
    doc.innerHTML = val.replace(/&amp;/g, "&amp;amp;").replace(/&#60;/g, "&amp;lt;").replace(/&#62;/g, "&amp;gt;").replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    val = doc.value.replace(/&/g, "&amp;").replace(/&amp;lt;/g, "&lt;").replace(/&amp;gt;/g, "&gt;").replace(/&amp;amp;/g, "&amp;").replace(/<br>/g, "<br />").replace(/<hr>/g, "<hr />").replace(/(<img[^>]+)>/gm, "$1 />");
  }
  return val;
};
mxSvgCanvas2D.prototype.createDiv = function(val) {
  if (!mxUtils.isNode(val)) {
    val = "<div><div>" + this.convertHtml(val) + "</div></div>";
  }
  if (mxClient.IS_IE || (mxClient.IS_IE11 || !document.createElementNS)) {
    return mxUtils.isNode(val) && (val = "<div><div>" + mxUtils.getXml(val) + "</div></div>"), mxUtils.parseXml('<div xmlns="http://www.w3.org/1999/xhtml">' + val + "</div>").documentElement;
  }
  var div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
  if (mxUtils.isNode(val)) {
    var div2 = document.createElement("div");
    var div3 = div2.cloneNode(false);
    if (this.root.ownerDocument != document) {
      div2.appendChild(val.cloneNode(true));
    } else {
      div2.appendChild(val);
    }
    div3.appendChild(div2);
    div.appendChild(div3);
  } else {
    div.innerHTML = val;
  }
  return div;
};
mxSvgCanvas2D.prototype.updateText = function(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node) {
  if (null != node) {
    if (null != node.firstChild) {
      if (null != node.firstChild.firstChild) {
        this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node.firstChild);
      }
    }
  }
};
mxSvgCanvas2D.prototype.addForeignObject = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, group, div, root) {
  group = this.createElement("g");
  var fo = this.createElement("foreignObject");
  this.setCssText(fo, "overflow: visible; text-align: left;");
  fo.setAttribute("data-moonspeak-locked", "test-data");
  fo.setAttribute("pointer-events", "none");
  if (div.ownerDocument != document) {
    div = mxUtils.importNodeImplementation(fo.ownerDocument, div, true);
  }
  fo.appendChild(div);
  group.appendChild(fo);
  this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, group);
  if (this.root.ownerDocument != document) {
    x = this.createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);
    if (null != x) {
      fo.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility");
      y = this.createElement("switch");
      y.appendChild(fo);
      y.appendChild(x);
      group.appendChild(y);
    }
  }
  root.appendChild(group);
};
mxSvgCanvas2D.prototype.updateTextNodes = function(x, y, w, h, align, valign, wrap, overflow, clip, rotation, g) {
  var s = this.state.scale;
  mxSvgCanvas2D.createCss(w + this.foreignObjectPadding, h, align, valign, wrap, overflow, clip, null != this.state.fontBackgroundColor ? this.state.fontBackgroundColor : null, null != this.state.fontBorderColor ? this.state.fontBorderColor : null, "display: flex; align-items: unsafe " + (valign == mxConstants.ALIGN_TOP ? "flex-start" : valign == mxConstants.ALIGN_BOTTOM ? "flex-end" : "center") + "; justify-content: unsafe " + (align == mxConstants.ALIGN_LEFT ? "flex-start" : align == mxConstants.ALIGN_RIGHT ?
  "flex-end" : "center") + "; ", this.getTextCss(), s, mxUtils.bind(this, function(dx, dy, flex, enabled, connectable) {
    x += this.state.dx;
    y += this.state.dy;
    var fo = g.firstChild;
    var div = fo.firstChild;
    var box = div.firstChild;
    var B = (this.rotateHtml ? this.state.rotation : 0) + (null != rotation ? rotation : 0);
    var value = (0 != this.foOffset ? "translate(" + this.foOffset + " " + this.foOffset + ")" : "") + (1 != s ? "scale(" + s + ")" : "");
    this.setCssText(box.firstChild, connectable);
    this.setCssText(box, enabled);
    box.setAttribute("data-drawio-colors", "color: " + this.state.fontColor + "; " + (null == this.state.fontBackgroundColor ? "" : "background-color: " + this.state.fontBackgroundColor + "; ") + (null == this.state.fontBorderColor ? "" : "border-color: " + this.state.fontBorderColor + "; "));
    fo.setAttribute("width", Math.ceil(1 / Math.min(1, s) * 100) + "%");
    fo.setAttribute("height", Math.ceil(1 / Math.min(1, s) * 100) + "%");
    dy = Math.round(y + dy);
    if (0 > dy) {
      fo.setAttribute("y", dy);
    } else {
      fo.removeAttribute("y");
      flex += "padding-top: " + dy + "px; ";
    }
    this.setCssText(div, flex + "margin-left: " + Math.round(x + dx) + "px;");
    value += 0 != B ? "rotate(" + B + " " + x + " " + y + ")" : "";
    if ("" != value) {
      g.setAttribute("transform", value);
    } else {
      g.removeAttribute("transform");
    }
    if (1 != this.state.alpha) {
      g.setAttribute("opacity", this.state.alpha);
    } else {
      g.removeAttribute("opacity");
    }
  }));
};
mxSvgCanvas2D.createCss = function(x, h, align, valign, w, overflow, clip, bg, flex, wrap, border, s, callback) {
  s = "box-sizing: border-box; font-size: 0; text-align: " + (align == mxConstants.ALIGN_LEFT ? "left" : align == mxConstants.ALIGN_RIGHT ? "right" : "center") + "; ";
  var pt = mxUtils.getAlignmentAsPoint(align, valign);
  align = "overflow: hidden; ";
  var fw = "width: 1px; ";
  var fh = "height: 1px; ";
  var dx = pt.x * x;
  pt = pt.y * h;
  if (clip) {
    fw = "width: " + Math.round(x) + "px; ";
    s += "max-height: " + Math.round(h) + "px; ";
    pt = 0;
  } else {
    if ("fill" == overflow) {
      fw = "width: " + Math.round(x) + "px; ";
      fh = "height: " + Math.round(h) + "px; ";
      border += "width: 100%; height: 100%; ";
      s += "width: " + Math.round(x - 2) + "px; " + fh;
    } else {
      if ("width" == overflow) {
        fw = "width: " + Math.round(x - 2) + "px; ";
        border += "width: 100%; ";
        s += fw;
        pt = 0;
        if (0 < h) {
          s += "max-height: " + Math.round(h) + "px; ";
        }
      } else {
        if ("block" == overflow) {
          fw = "width: " + Math.round(x - 2) + "px; ";
          border += "width: 100%; ";
          align = "";
          pt = 0;
          s += fw;
          if ("middle" == valign) {
            s += "max-height: " + Math.round(h) + "px; ";
          }
        } else {
          align = "";
          pt = 0;
        }
      }
    }
  }
  h = "";
  if (null != bg) {
    h += "background-color: " + bg + "; ";
  }
  if (null != flex) {
    h += "border: 1px solid " + flex + "; ";
  }
  if ("" == align || clip) {
    border += h;
  } else {
    s += h;
  }
  if (w && 0 < x) {
    border += "white-space: normal; word-wrap: " + mxConstants.WORD_WRAP + "; ";
    fw = "width: " + Math.round(x) + "px; ";
    if ("" != align) {
      if ("fill" != overflow) {
        pt = 0;
      }
    }
  } else {
    border += "white-space: nowrap; ";
    if ("" == align) {
      if ("block" != overflow) {
        dx = 0;
      }
    }
  }
  callback(dx, pt, wrap + fw + fh, s + align, border, align);
};
mxSvgCanvas2D.prototype.getTextCss = function() {
  var s = this.state;
  var css = "display: inline-block; font-size: " + s.fontSize + "px; font-family: " + s.fontFamily + "; color: " + s.fontColor + "; line-height: " + (mxConstants.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT * this.lineHeightCorrection) + "; pointer-events: " + (this.pointerEvents ? this.pointerEventsValue : "none") + "; ";
  if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    css += "font-weight: bold; ";
  }
  if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    css += "font-style: italic; ";
  }
  var txtDecor = [];
  if ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    txtDecor.push("underline");
  }
  if ((s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    txtDecor.push("line-through");
  }
  if (0 < txtDecor.length) {
    css += "text-decoration: " + txtDecor.join(" ") + "; ";
  }
  return css;
};
mxSvgCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir) {
  if (this.textEnabled && null != str) {
    if (rotation = null != rotation ? rotation : 0, this.foEnabled && "html" == format) {
      var div = this.createDiv(str);
      if (null != div) {
        if (null != dir) {
          div.setAttribute("dir", dir);
        }
        this.addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, this.root);
      }
    } else {
      this.plainText(x + this.state.dx, y + this.state.dy, w, h, str, align, valign, wrap, overflow, clip, rotation, dir);
    }
  }
};
mxSvgCanvas2D.prototype.createClip = function(x, y, w, h) {
  x = Math.round(x);
  y = Math.round(y);
  w = Math.round(w);
  h = Math.round(h);
  var clip = "mx-clip-" + x + "-" + y + "-" + w + "-" + h;
  var counter = 0;
  for (var tmp = clip + "-" + counter;null != document.getElementById(tmp);) {
    tmp = clip + "-" + ++counter;
  }
  clip = this.createElement("clipPath");
  clip.setAttribute("id", tmp);
  tmp = this.createElement("rect");
  tmp.setAttribute("x", x);
  tmp.setAttribute("y", y);
  tmp.setAttribute("width", w);
  tmp.setAttribute("height", h);
  clip.appendChild(tmp);
  return clip;
};
mxSvgCanvas2D.prototype.createClipPathId = function(value) {
  value = "mx-clippath-" + value.replace(/[^a-zA-Z0-9]+/g, "-");
  var _ = "-" == value.charAt(value.length - 1) ? "" : "-";
  var counter = 0;
  for (var tmp = value + _ + counter;null != document.getElementById(tmp);) {
    tmp = value + _ + ++counter;
  }
  return tmp;
};
mxSvgCanvas2D.prototype.appendClipPath = function(node, y, into) {
  var d = y.match(/\(([^)]+)\)/);
  var obj = null;
  if ("polygon" == y.substring(0, 7)) {
    obj = this.appendPolygonClip(d[1], node, into);
  } else {
    if ("circle" == y.substring(0, 6)) {
      obj = this.appendCircleClip(d[1], node, into);
    } else {
      if ("ellipse" == y.substring(0, 7)) {
        obj = this.appendEllipseClip(d[1], node, into);
      } else {
        if ("inset" == y.substring(0, 5)) {
          obj = this.appendInsetClip(d[1], node, into);
        }
      }
    }
  }
  return obj;
};
mxSvgCanvas2D.prototype.appendPolygonClip = function(value, parent, node) {
  node = this.createElement("polygon");
  value = value.split(/[ ,]+/);
  var x = null;
  var childrenY = null;
  var lastChild = null;
  var maxChildrenY = null;
  var result = [];
  for (var i = 0;i < value.length;i++) {
    var child = this.parseClipValue(value, i);
    if (0 == i % 2) {
      if (null == x || x > child) {
        x = child;
      }
      if (null == lastChild || lastChild < child) {
        lastChild = child;
      }
    } else {
      if (null == childrenY || childrenY > child) {
        childrenY = child;
      }
      if (null == maxChildrenY || maxChildrenY < child) {
        maxChildrenY = child;
      }
    }
    result.push(child);
  }
  node.setAttribute("points", result.join(","));
  parent.appendChild(node);
  return new mxRectangle(x, childrenY, lastChild - x, maxChildrenY - childrenY);
};
mxSvgCanvas2D.prototype.appendCircleClip = function(str, node, elem) {
  elem = this.createElement("circle");
  var value = str.split(/[ ,]+/);
  str = this.parseClipValue(value, 0);
  var src = this.parseClipValue(value, 2);
  value = this.parseClipValue(value, 3);
  elem.setAttribute("r", str);
  elem.setAttribute("cx", src);
  elem.setAttribute("cy", value);
  node.appendChild(elem);
  return new mxRectangle(src - str, value - str, 2 * str, 2 * str);
};
mxSvgCanvas2D.prototype.appendEllipseClip = function(name, node, n) {
  n = this.createElement("ellipse");
  var value = name.split(/[ ,]+/);
  name = this.parseClipValue(value, 0);
  var src = this.parseClipValue(value, 1);
  var size = this.parseClipValue(value, 3);
  value = this.parseClipValue(value, 4);
  n.setAttribute("rx", name);
  n.setAttribute("ry", src);
  n.setAttribute("cx", size);
  n.setAttribute("cy", value);
  node.appendChild(n);
  return new mxRectangle(size - name, value - src, 2 * name, 2 * src);
};
mxSvgCanvas2D.prototype.appendInsetClip = function(name, node, n) {
  n = this.createElement("rect");
  var value = name.split(/[ ,]+/);
  name = this.parseClipValue(value, 0);
  var src = this.parseClipValue(value, 1);
  var size = this.parseClipValue(value, 2);
  var dx = this.parseClipValue(value, 3);
  src = 1 - src - dx;
  size = 1 - name - size;
  n.setAttribute("x", dx);
  n.setAttribute("y", name);
  n.setAttribute("width", src);
  n.setAttribute("height", size);
  if (4 < value.length) {
    if ("round" == value[4]) {
      value = this.parseClipValue(value, 5);
      n.setAttribute("rx", value);
      n.setAttribute("ry", value);
    }
  }
  node.appendChild(n);
  return new mxRectangle(dx, name, src, size);
};
mxSvgCanvas2D.prototype.parseClipValue = function(value, index) {
  index = value[Math.min(index, value.length - 1)];
  value = 1;
  if ("center" == index) {
    value = 0.5;
  } else {
    if ("top" == index || "left" == index) {
      value = 0;
    } else {
      index = parseFloat(index);
      if (!isNaN(index)) {
        value = Math.max(0, Math.min(1, index / 100));
      }
    }
  }
  return value;
};
mxSvgCanvas2D.prototype.setClip = function(node, c) {
  if (null != this.defs) {
    this.defs.appendChild(c);
  } else {
    this.root.appendChild(c);
  }
  if (mxClient.IS_CHROMEAPP || (mxClient.IS_IE || (mxClient.IS_IE11 || (mxClient.IS_EDGE || this.root.ownerDocument != document)))) {
    node.setAttribute("clip-path", "url(#" + c.getAttribute("id") + ")");
  } else {
    var base = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
    node.setAttribute("clip-path", "url(" + base + "#" + c.getAttribute("id") + ")");
  }
};
mxSvgCanvas2D.prototype.plainText = function(x, y, w, h, str, align, valign, s, fill, i, dy, dx) {
  dy = null != dy ? dy : 0;
  s = this.state;
  var size = s.fontSize;
  var node = this.createElement("g");
  var lines = s.transform || "";
  this.updateFont(node);
  if (!this.pointerEvents) {
    if (!(null != this.originalRoot)) {
      node.setAttribute("pointer-events", "none");
    }
  }
  if (0 != dy) {
    lines += "rotate(" + dy + "," + this.format(x * s.scale) + "," + this.format(y * s.scale) + ")";
  }
  if (null != dx) {
    node.setAttribute("direction", dx);
  }
  if (i) {
    if (0 < w) {
      if (0 < h) {
        dx = x;
        dy = y;
        if (align == mxConstants.ALIGN_CENTER) {
          dx -= w / 2;
        } else {
          if (align == mxConstants.ALIGN_RIGHT) {
            dx -= w;
          }
        }
        if ("fill" != fill) {
          if (valign == mxConstants.ALIGN_MIDDLE) {
            dy -= h / 2;
          } else {
            if (valign == mxConstants.ALIGN_BOTTOM) {
              dy -= h;
            }
          }
        }
        this.setClip(node, this.createClip(dx * s.scale - 2, dy * s.scale - 2, w * s.scale + 4, h * s.scale + 4));
      }
    }
  }
  dy = align == mxConstants.ALIGN_RIGHT ? "end" : align == mxConstants.ALIGN_CENTER ? "middle" : "start";
  if ("start" != dy) {
    node.setAttribute("text-anchor", dy);
  }
  if (!(this.styleEnabled && size == mxConstants.DEFAULT_FONTSIZE)) {
    node.setAttribute("font-size", size * s.scale + "px");
  }
  if (0 < lines.length) {
    node.setAttribute("transform", lines);
  }
  if (1 > s.alpha) {
    node.setAttribute("opacity", s.alpha);
  }
  lines = str.split("\n");
  dx = Math.round(size * mxConstants.LINE_HEIGHT);
  var textHeight = size + (lines.length - 1) * dx;
  dy = y + size - 1;
  if (valign == mxConstants.ALIGN_MIDDLE) {
    if ("fill" == fill) {
      dy -= h / 2;
    } else {
      i = (this.matchHtmlAlignment && (i && 0 < h) ? Math.min(textHeight, h) : textHeight) / 2;
      dy -= i;
    }
  } else {
    if (valign == mxConstants.ALIGN_BOTTOM) {
      if ("fill" == fill) {
        dy -= h;
      } else {
        i = this.matchHtmlAlignment && (i && 0 < h) ? Math.min(textHeight, h) : textHeight;
        dy -= i + 1;
      }
    }
  }
  for (i = 0;i < lines.length;i++) {
    if (0 < lines[i].length) {
      if (0 < mxUtils.trim(lines[i]).length) {
        size = this.createElement("text");
        size.setAttribute("x", this.format(x * s.scale) + this.textOffset);
        size.setAttribute("y", this.format(dy * s.scale) + this.textOffset);
        mxUtils.write(size, lines[i]);
        node.appendChild(size);
      }
    }
    dy += dx;
  }
  this.root.appendChild(node);
  this.addTextBackground(node, str, x, y, w, "fill" == fill ? h : textHeight, align, valign, fill);
};
mxSvgCanvas2D.prototype.updateFont = function(node) {
  var s = this.state;
  node.setAttribute("fill", s.fontColor);
  if (!(this.styleEnabled && s.fontFamily == mxConstants.DEFAULT_FONTFAMILY)) {
    node.setAttribute("font-family", s.fontFamily);
  }
  if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    node.setAttribute("font-weight", "bold");
  }
  if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    node.setAttribute("font-style", "italic");
  }
  var txtDecor = [];
  if ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    txtDecor.push("underline");
  }
  if ((s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    txtDecor.push("line-through");
  }
  if (0 < txtDecor.length) {
    node.setAttribute("text-decoration", txtDecor.join(" "));
  }
};
mxSvgCanvas2D.prototype.addTextBackground = function(node, n, x, y, w, h, align, valign, fill) {
  var s = this.state;
  if (null != s.fontBackgroundColor || null != s.fontBorderColor) {
    var div = null;
    if ("fill" == fill || "width" == fill) {
      if (align == mxConstants.ALIGN_CENTER) {
        x -= w / 2;
      } else {
        if (align == mxConstants.ALIGN_RIGHT) {
          x -= w;
        }
      }
      if (valign == mxConstants.ALIGN_MIDDLE) {
        y -= h / 2;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          y -= h;
        }
      }
      div = new mxRectangle((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);
    } else {
      if (null != node.getBBox && this.root.ownerDocument == document) {
        try {
          div = node.getBBox();
          var ie = mxClient.IS_IE && mxClient.IS_SVG;
          div = new mxRectangle(div.x, div.y + (ie ? 0 : 1), div.width, div.height + (ie ? 1 : 0));
        } catch (q) {
        }
      }
    }
    if (null == div || (0 == div.width || 0 == div.height)) {
      div = document.createElement("div");
      div.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
      div.style.fontSize = s.fontSize + "px";
      div.style.fontFamily = s.fontFamily;
      div.style.whiteSpace = "nowrap";
      div.style.position = "absolute";
      div.style.visibility = "hidden";
      div.style.display = "inline-block";
      div.style.zoom = "1";
      if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
        div.style.fontWeight = "bold";
      }
      if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
        div.style.fontStyle = "italic";
      }
      n = mxUtils.htmlEntities(n, false);
      div.innerHTML = n.replace(/\n/g, "<br/>");
      document.body.appendChild(div);
      w = div.offsetWidth;
      h = div.offsetHeight;
      div.parentNode.removeChild(div);
      if (align == mxConstants.ALIGN_CENTER) {
        x -= w / 2;
      } else {
        if (align == mxConstants.ALIGN_RIGHT) {
          x -= w;
        }
      }
      if (valign == mxConstants.ALIGN_MIDDLE) {
        y -= h / 2;
      } else {
        if (valign == mxConstants.ALIGN_BOTTOM) {
          y -= h;
        }
      }
      div = new mxRectangle((x + 1) * s.scale, (y + 2) * s.scale, w * s.scale, (h + 1) * s.scale);
    }
    if (null != div) {
      n = this.createElement("rect");
      n.setAttribute("fill", s.fontBackgroundColor || "none");
      n.setAttribute("stroke", s.fontBorderColor || "none");
      n.setAttribute("x", Math.floor(div.x - 1));
      n.setAttribute("y", Math.floor(div.y - 1));
      n.setAttribute("width", Math.ceil(div.width + 2));
      n.setAttribute("height", Math.ceil(div.height));
      s = null != s.fontBorderColor ? Math.max(1, this.format(s.scale)) : 0;
      n.setAttribute("stroke-width", s);
      if (this.root.ownerDocument == document) {
        if (1 == mxUtils.mod(s, 2)) {
          n.setAttribute("transform", "translate(0.5, 0.5)");
        }
      }
      node.insertBefore(n, node.firstChild);
    }
  }
};
mxSvgCanvas2D.prototype.stroke = function() {
  this.addNode(false, true);
};
mxSvgCanvas2D.prototype.fill = function() {
  this.addNode(true, false);
};
mxSvgCanvas2D.prototype.fillAndStroke = function() {
  this.addNode(true, true);
};
function mxGuide(graph, states) {
  this.graph = graph;
  this.setStates(states);
}
mxGuide.prototype.graph = null;
mxGuide.prototype.states = null;
mxGuide.prototype.horizontal = true;
mxGuide.prototype.vertical = true;
mxGuide.prototype.guideX = null;
mxGuide.prototype.guideY = null;
mxGuide.prototype.rounded = false;
mxGuide.prototype.tolerance = 2;
mxGuide.prototype.setStates = function(states) {
  this.states = states;
};
mxGuide.prototype.isEnabledForEvent = function(evt) {
  return true;
};
mxGuide.prototype.getGuideTolerance = function(gridEnabled) {
  return gridEnabled && this.graph.gridEnabled ? this.graph.gridSize / 2 : this.tolerance;
};
mxGuide.prototype.createGuideShape = function(horizontal) {
  horizontal = new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH);
  horizontal.isDashed = true;
  return horizontal;
};
mxGuide.prototype.isStateIgnored = function(state) {
  return false;
};
mxGuide.prototype.move = function(bounds, delta, gridEnabled, snapY) {
  if (null != this.states && ((this.horizontal || this.vertical) && (null != bounds && null != delta))) {
    snapY = function(y, state, centerAlign) {
      var override = false;
      if (centerAlign && Math.abs(y - middle) < ttY) {
        delta.y = y - bounds.getCenterY();
        ttY = Math.abs(y - middle);
        override = true;
      } else {
        if (!centerAlign) {
          if (Math.abs(y - top) < ttY) {
            delta.y = y - bounds.y;
            ttY = Math.abs(y - top);
            override = true;
          } else {
            if (Math.abs(y - bottom) < ttY) {
              delta.y = y - bounds.y - bounds.height;
              ttY = Math.abs(y - bottom);
              override = true;
            }
          }
        }
      }
      if (override) {
        stateY = state;
        valueY = y;
        if (null == this.guideY) {
          this.guideY = this.createGuideShape(false);
          this.guideY.dialect = mxConstants.DIALECT_SVG;
          this.guideY.pointerEvents = false;
          this.guideY.init(this.graph.getView().getOverlayPane());
        }
      }
      overrideY = overrideY || override;
    };
    var snapX = function(x, state, centerAlign) {
      var override = false;
      if (centerAlign && Math.abs(x - center) < ttX) {
        delta.x = x - bounds.getCenterX();
        ttX = Math.abs(x - center);
        override = true;
      } else {
        if (!centerAlign) {
          if (Math.abs(x - left) < ttX) {
            delta.x = x - bounds.x;
            ttX = Math.abs(x - left);
            override = true;
          } else {
            if (Math.abs(x - right) < ttX) {
              delta.x = x - bounds.x - bounds.width;
              ttX = Math.abs(x - right);
              override = true;
            }
          }
        }
      }
      if (override) {
        stateX = state;
        valueX = x;
        if (null == this.guideX) {
          this.guideX = this.createGuideShape(true);
          this.guideX.dialect = mxConstants.DIALECT_SVG;
          this.guideX.pointerEvents = false;
          this.guideX.init(this.graph.getView().getOverlayPane());
        }
      }
      overrideX = overrideX || override;
    };
    var i = this.graph.getView().scale;
    i *= this.getGuideTolerance(gridEnabled);
    var state = bounds.clone();
    state.x += delta.x;
    state.y += delta.y;
    var overrideX = false;
    var stateX = null;
    var valueX = null;
    var overrideY = false;
    var stateY = null;
    var valueY = null;
    var ttX = i;
    var ttY = i;
    var left = state.x;
    var right = state.x + state.width;
    var center = state.getCenterX();
    var top = state.y;
    var bottom = state.y + state.height;
    var middle = state.getCenterY();
    for (i = 0;i < this.states.length;i++) {
      state = this.states[i];
      if (!(null == state)) {
        if (!this.isStateIgnored(state)) {
          if (this.horizontal) {
            snapX.call(this, state.getCenterX(), state, true);
            snapX.call(this, state.x, state, false);
            snapX.call(this, state.x + state.width, state, false);
            if (null == state.cell) {
              snapX.call(this, state.getCenterX(), state, false);
            }
          }
          if (this.vertical) {
            snapY.call(this, state.getCenterY(), state, true);
            snapY.call(this, state.y, state, false);
            snapY.call(this, state.y + state.height, state, false);
            if (null == state.cell) {
              snapY.call(this, state.getCenterY(), state, false);
            }
          }
        }
      }
    }
    this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);
    delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);
    gridEnabled = this.graph.container;
    if (overrideX || null == this.guideX) {
      if (null != this.guideX) {
        snapX = snapY = null;
        if (null != stateX) {
          if (null != bounds) {
            snapY = Math.min(bounds.y + delta.y - this.graph.panDy, stateX.y);
            snapX = Math.max(bounds.y + bounds.height + delta.y - this.graph.panDy, stateX.y + stateX.height);
          }
        }
        this.guideX.points = null != snapY && null != snapX ? [new mxPoint(valueX, snapY), new mxPoint(valueX, snapX)] : [new mxPoint(valueX, -this.graph.panDy), new mxPoint(valueX, gridEnabled.scrollHeight - 3 - this.graph.panDy)];
        this.guideX.stroke = this.getGuideColor(stateX, true);
        this.guideX.node.style.visibility = "visible";
        this.guideX.redraw();
      }
    } else {
      this.guideX.node.style.visibility = "hidden";
    }
    if (overrideY || null == this.guideY) {
      if (null != this.guideY) {
        snapX = snapY = null;
        if (null != stateY) {
          if (null != bounds) {
            snapY = Math.min(bounds.x + delta.x - this.graph.panDx, stateY.x);
            snapX = Math.max(bounds.x + bounds.width + delta.x - this.graph.panDx, stateY.x + stateY.width);
          }
        }
        this.guideY.points = null != snapY && null != snapX ? [new mxPoint(snapY, valueY), new mxPoint(snapX, valueY)] : [new mxPoint(-this.graph.panDx, valueY), new mxPoint(gridEnabled.scrollWidth - 3 - this.graph.panDx, valueY)];
        this.guideY.stroke = this.getGuideColor(stateY, false);
        this.guideY.node.style.visibility = "visible";
        this.guideY.redraw();
      }
    } else {
      this.guideY.node.style.visibility = "hidden";
    }
  }
  return delta;
};
mxGuide.prototype.getDelta = function(bounds, stateX, dx, stateY, dy) {
  var s = this.graph.view.scale;
  if (this.rounded || null != stateX && null == stateX.cell) {
    dx = Math.round((bounds.x + dx) / s) * s - bounds.x;
  }
  if (this.rounded || null != stateY && null == stateY.cell) {
    dy = Math.round((bounds.y + dy) / s) * s - bounds.y;
  }
  return new mxPoint(dx, dy);
};
mxGuide.prototype.getGuideColor = function(state, horizontal) {
  return mxConstants.GUIDE_COLOR;
};
mxGuide.prototype.hide = function() {
  this.setVisible(false);
};
mxGuide.prototype.setVisible = function(visible) {
  if (null != this.guideX) {
    this.guideX.node.style.visibility = visible ? "visible" : "hidden";
  }
  if (null != this.guideY) {
    this.guideY.node.style.visibility = visible ? "visible" : "hidden";
  }
};
mxGuide.prototype.destroy = function() {
  if (null != this.guideX) {
    this.guideX.destroy();
    this.guideX = null;
  }
  if (null != this.guideY) {
    this.guideY.destroy();
    this.guideY = null;
  }
};
function mxShape(stencil) {
  this.stencil = stencil;
  this.initStyles();
}
mxShape.prototype.dialect = null;
mxShape.prototype.scale = 1;
mxShape.prototype.antiAlias = true;
mxShape.prototype.minSvgStrokeWidth = 1;
mxShape.prototype.bounds = null;
mxShape.prototype.points = null;
mxShape.prototype.node = null;
mxShape.prototype.state = null;
mxShape.prototype.style = null;
mxShape.prototype.boundingBox = null;
mxShape.prototype.stencil = null;
mxShape.prototype.svgStrokeTolerance = 8;
mxShape.prototype.pointerEvents = true;
mxShape.prototype.svgPointerEvents = "all";
mxShape.prototype.shapePointerEvents = false;
mxShape.prototype.stencilPointerEvents = false;
mxShape.prototype.outline = false;
mxShape.prototype.visible = true;
mxShape.prototype.useSvgBoundingBox = false;
mxShape.prototype.init = function(container) {
  if (null == this.node) {
    this.node = this.create(container);
    if (null != container) {
      container.appendChild(this.node);
    }
  }
};
mxShape.prototype.initStyles = function(container) {
  this.strokewidth = 1;
  this.rotation = 0;
  this.strokeOpacity = this.fillOpacity = this.opacity = 100;
  this.flipV = this.flipH = false;
};
mxShape.prototype.isHtmlAllowed = function() {
  return false;
};
mxShape.prototype.getSvgScreenOffset = function() {
  return 1 == mxUtils.mod(Math.max(1, Math.round((this.stencil && "inherit" != this.stencil.strokewidth ? Number(this.stencil.strokewidth) : this.strokewidth) * this.scale)), 2) ? 0.5 : 0;
};
mxShape.prototype.create = function(cell) {
  return null != cell && null != cell.ownerSVGElement ? this.createSvg(cell) : this.createHtml(cell);
};
mxShape.prototype.createSvg = function() {
  return document.createElementNS(mxConstants.NS_SVG, "g");
};
mxShape.prototype.createHtml = function() {
  var node = document.createElement("div");
  node.style.position = "absolute";
  return node;
};
mxShape.prototype.reconfigure = function() {
  this.redraw();
};
mxShape.prototype.redraw = function() {
  this.updateBoundsFromPoints();
  if (this.visible && this.checkBounds()) {
    this.node.style.visibility = "visible";
    this.clear();
    if ("DIV" == this.node.nodeName) {
      this.redrawHtmlShape();
    } else {
      this.redrawShape();
    }
    this.updateBoundingBox();
  } else {
    this.node.style.visibility = "hidden";
    this.boundingBox = null;
  }
};
mxShape.prototype.clear = function() {
  if (null != this.node.ownerSVGElement) {
    for (;null != this.node.lastChild;) {
      this.node.removeChild(this.node.lastChild);
    }
  } else {
    this.node.style.cssText = "position:absolute;" + (null != this.cursor ? "cursor:" + this.cursor + ";" : "");
    this.node.innerText = "";
  }
};
mxShape.prototype.updateBoundsFromPoints = function() {
  var pts = this.points;
  if (null != pts && (0 < pts.length && null != pts[0])) {
    this.bounds = new mxRectangle(Number(pts[0].x), Number(pts[0].y), 1, 1);
    for (var i = 1;i < this.points.length;i++) {
      if (null != pts[i]) {
        this.bounds.add(new mxRectangle(Number(pts[i].x), Number(pts[i].y), 1, 1));
      }
    }
  }
};
mxShape.prototype.getLabelBounds = function(rect) {
  var tmp = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
  var m = rect;
  if (tmp != mxConstants.DIRECTION_SOUTH) {
    if (tmp != mxConstants.DIRECTION_NORTH) {
      if (null != this.state) {
        if (null != this.state.text) {
          if (this.state.text.isPaintBoundsInverted()) {
            m = m.clone();
            tmp = m.width;
            m.width = m.height;
            m.height = tmp;
          }
        }
      }
    }
  }
  m = this.getLabelMargins(m);
  if (null != m) {
    var flipH = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, false);
    var flipV = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, false);
    if (null != this.state) {
      if (null != this.state.text) {
        if (this.state.text.isPaintBoundsInverted()) {
          tmp = m.x;
          m.x = m.height;
          m.height = m.width;
          m.width = m.y;
          m.y = tmp;
          tmp = flipH;
          flipH = flipV;
          flipV = tmp;
        }
      }
    }
    return mxUtils.getDirectedBounds(rect, m, this.style, flipH, flipV);
  }
  return rect;
};
mxShape.prototype.getLabelMargins = function(rect) {
  return null;
};
mxShape.prototype.checkBounds = function() {
  return!isNaN(this.scale) && (isFinite(this.scale) && (0 < this.scale && (null != this.bounds && (!isNaN(this.bounds.x) && (!isNaN(this.bounds.y) && (!isNaN(this.bounds.width) && (!isNaN(this.bounds.height) && (0 < this.bounds.width && 0 < this.bounds.height))))))));
};
mxShape.prototype.redrawShape = function() {
  var canvas = this.createCanvas();
  if (null != canvas) {
    canvas.pointerEvents = this.pointerEvents;
    this.beforePaint(canvas);
    this.paint(canvas);
    this.afterPaint(canvas);
    if (this.node != canvas.root) {
      this.node.insertAdjacentHTML("beforeend", canvas.root.outerHTML);
    }
    if ("DIV" == this.node.nodeName) {
      if (8 == document.documentMode) {
        this.node.style.filter = "";
        mxUtils.addTransparentBackgroundFilter(this.node);
      }
    }
    this.destroyCanvas(canvas);
  }
};
mxShape.prototype.createCanvas = function() {
  var canvas = null;
  if (null != this.node.ownerSVGElement) {
    canvas = this.createSvgCanvas();
  }
  if (null != canvas) {
    if (this.outline) {
      canvas.setStrokeWidth(this.strokewidth);
      canvas.setStrokeColor(this.stroke);
      if (null != this.isDashed) {
        canvas.setDashed(this.isDashed);
      }
      canvas.setStrokeWidth = function() {
      };
      canvas.setStrokeColor = function() {
      };
      canvas.setFillColor = function() {
      };
      canvas.setGradient = function() {
      };
      canvas.setDashed = function() {
      };
      canvas.text = function() {
      };
    }
  }
  return canvas;
};
mxShape.prototype.createSvgCanvas = function() {
  var canvas = new mxSvgCanvas2D(this.node, false);
  canvas.strokeTolerance = this.svgStrokeTolerance;
  canvas.pointerEventsValue = this.svgPointerEvents;
  var off = this.getSvgScreenOffset();
  if (0 != off) {
    this.node.setAttribute("transform", "translate(" + off + "," + off + ")");
  } else {
    this.node.removeAttribute("transform");
  }
  canvas.minStrokeWidth = this.minSvgStrokeWidth;
  if (!this.antiAlias) {
    canvas.format = function(value) {
      return Math.round(parseFloat(value));
    };
  }
  return canvas;
};
mxShape.prototype.redrawHtmlShape = function() {
  this.updateHtmlBounds(this.node);
  this.updateHtmlFilters(this.node);
  this.updateHtmlColors(this.node);
};
mxShape.prototype.updateHtmlFilters = function(node) {
  var f = "";
  if (100 > this.opacity) {
    f += "alpha(opacity=" + this.opacity + ")";
  }
  if (this.isShadow) {
    f += "progid:DXImageTransform.Microsoft.dropShadow (OffX='" + Math.round(mxConstants.SHADOW_OFFSET_X * this.scale) + "', OffY='" + Math.round(mxConstants.SHADOW_OFFSET_Y * this.scale) + "', Color='" + mxConstants.VML_SHADOWCOLOR + "')";
  }
  if (null != this.fill && (this.fill != mxConstants.NONE && (this.gradient && this.gradient != mxConstants.NONE))) {
    var start = this.fill;
    var end = this.gradient;
    var e = "0";
    var lookup = {
      east : 0,
      south : 1,
      west : 2,
      north : 3
    };
    var dir = null != this.direction ? lookup[this.direction] : 0;
    if (null != this.gradientDirection) {
      dir = mxUtils.mod(dir + lookup[this.gradientDirection] - 1, 4);
    }
    if (1 == dir) {
      e = "1";
      lookup = start;
      start = end;
      end = lookup;
    } else {
      if (2 == dir) {
        lookup = start;
        start = end;
        end = lookup;
      } else {
        if (3 == dir) {
          e = "1";
        }
      }
    }
    f += "progid:DXImageTransform.Microsoft.gradient(startColorStr='" + start + "', endColorStr='" + end + "', gradientType='" + e + "')";
  }
  node.style.filter = f;
};
mxShape.prototype.updateHtmlColors = function(node) {
  var color = this.stroke;
  if (null != color && color != mxConstants.NONE) {
    node.style.borderColor = color;
    if (this.isDashed) {
      node.style.borderStyle = "dashed";
    } else {
      if (0 < this.strokewidth) {
        node.style.borderStyle = "solid";
      }
    }
    node.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + "px";
  } else {
    node.style.borderWidth = "0px";
  }
  color = this.outline ? null : this.fill;
  if (null != color && color != mxConstants.NONE) {
    node.style.backgroundColor = color;
    node.style.backgroundImage = "none";
  } else {
    if (this.pointerEvents) {
      node.style.backgroundColor = "transparent";
    } else {
      if (8 == document.documentMode) {
        mxUtils.addTransparentBackgroundFilter(node);
      } else {
        this.setTransparentBackgroundImage(node);
      }
    }
  }
};
mxShape.prototype.updateHtmlBounds = function(node) {
  var sw = 9 <= document.documentMode ? 0 : Math.ceil(this.strokewidth * this.scale);
  node.style.borderWidth = Math.max(1, sw) + "px";
  node.style.overflow = "hidden";
  node.style.left = Math.round(this.bounds.x - sw / 2) + "px";
  node.style.top = Math.round(this.bounds.y - sw / 2) + "px";
  if ("CSS1Compat" == document.compatMode) {
    sw = -sw;
  }
  node.style.width = Math.round(Math.max(0, this.bounds.width + sw)) + "px";
  node.style.height = Math.round(Math.max(0, this.bounds.height + sw)) + "px";
};
mxShape.prototype.destroyCanvas = function(canvas) {
  if (canvas instanceof mxSvgCanvas2D) {
    for (var key in canvas.gradients) {
      var gradient = canvas.gradients[key];
      if (null != gradient) {
        gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;
      }
    }
    for (key in canvas.fillPatterns) {
      gradient = canvas.fillPatterns[key];
      if (null != gradient) {
        gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;
      }
    }
    this.releaseSvgGradients(this.oldGradients);
    this.releaseSvgFillPatterns(this.oldFillPatterns);
    this.oldGradients = canvas.gradients;
    this.oldFillPatterns = canvas.fillPatterns;
  }
};
mxShape.prototype.beforePaint = function(c) {
};
mxShape.prototype.afterPaint = function(c) {
};
mxShape.prototype.paint = function(c) {
  var b = false;
  if (null != c && this.outline) {
    var stroke = c.stroke;
    c.stroke = function() {
      b = true;
      stroke.apply(this, arguments);
    };
    var fillAndStroke = c.fillAndStroke;
    c.fillAndStroke = function() {
      b = true;
      fillAndStroke.apply(this, arguments);
    };
  }
  var s = this.scale;
  var x = this.bounds.x / s;
  var y = this.bounds.y / s;
  var w = this.bounds.width / s;
  var h = this.bounds.height / s;
  if (this.isPaintBoundsInverted()) {
    var bg = (w - h) / 2;
    x += bg;
    y -= bg;
    bg = w;
    w = h;
    h = bg;
  }
  this.updateTransform(c, x, y, w, h);
  this.configureCanvas(c, x, y, w, h);
  bg = null;
  if (null == this.stencil && (null == this.points && this.shapePointerEvents) || null != this.stencil && this.stencilPointerEvents) {
    var bb = this.createBoundingBox();
    if (this.dialect == mxConstants.DIALECT_SVG) {
      bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);
      this.node.appendChild(bg);
    } else {
      s = c.createRect("rect", bb.x / s, bb.y / s, bb.width / s, bb.height / s);
      s.appendChild(c.createTransparentFill());
      s.stroked = "false";
      c.root.appendChild(s);
    }
  }
  if (null != this.stencil) {
    this.stencil.drawShape(c, this, x, y, w, h);
  } else {
    c.setStrokeWidth(this.strokewidth);
    s = this.getWaypoints();
    if (null != s) {
      if (1 < s.length) {
        this.paintEdgeShape(c, s);
      }
    } else {
      this.paintVertexShape(c, x, y, w, h);
    }
  }
  if (null != bg) {
    if (null != c.state) {
      if (null != c.state.transform) {
        bg.setAttribute("transform", c.state.transform);
      }
    }
  }
  if (null != c) {
    if (this.outline) {
      if (!b) {
        c.rect(x, y, w, h);
        c.stroke();
      }
    }
  }
};
mxShape.prototype.getWaypoints = function() {
  var pairs = this.points;
  var result = null;
  if (null != pairs && (result = [], 0 < pairs.length)) {
    var s = this.scale;
    var tol = Math.max(s, 1);
    var pt = pairs[0];
    result.push(new mxPoint(pt.x / s, pt.y / s));
    for (var i = 1;i < pairs.length;i++) {
      var tmp = pairs[i];
      if (Math.abs(pt.x - tmp.x) >= tol || Math.abs(pt.y - tmp.y) >= tol) {
        result.push(new mxPoint(tmp.x / s, tmp.y / s));
      }
      pt = tmp;
    }
  }
  return result;
};
mxShape.prototype.configureCanvas = function(c, b, y, w, h) {
  var value = null;
  if (null != this.style) {
    value = this.style.dashPattern;
  }
  c.setAlpha(this.opacity / 100);
  c.setFillAlpha(this.fillOpacity / 100);
  c.setStrokeAlpha(this.strokeOpacity / 100);
  if (null != this.isShadow) {
    c.setShadow(this.isShadow);
  }
  if (null != this.isDashed) {
    c.setDashed(this.isDashed, null != this.style ? 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FIX_DASH, false) : false);
  }
  if (null != value) {
    c.setDashPattern(value);
  }
  if (null != this.fill && (this.fill != mxConstants.NONE && (this.gradient && this.gradient != mxConstants.NONE))) {
    b = this.getGradientBounds(c, b, y, w, h);
    c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);
  } else {
    c.setFillColor(this.fill);
    c.setFillStyle(this.fillStyle);
  }
  c.setStrokeColor(this.stroke);
  this.configurePointerEvents(c);
};
mxShape.prototype.configurePointerEvents = function(c) {
  if (!(null == this.style)) {
    if (!(null != this.fill && (this.fill != mxConstants.NONE && (0 != this.opacity && 0 != this.fillOpacity)))) {
      if (!("0" != mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1"))) {
        c.pointerEvents = false;
      }
    }
  }
};
mxShape.prototype.getGradientBounds = function(c, x, y, w, h) {
  return new mxRectangle(x, y, w, h);
};
mxShape.prototype.updateTransform = function(c, x, y, w, h) {
  c.scale(this.scale);
  c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);
};
mxShape.prototype.paintVertexShape = function(c, x, y, w, h) {
  this.paintBackground(c, x, y, w, h);
  if (!(this.outline && (null != this.style && 0 != mxUtils.getValue(this.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0)))) {
    c.setShadow(false);
    this.paintForeground(c, x, y, w, h);
  }
};
mxShape.prototype.paintBackground = function(c, x, y, w, h) {
};
mxShape.prototype.paintForeground = function(c, x, y, w, h) {
};
mxShape.prototype.paintEdgeShape = function(c, pts) {
};
mxShape.prototype.getArcSize = function(w, h) {
  if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
    w = Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
  } else {
    var f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
    w = Math.min(w * f, h * f);
  }
  return w;
};
mxShape.prototype.paintGlassEffect = function(c, x, y, w, h, arc) {
  var sw = Math.ceil(this.strokewidth / 2);
  c.setGradient("#ffffff", "#ffffff", x, y, w, 0.6 * h, "south", 0.9, 0.1);
  c.begin();
  arc += 2 * sw;
  if (this.isRounded) {
    c.moveTo(x - sw + arc, y - sw);
    c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);
    c.lineTo(x - sw, y + 0.4 * h);
    c.quadTo(x + 0.5 * w, y + 0.7 * h, x + w + sw, y + 0.4 * h);
    c.lineTo(x + w + sw, y - sw + arc);
    c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);
  } else {
    c.moveTo(x - sw, y - sw);
    c.lineTo(x - sw, y + 0.4 * h);
    c.quadTo(x + 0.5 * w, y + 0.7 * h, x + w + sw, y + 0.4 * h);
    c.lineTo(x + w + sw, y - sw);
  }
  c.close();
  c.fill();
};
mxShape.prototype.addPoints = function(c, pts, rounded, arcSize, initialMove, transients, tmp) {
  if (null != pts && 0 < pts.length) {
    tmp = null != tmp ? tmp : true;
    var pe = pts[pts.length - 1];
    if (initialMove && rounded) {
      pts = pts.slice();
      var pt = pts[0];
      pt = new mxPoint(pe.x + (pt.x - pe.x) / 2, pe.y + (pt.y - pe.y) / 2);
      pts.splice(0, 0, pt);
    }
    var y2 = pts[0];
    pt = 1;
    if (tmp) {
      c.moveTo(y2.x, y2.y);
    } else {
      c.lineTo(y2.x, y2.y);
    }
    for (;pt < (initialMove ? pts.length : pts.length - 1);) {
      tmp = pts[mxUtils.mod(pt, pts.length)];
      var x2 = y2.x - tmp.x;
      y2 = y2.y - tmp.y;
      if (rounded && ((0 != x2 || 0 != y2) && (null == transients || 0 > mxUtils.indexOf(transients, pt - 1)))) {
        var angleFactor = Math.sqrt(x2 * x2 + y2 * y2);
        c.lineTo(tmp.x + x2 * Math.min(arcSize, angleFactor / 2) / angleFactor, tmp.y + y2 * Math.min(arcSize, angleFactor / 2) / angleFactor);
        for (y2 = pts[mxUtils.mod(pt + 1, pts.length)];pt < pts.length - 2 && (0 == Math.round(y2.x - tmp.x) && 0 == Math.round(y2.y - tmp.y));) {
          y2 = pts[mxUtils.mod(pt + 2, pts.length)];
          pt++;
        }
        x2 = y2.x - tmp.x;
        y2 = y2.y - tmp.y;
        angleFactor = Math.max(1, Math.sqrt(x2 * x2 + y2 * y2));
        x2 = tmp.x + x2 * Math.min(arcSize, angleFactor / 2) / angleFactor;
        y2 = tmp.y + y2 * Math.min(arcSize, angleFactor / 2) / angleFactor;
        c.quadTo(tmp.x, tmp.y, x2, y2);
        tmp = new mxPoint(x2, y2);
      } else {
        c.lineTo(tmp.x, tmp.y);
      }
      y2 = tmp;
      pt++;
    }
    if (initialMove) {
      c.close();
    } else {
      c.lineTo(pe.x, pe.y);
    }
  }
};
mxShape.prototype.resetStyles = function() {
  this.initStyles();
  this.spacing = 0;
  delete this.fill;
  delete this.gradient;
  delete this.gradientDirection;
  delete this.stroke;
  delete this.startSize;
  delete this.endSize;
  delete this.startArrow;
  delete this.endArrow;
  delete this.direction;
  delete this.isShadow;
  delete this.isDashed;
  delete this.isRounded;
  delete this.glass;
};
mxShape.prototype.apply = function(state) {
  this.state = state;
  this.style = state.style;
  if (null != this.style) {
    this.fill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, this.fill);
    this.gradient = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENTCOLOR, this.gradient);
    this.gradientDirection = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENT_DIRECTION, this.gradientDirection);
    this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_OPACITY, this.opacity);
    this.fillOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_OPACITY, this.fillOpacity);
    this.fillStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_STYLE, this.fillStyle);
    this.strokeOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_STROKE_OPACITY, this.strokeOpacity);
    this.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, this.stroke);
    this.strokewidth = mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth);
    this.spacing = mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing);
    this.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, this.startSize);
    this.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, this.endSize);
    this.startArrow = mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, this.startArrow);
    this.endArrow = mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, this.endArrow);
    this.rotation = mxUtils.getValue(this.style, mxConstants.STYLE_ROTATION, this.rotation);
    this.direction = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, this.direction);
    this.flipH = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0);
    this.flipV = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0);
    if (null != this.stencil) {
      this.flipH = 1 == mxUtils.getValue(this.style, "stencilFlipH", 0) || this.flipH;
      this.flipV = 1 == mxUtils.getValue(this.style, "stencilFlipV", 0) || this.flipV;
    }
    if (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH) {
      state = this.flipH;
      this.flipH = this.flipV;
      this.flipV = state;
    }
    this.isShadow = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SHADOW, this.isShadow);
    this.isDashed = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, this.isDashed);
    this.isRounded = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_ROUNDED, this.isRounded);
    this.glass = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_GLASS, this.glass);
    if (this.fill == mxConstants.NONE) {
      this.fill = null;
    }
    if (this.gradient == mxConstants.NONE) {
      this.gradient = null;
    }
    if (this.stroke == mxConstants.NONE) {
      this.stroke = null;
    }
  }
};
mxShape.prototype.setCursor = function(cursor) {
  if (null == cursor) {
    cursor = "";
  }
  this.cursor = cursor;
  if (null != this.node) {
    this.node.style.cursor = cursor;
  }
};
mxShape.prototype.getCursor = function() {
  return this.cursor;
};
mxShape.prototype.isRoundable = function() {
  return false;
};
mxShape.prototype.updateBoundingBox = function() {
  if (this.useSvgBoundingBox && (null != this.node && null != this.node.ownerSVGElement)) {
    try {
      var bbox = this.node.getBBox();
      if (0 < bbox.width && 0 < bbox.height) {
        this.boundingBox = new mxRectangle(bbox.x, bbox.y, bbox.width, bbox.height);
        this.boundingBox.grow(this.strokewidth * this.scale / 2);
        return;
      }
    } catch (c) {
    }
  }
  if (null != this.bounds) {
    bbox = this.createBoundingBox();
    if (null != bbox) {
      this.augmentBoundingBox(bbox);
      var rot = this.getShapeRotation();
      if (0 != rot) {
        bbox = mxUtils.getBoundingBox(bbox, rot);
      }
    }
    this.boundingBox = bbox;
  }
};
mxShape.prototype.createBoundingBox = function() {
  var bb = this.bounds.clone();
  if (null != this.stencil && (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH) || this.isPaintBoundsInverted()) {
    bb.rotate90();
  }
  return bb;
};
mxShape.prototype.augmentBoundingBox = function(bbox) {
  if (this.isShadow) {
    bbox.width += Math.ceil(mxConstants.SHADOW_OFFSET_X * this.scale);
    bbox.height += Math.ceil(mxConstants.SHADOW_OFFSET_Y * this.scale);
  }
  bbox.grow(this.strokewidth * this.scale / 2);
};
mxShape.prototype.isPaintBoundsInverted = function() {
  return null == this.stencil && (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH);
};
mxShape.prototype.getRotation = function() {
  return null != this.rotation ? this.rotation : 0;
};
mxShape.prototype.getTextRotation = function() {
  var rot = this.getRotation();
  if (1 != mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1)) {
    rot += mxText.prototype.verticalTextRotation;
  }
  return rot;
};
mxShape.prototype.getShapeRotation = function() {
  var rot = this.getRotation();
  if (null != this.direction) {
    if (this.direction == mxConstants.DIRECTION_NORTH) {
      rot += 270;
    } else {
      if (this.direction == mxConstants.DIRECTION_WEST) {
        rot += 180;
      } else {
        if (this.direction == mxConstants.DIRECTION_SOUTH) {
          rot += 90;
        }
      }
    }
  }
  return rot;
};
mxShape.prototype.createTransparentSvgRectangle = function(y, value, h, w) {
  var rect = document.createElementNS(mxConstants.NS_SVG, "rect");
  rect.setAttribute("x", y);
  rect.setAttribute("y", value);
  rect.setAttribute("width", h);
  rect.setAttribute("height", w);
  rect.setAttribute("fill", "none");
  rect.setAttribute("stroke", "none");
  rect.setAttribute("pointer-events", "all");
  return rect;
};
mxShape.prototype.setTransparentBackgroundImage = function(node) {
  node.style.backgroundImage = "url('" + mxClient.imageBasePath + "/transparent.gif')";
};
mxShape.prototype.intersectsRectangle = function(x) {
  return null != x && (null != this.node && ("hidden" != this.node.style.visibility && ("none" != this.node.style.display && mxUtils.intersects(this.bounds, x))));
};
mxShape.prototype.releaseSvgGradients = function(grads) {
  if (null != grads) {
    for (var key in grads) {
      var gradient = grads[key];
      if (null != gradient) {
        gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;
        if (0 == gradient.mxRefCount) {
          if (null != gradient.parentNode) {
            gradient.parentNode.removeChild(gradient);
          }
        }
      }
    }
  }
};
mxShape.prototype.releaseSvgFillPatterns = function(grads) {
  if (null != grads) {
    for (var key in grads) {
      var gradient = grads[key];
      if (null != gradient) {
        gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;
        if (0 == gradient.mxRefCount) {
          if (null != gradient.parentNode) {
            gradient.parentNode.removeChild(gradient);
          }
        }
      }
    }
  }
};
mxShape.prototype.destroy = function() {
  if (null != this.node) {
    mxEvent.release(this.node);
    if (null != this.node.parentNode) {
      this.node.parentNode.removeChild(this.node);
    }
    this.node = null;
  }
  this.releaseSvgGradients(this.oldGradients);
  this.releaseSvgFillPatterns(this.oldFillPatterns);
  this.oldFillPatterns = this.oldGradients = null;
};
function mxStencil(desc) {
  this.desc = desc;
  this.parseDescription();
  this.parseConstraints();
}
mxUtils.extend(mxStencil, mxShape);
mxStencil.defaultLocalized = false;
mxStencil.allowEval = false;
mxStencil.prototype.desc = null;
mxStencil.prototype.constraints = null;
mxStencil.prototype.aspect = null;
mxStencil.prototype.w0 = null;
mxStencil.prototype.h0 = null;
mxStencil.prototype.bgNode = null;
mxStencil.prototype.fgNode = null;
mxStencil.prototype.strokewidth = null;
mxStencil.prototype.parseDescription = function() {
  this.fgNode = this.desc.getElementsByTagName("foreground")[0];
  this.bgNode = this.desc.getElementsByTagName("background")[0];
  this.w0 = Number(this.desc.getAttribute("w") || 100);
  this.h0 = Number(this.desc.getAttribute("h") || 100);
  var aspect = this.desc.getAttribute("aspect");
  this.aspect = null != aspect ? aspect : "variable";
  aspect = this.desc.getAttribute("strokewidth");
  this.strokewidth = null != aspect ? aspect : "1";
};
mxStencil.prototype.parseConstraints = function() {
  var tmp = this.desc.getElementsByTagName("connections")[0];
  if (null != tmp && (tmp = mxUtils.getChildNodes(tmp), null != tmp && 0 < tmp.length)) {
    this.constraints = [];
    for (var i = 0;i < tmp.length;i++) {
      this.constraints.push(this.parseConstraint(tmp[i]));
    }
  }
};
mxStencil.prototype.parseConstraint = function(node) {
  var x = Number(node.getAttribute("x"));
  var y = Number(node.getAttribute("y"));
  var perimeter = "1" == node.getAttribute("perimeter");
  node = node.getAttribute("name");
  return new mxConnectionConstraint(new mxPoint(x, y), perimeter, node);
};
mxStencil.prototype.evaluateTextAttribute = function(node, cell, shape) {
  cell = this.evaluateAttribute(node, cell, shape);
  node = node.getAttribute("localized");
  if (mxStencil.defaultLocalized && null == node || "1" == node) {
    cell = mxResources.get(cell);
  }
  return cell;
};
mxStencil.prototype.evaluateAttribute = function(node, attribute, shape) {
  attribute = node.getAttribute(attribute);
  if (null == attribute) {
    node = mxUtils.getTextContent(node);
    if (null != node) {
      if (mxStencil.allowEval) {
        node = mxUtils.eval(node);
        if ("function" == typeof node) {
          attribute = node(shape);
        }
      }
    }
  }
  return attribute;
};
mxStencil.prototype.drawShape = function(canvas, shape, x, y, w, h) {
  var stack = canvas.states.slice();
  var aspect = mxUtils.getValue(shape.style, mxConstants.STYLE_DIRECTION, null);
  aspect = this.computeAspect(shape.style, x, y, w, h, aspect);
  var sx = Math.min(aspect.width, aspect.height);
  sx = "inherit" == this.strokewidth ? Number(mxUtils.getNumber(shape.style, mxConstants.STYLE_STROKEWIDTH, 1)) : Number(this.strokewidth) * sx;
  canvas.setStrokeWidth(sx);
  if (null != shape.style) {
    if ("1" == mxUtils.getValue(shape.style, mxConstants.STYLE_POINTER_EVENTS, "0")) {
      canvas.setStrokeColor(mxConstants.NONE);
      canvas.rect(x, y, w, h);
      canvas.stroke();
      canvas.setStrokeColor(shape.stroke);
    }
  }
  this.drawChildren(canvas, shape, x, y, w, h, this.bgNode, aspect, false, true);
  this.drawChildren(canvas, shape, x, y, w, h, this.fgNode, aspect, true, !shape.outline || (null == shape.style || 0 == mxUtils.getValue(shape.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0)));
  if (canvas.states.length != stack.length) {
    canvas.states = stack;
  }
};
mxStencil.prototype.drawChildren = function(canvas, shape, tmp, y, w, h, node, aspect, disableShadow, paint) {
  if (null != node && (0 < w && 0 < h)) {
    for (tmp = node.firstChild;null != tmp;) {
      if (tmp.nodeType == mxConstants.NODETYPE_ELEMENT) {
        this.drawNode(canvas, shape, tmp, aspect, disableShadow, paint);
      }
      tmp = tmp.nextSibling;
    }
  }
};
mxStencil.prototype.computeAspect = function(x, sx, y, w, h, direction) {
  x = sx;
  sx = w / this.w0;
  var sy = h / this.h0;
  if (direction = direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) {
    sy = w / this.h0;
    sx = h / this.w0;
    var t = (w - h) / 2;
    x += t;
    y -= t;
  }
  if ("fixed" == this.aspect) {
    sx = sy = Math.min(sx, sy);
    if (direction) {
      x += (h - this.w0 * sx) / 2;
      y += (w - this.h0 * sy) / 2;
    } else {
      x += (w - this.w0 * sx) / 2;
      y += (h - this.h0 * sy) / 2;
    }
  }
  return new mxRectangle(x, y, sx, sy);
};
mxStencil.prototype.parseColor = function(canvas, shape, node, flex) {
  if ("stroke" == flex) {
    flex = shape.stroke;
  } else {
    if ("fill" == flex) {
      flex = shape.fill;
    }
  }
  return flex;
};
mxStencil.prototype.drawNode = function(canvas, shape, node, aspect, disableShadow, h) {
  var name = node.nodeName;
  var x0 = aspect.x;
  var y0 = aspect.y;
  var sx = aspect.width;
  var sy = aspect.height;
  var minScale = Math.min(sx, sy);
  if ("save" == name) {
    canvas.save();
  } else {
    if ("restore" == name) {
      canvas.restore();
    } else {
      if (h) {
        if ("path" == name) {
          canvas.begin();
          minScale = true;
          if ("1" == node.getAttribute("rounded")) {
            minScale = false;
            var arcSize = Number(node.getAttribute("arcSize"));
            var r = 0;
            var segs = [];
            for (var childNode = node.firstChild;null != childNode;) {
              if (childNode.nodeType == mxConstants.NODETYPE_ELEMENT) {
                var childName = childNode.nodeName;
                if ("move" == childName || "line" == childName) {
                  if (!("move" != childName && 0 != segs.length)) {
                    segs.push([]);
                  }
                  segs[segs.length - 1].push(new mxPoint(x0 + Number(childNode.getAttribute("x")) * sx, y0 + Number(childNode.getAttribute("y")) * sy));
                  r++;
                } else {
                  minScale = true;
                  break;
                }
              }
              childNode = childNode.nextSibling;
            }
            if (!minScale && 0 < r) {
              for (sx = 0;sx < segs.length;sx++) {
                sy = false;
                y0 = segs[sx][0];
                x0 = segs[sx][segs[sx].length - 1];
                if (y0.x == x0.x) {
                  if (y0.y == x0.y) {
                    segs[sx].pop();
                    sy = true;
                  }
                }
                this.addPoints(canvas, segs[sx], true, arcSize, sy);
              }
            } else {
              minScale = true;
            }
          }
          if (minScale) {
            for (childNode = node.firstChild;null != childNode;) {
              if (childNode.nodeType == mxConstants.NODETYPE_ELEMENT) {
                this.drawNode(canvas, shape, childNode, aspect, disableShadow, h);
              }
              childNode = childNode.nextSibling;
            }
          }
        } else {
          if ("close" == name) {
            canvas.close();
          } else {
            if ("move" == name) {
              canvas.moveTo(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
            } else {
              if ("line" == name) {
                canvas.lineTo(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
              } else {
                if ("quad" == name) {
                  canvas.quadTo(x0 + Number(node.getAttribute("x1")) * sx, y0 + Number(node.getAttribute("y1")) * sy, x0 + Number(node.getAttribute("x2")) * sx, y0 + Number(node.getAttribute("y2")) * sy);
                } else {
                  if ("curve" == name) {
                    canvas.curveTo(x0 + Number(node.getAttribute("x1")) * sx, y0 + Number(node.getAttribute("y1")) * sy, x0 + Number(node.getAttribute("x2")) * sx, y0 + Number(node.getAttribute("y2")) * sy, x0 + Number(node.getAttribute("x3")) * sx, y0 + Number(node.getAttribute("y3")) * sy);
                  } else {
                    if ("arc" == name) {
                      canvas.arcTo(Number(node.getAttribute("rx")) * sx, Number(node.getAttribute("ry")) * sy, Number(node.getAttribute("x-axis-rotation")), Number(node.getAttribute("large-arc-flag")), Number(node.getAttribute("sweep-flag")), x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
                    } else {
                      if ("rect" == name) {
                        canvas.rect(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy);
                      } else {
                        if ("roundrect" == name) {
                          shape = Number(node.getAttribute("arcsize"));
                          if (0 == shape) {
                            shape = 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR;
                          }
                          aspect = Number(node.getAttribute("w")) * sx;
                          h = Number(node.getAttribute("h")) * sy;
                          shape = Number(shape) / 100;
                          shape = Math.min(aspect * shape, h * shape);
                          canvas.roundrect(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, aspect, h, shape, shape);
                        } else {
                          if ("ellipse" == name) {
                            canvas.ellipse(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy);
                          } else {
                            if ("image" == name) {
                              if (!shape.outline) {
                                shape = this.evaluateAttribute(node, "src", shape);
                                canvas.image(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy, shape, false, "1" == node.getAttribute("flipH"), "1" == node.getAttribute("flipV"));
                              }
                            } else {
                              if ("text" == name) {
                                if (!shape.outline) {
                                  aspect = this.evaluateTextAttribute(node, "str", shape);
                                  h = "1" == node.getAttribute("vertical") ? -90 : 0;
                                  if ("0" == node.getAttribute("align-shape")) {
                                    minScale = shape.rotation;
                                    arcSize = 1 == mxUtils.getValue(shape.style, mxConstants.STYLE_FLIPH, 0);
                                    shape = 1 == mxUtils.getValue(shape.style, mxConstants.STYLE_FLIPV, 0);
                                    h = arcSize && shape ? h - minScale : arcSize || shape ? h + minScale : h - minScale;
                                  }
                                  h -= node.getAttribute("rotation");
                                  canvas.text(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, 0, 0, aspect, node.getAttribute("align") || "left", node.getAttribute("valign") || "top", false, "", null, false, h);
                                }
                              } else {
                                if ("include-shape" == name) {
                                  minScale = mxStencilRegistry.getStencil(node.getAttribute("name"));
                                  if (null != minScale) {
                                    x0 += Number(node.getAttribute("x")) * sx;
                                    y0 += Number(node.getAttribute("y")) * sy;
                                    aspect = Number(node.getAttribute("w")) * sx;
                                    h = Number(node.getAttribute("h")) * sy;
                                    minScale.drawShape(canvas, shape, x0, y0, aspect, h);
                                  }
                                } else {
                                  if ("fillstroke" == name) {
                                    canvas.fillAndStroke();
                                  } else {
                                    if ("fill" == name) {
                                      canvas.fill();
                                    } else {
                                      if ("stroke" == name) {
                                        canvas.stroke();
                                      } else {
                                        if ("strokewidth" == name) {
                                          sx = "1" == node.getAttribute("fixed") ? 1 : minScale;
                                          canvas.setStrokeWidth(Number(node.getAttribute("width")) * sx);
                                        } else {
                                          if ("dashed" == name) {
                                            canvas.setDashed("1" == node.getAttribute("dashed"));
                                          } else {
                                            if ("dashpattern" == name) {
                                              if (node = node.getAttribute("pattern"), null != node) {
                                                node = node.split(" ");
                                                sy = [];
                                                for (sx = 0;sx < node.length;sx++) {
                                                  if (0 < node[sx].length) {
                                                    sy.push(Number(node[sx]) * minScale);
                                                  }
                                                }
                                                node = sy.join(" ");
                                                canvas.setDashPattern(node);
                                              }
                                            } else {
                                              if ("strokecolor" == name) {
                                                canvas.setStrokeColor(this.parseColor(canvas, shape, node, node.getAttribute("color")));
                                              } else {
                                                if ("linecap" == name) {
                                                  canvas.setLineCap(node.getAttribute("cap"));
                                                } else {
                                                  if ("linejoin" == name) {
                                                    canvas.setLineJoin(node.getAttribute("join"));
                                                  } else {
                                                    if ("miterlimit" == name) {
                                                      canvas.setMiterLimit(Number(node.getAttribute("limit")));
                                                    } else {
                                                      if ("fillcolor" == name) {
                                                        canvas.setFillColor(this.parseColor(canvas, shape, node, node.getAttribute("color")));
                                                      } else {
                                                        if ("alpha" == name) {
                                                          canvas.setAlpha(node.getAttribute("alpha"));
                                                        } else {
                                                          if ("fillalpha" == name) {
                                                            canvas.setAlpha(node.getAttribute("alpha"));
                                                          } else {
                                                            if ("strokealpha" == name) {
                                                              canvas.setAlpha(node.getAttribute("alpha"));
                                                            } else {
                                                              if ("fontcolor" == name) {
                                                                canvas.setFontColor(this.parseColor(canvas, shape, node, node.getAttribute("color")));
                                                              } else {
                                                                if ("fontstyle" == name) {
                                                                  canvas.setFontStyle(node.getAttribute("style"));
                                                                } else {
                                                                  if ("fontfamily" == name) {
                                                                    canvas.setFontFamily(node.getAttribute("family"));
                                                                  } else {
                                                                    if ("fontsize" == name) {
                                                                      canvas.setFontSize(Number(node.getAttribute("size")) * minScale);
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (!!disableShadow) {
          if (!("fillstroke" != name && ("fill" != name && "stroke" != name))) {
            canvas.setShadow(false);
          }
        }
      }
    }
  }
};
var mxStencilRegistry = {
  stencils : {},
  addStencil : function(name, stencil) {
    mxStencilRegistry.stencils[name] = stencil;
  },
  getStencil : function(name) {
    return mxStencilRegistry.stencils[name];
  }
};
var mxMarker = {
  markers : [],
  addMarker : function(type, funct) {
    mxMarker.markers[type] = funct;
  },
  createMarker : function(c, pts, type, pe, unitX, unitY, size, source, sw, filled) {
    var funct = mxMarker.markers[type];
    return null != funct ? funct(c, pts, type, pe, unitX, unitY, size, source, sw, filled) : null;
  }
};
(function() {
  function createArrow(widthFactor) {
    widthFactor = null != widthFactor ? widthFactor : 2;
    return function(canvas, endOffsetX, type, pe, unitX, unitY, f, endOffsetY, a, flex) {
      endOffsetX = unitX * a * 1.118;
      endOffsetY = unitY * a * 1.118;
      unitX *= f + a;
      unitY *= f + a;
      var pt = pe.clone();
      pt.x -= endOffsetX;
      pt.y -= endOffsetY;
      f = type != mxConstants.ARROW_CLASSIC && type != mxConstants.ARROW_CLASSIC_THIN ? 1 : 0.75;
      pe.x += -unitX * f - endOffsetX;
      pe.y += -unitY * f - endOffsetY;
      return function() {
        canvas.begin();
        canvas.moveTo(pt.x, pt.y);
        canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
        if (!(type != mxConstants.ARROW_CLASSIC && type != mxConstants.ARROW_CLASSIC_THIN)) {
          canvas.lineTo(pt.x - 3 * unitX / 4, pt.y - 3 * unitY / 4);
        }
        canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
        canvas.close();
        if (flex) {
          canvas.fillAndStroke();
        } else {
          canvas.stroke();
        }
      };
    };
  }
  function createOpenArrow(widthFactor) {
    widthFactor = null != widthFactor ? widthFactor : 2;
    return function(canvas, endOffsetX, endOffsetY, pe, unitX, unitY, x, flex, a, editor) {
      endOffsetX = unitX * a * 1.118;
      endOffsetY = unitY * a * 1.118;
      unitX *= x + a;
      unitY *= x + a;
      var pt = pe.clone();
      pt.x -= endOffsetX;
      pt.y -= endOffsetY;
      pe.x += 2 * -endOffsetX;
      pe.y += 2 * -endOffsetY;
      return function() {
        canvas.begin();
        canvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
        canvas.lineTo(pt.x, pt.y);
        canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
        canvas.stroke();
      };
    };
  }
  function diamond(canvas, endOffsetX, type, pe, unitX, unitY, size, endOffsetY, sw, filled) {
    endOffsetY = type == mxConstants.ARROW_DIAMOND ? 0.7071 : 0.9862;
    endOffsetX = unitX * sw * endOffsetY;
    endOffsetY *= unitY * sw;
    unitX *= size + sw;
    unitY *= size + sw;
    var pt = pe.clone();
    pt.x -= endOffsetX;
    pt.y -= endOffsetY;
    pe.x += -unitX - endOffsetX;
    pe.y += -unitY - endOffsetY;
    var tk = type == mxConstants.ARROW_DIAMOND ? 2 : 3.4;
    return function() {
      canvas.begin();
      canvas.moveTo(pt.x, pt.y);
      canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);
      canvas.lineTo(pt.x - unitX, pt.y - unitY);
      canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);
      canvas.close();
      if (filled) {
        canvas.fillAndStroke();
      } else {
        canvas.stroke();
      }
    };
  }
  mxMarker.addMarker("classic", createArrow(2));
  mxMarker.addMarker("classicThin", createArrow(3));
  mxMarker.addMarker("block", createArrow(2));
  mxMarker.addMarker("blockThin", createArrow(3));
  mxMarker.addMarker("open", createOpenArrow(2));
  mxMarker.addMarker("openThin", createOpenArrow(3));
  mxMarker.addMarker("oval", function(canvas, flex, editor, pe, unitX, unitY, w, type, id, eo) {
    var a = w / 2;
    var pt = pe.clone();
    pe.x -= unitX * a;
    pe.y -= unitY * a;
    return function() {
      canvas.ellipse(pt.x - a, pt.y - a, w, w);
      if (eo) {
        canvas.fillAndStroke();
      } else {
        canvas.stroke();
      }
    };
  });
  mxMarker.addMarker("baseDash", function(canvas, type, id, pt, flex, editor, y, eo, dy, layer) {
    var unitX = flex * (y + dy + 1);
    var unitY = editor * (y + dy + 1);
    return function() {
      canvas.begin();
      canvas.moveTo(pt.x - unitY / 2, pt.y + unitX / 2);
      canvas.lineTo(pt.x + unitY / 2, pt.y - unitX / 2);
      canvas.stroke();
    };
  });
  mxMarker.addMarker("doubleBlock", function(canvas, endOffsetX, type, pe, unitX, unitY, x, endOffsetY, a, flex) {
    endOffsetX = unitX * a * 1.118;
    endOffsetY = unitY * a * 1.118;
    unitX *= x + a;
    unitY *= x + a;
    var pt = pe.clone();
    pt.x -= endOffsetX;
    pt.y -= endOffsetY;
    type = type != mxConstants.ARROW_CLASSIC && type != mxConstants.ARROW_CLASSIC_THIN ? 1 : 0.75;
    pe.x += -unitX * type * 2 - endOffsetX;
    pe.y += -unitY * type * 2 - endOffsetY;
    return function() {
      canvas.begin();
      canvas.moveTo(pt.x, pt.y);
      canvas.lineTo(pt.x - unitX - unitY / 2, pt.y - unitY + unitX / 2);
      canvas.lineTo(pt.x + unitY / 2 - unitX, pt.y - unitY - unitX / 2);
      canvas.close();
      canvas.moveTo(pt.x - unitX, pt.y - unitY);
      canvas.lineTo(pt.x - 2 * unitX - 0.5 * unitY, pt.y + 0.5 * unitX - 2 * unitY);
      canvas.lineTo(pt.x - 2 * unitX + 0.5 * unitY, pt.y - 0.5 * unitX - 2 * unitY);
      canvas.close();
      if (flex) {
        canvas.fillAndStroke();
      } else {
        canvas.stroke();
      }
    };
  });
  mxMarker.addMarker("diamond", diamond);
  mxMarker.addMarker("diamondThin", diamond);
})();
function mxActor(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxActor, mxShape);
mxActor.prototype.paintVertexShape = function(c, x, y, w, h) {
  c.translate(x, y);
  c.begin();
  this.redrawPath(c, x, y, w, h);
  c.fillAndStroke();
};
mxActor.prototype.redrawPath = function(c, width, y, w, h) {
  width = w / 3;
  c.moveTo(0, h);
  c.curveTo(0, 3 * h / 5, 0, 2 * h / 5, w / 2, 2 * h / 5);
  c.curveTo(w / 2 - width, 2 * h / 5, w / 2 - width, 0, w / 2, 0);
  c.curveTo(w / 2 + width, 0, w / 2 + width, 2 * h / 5, w / 2, 2 * h / 5);
  c.curveTo(w, 2 * h / 5, w, 3 * h / 5, w, h);
  c.close();
};
function mxCloud(bounds, fill, stroke, strokewidth) {
  mxActor.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxCloud, mxActor);
mxCloud.prototype.redrawPath = function(c, x, y, w, h) {
  c.moveTo(0.25 * w, 0.25 * h);
  c.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);
  c.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);
  c.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);
  c.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);
  c.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);
  c.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);
  c.close();
};
function mxRectangleShape(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxRectangleShape, mxShape);
mxRectangleShape.prototype.isHtmlAllowed = function() {
  var a = true;
  if (null != this.style) {
    a = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
  }
  return!this.isRounded && (!this.glass && (0 == this.rotation && (a || null != this.fill && this.fill != mxConstants.NONE)));
};
mxRectangleShape.prototype.paintBackground = function(c, x, y, w, h) {
  if (this.isRounded) {
    if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
      var dy = Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2))
    } else {
      dy = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
      dy = Math.min(w * dy, h * dy);
    }
    c.roundrect(x, y, w, h, dy, dy);
  } else {
    c.rect(x, y, w, h);
  }
  c.fillAndStroke();
};
mxRectangleShape.prototype.isRoundable = function() {
  return true;
};
mxRectangleShape.prototype.paintForeground = function(c, x, y, w, h) {
  if (this.glass) {
    if (!this.outline) {
      if (null != this.fill) {
        if (this.fill != mxConstants.NONE) {
          this.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokewidth, h + this.strokewidth));
        }
      }
    }
  }
};
function mxEllipse(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxEllipse, mxShape);
mxEllipse.prototype.paintVertexShape = function(c, x, y, w, h) {
  c.ellipse(x, y, w, h);
  c.fillAndStroke();
};
function mxDoubleEllipse(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxDoubleEllipse, mxShape);
mxDoubleEllipse.prototype.paintBackground = function(c, x, y, w, h) {
  c.ellipse(x, y, w, h);
  c.fillAndStroke();
};
mxDoubleEllipse.prototype.paintForeground = function(c, x, y, w, h) {
  if (!this.outline) {
    var margin = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));
    x += margin;
    y += margin;
    w -= 2 * margin;
    h -= 2 * margin;
    if (0 < w) {
      if (0 < h) {
        c.ellipse(x, y, w, h);
      }
    }
    c.stroke();
  }
};
mxDoubleEllipse.prototype.getLabelBounds = function(rect) {
  var margin = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale))) * this.scale;
  return new mxRectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);
};
function mxRhombus(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxRhombus, mxShape);
mxRhombus.prototype.isRoundable = function() {
  return true;
};
mxRhombus.prototype.paintVertexShape = function(c, x, y, w, h) {
  var hw = w / 2;
  var hh = h / 2;
  var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  c.begin();
  this.addPoints(c, [new mxPoint(x + hw, y), new mxPoint(x + w, y + hh), new mxPoint(x + hw, y + h), new mxPoint(x, y + hh)], this.isRounded, arcSize, true);
  c.fillAndStroke();
};
function mxPolyline(points, stroke, strokewidth) {
  mxShape.call(this);
  this.points = points;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxPolyline, mxShape);
mxPolyline.prototype.getRotation = function() {
  return 0;
};
mxPolyline.prototype.getShapeRotation = function() {
  return 0;
};
mxPolyline.prototype.isPaintBoundsInverted = function() {
  return false;
};
mxPolyline.prototype.paintEdgeShape = function(c, pts) {
  var prev = c.pointerEventsValue;
  c.pointerEventsValue = "stroke";
  if (null == this.style || 1 != this.style[mxConstants.STYLE_CURVED]) {
    this.paintLine(c, pts, this.isRounded);
  } else {
    this.paintCurvedLine(c, pts);
  }
  c.pointerEventsValue = prev;
};
mxPolyline.prototype.paintLine = function(c, pts, rounded) {
  var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  c.begin();
  this.addPoints(c, pts, rounded, arcSize, false);
  c.stroke();
};
mxPolyline.prototype.paintCurvedLine = function(c, pts) {
  c.begin();
  var pt = pts[0];
  var idx = pts.length;
  c.moveTo(pt.x, pt.y);
  for (pt = 1;pt < idx - 2;pt++) {
    var p0 = pts[pt];
    var p1 = pts[pt + 1];
    c.quadTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
  }
  p0 = pts[idx - 2];
  p1 = pts[idx - 1];
  c.quadTo(p0.x, p0.y, p1.x, p1.y);
  c.stroke();
};
function mxArrow(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {
  mxShape.call(this);
  this.points = points;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
  this.arrowWidth = null != arrowWidth ? arrowWidth : mxConstants.ARROW_WIDTH;
  this.spacing = null != spacing ? spacing : mxConstants.ARROW_SPACING;
  this.endSize = null != endSize ? endSize : mxConstants.ARROW_SIZE;
}
mxUtils.extend(mxArrow, mxShape);
mxArrow.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  bbox.grow((Math.max(this.arrowWidth, this.endSize) / 2 + this.strokewidth) * this.scale);
};
mxArrow.prototype.paintEdgeShape = function(c, pe) {
  var spacing = mxConstants.ARROW_SPACING;
  var floory = mxConstants.ARROW_WIDTH;
  var p0 = pe[0];
  pe = pe[pe.length - 1];
  var dx = pe.x - p0.x;
  var dy = pe.y - p0.y;
  var floorx = Math.sqrt(dx * dx + dy * dy);
  var y2 = floorx - 2 * spacing - mxConstants.ARROW_SIZE;
  dx /= floorx;
  dy /= floorx;
  floorx = floory * dy / 3;
  floory = -floory * dx / 3;
  var p0x = p0.x - floorx / 2 + spacing * dx;
  p0 = p0.y - floory / 2 + spacing * dy;
  var p1x = p0x + floorx;
  var y = p0 + floory;
  var p2x = p1x + y2 * dx;
  y2 = y + y2 * dy;
  var p3x = p2x + floorx;
  var p3y = y2 + floory;
  var p5x = p3x - 3 * floorx;
  var p5y = p3y - 3 * floory;
  c.begin();
  c.moveTo(p0x, p0);
  c.lineTo(p1x, y);
  c.lineTo(p2x, y2);
  c.lineTo(p3x, p3y);
  c.lineTo(pe.x - spacing * dx, pe.y - spacing * dy);
  c.lineTo(p5x, p5y);
  c.lineTo(p5x + floorx, p5y + floory);
  c.close();
  c.fillAndStroke();
};
function mxArrowConnector(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {
  mxShape.call(this);
  this.points = points;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
  this.arrowWidth = null != arrowWidth ? arrowWidth : mxConstants.ARROW_WIDTH;
  this.arrowSpacing = null != spacing ? spacing : mxConstants.ARROW_SPACING;
  this.startSize = mxConstants.ARROW_SIZE / 5;
  this.endSize = mxConstants.ARROW_SIZE / 5;
}
mxUtils.extend(mxArrowConnector, mxShape);
mxArrowConnector.prototype.useSvgBoundingBox = true;
mxArrowConnector.prototype.isRoundable = function() {
  return true;
};
mxArrowConnector.prototype.resetStyles = function() {
  mxShape.prototype.resetStyles.apply(this, arguments);
  this.arrowSpacing = mxConstants.ARROW_SPACING;
};
mxArrowConnector.prototype.apply = function(state) {
  mxShape.prototype.apply.apply(this, arguments);
  if (null != this.style) {
    this.startSize = 3 * mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5);
    this.endSize = 3 * mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5);
  }
};
mxArrowConnector.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  var w = this.getEdgeWidth();
  if (this.isMarkerStart()) {
    w = Math.max(w, this.getStartArrowWidth());
  }
  if (this.isMarkerEnd()) {
    w = Math.max(w, this.getEndArrowWidth());
  }
  bbox.grow((w / 2 + this.strokewidth) * this.scale);
};
mxArrowConnector.prototype.paintEdgeShape = function(c, pts) {
  var strokeWidth = this.strokewidth;
  if (this.outline) {
    strokeWidth = Math.max(1, mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth));
  }
  var startWidth = this.getStartArrowWidth() + strokeWidth;
  var endWidth = this.getEndArrowWidth() + strokeWidth;
  var edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();
  var openEnded = this.isOpenEnded();
  var markerStart = this.isMarkerStart();
  var markerEnd = this.isMarkerEnd();
  var spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;
  var startSize = this.startSize + strokeWidth;
  strokeWidth = this.endSize + strokeWidth;
  var isRounded = this.isArrowRounded();
  var pe = pts[pts.length - 1];
  var dx = pts[1].x - pts[0].x;
  var dy = pts[1].y - pts[0].y;
  var i = Math.sqrt(dx * dx + dy * dy);
  if (0 != i) {
    var nx = dx / i;
    var nx1 = nx;
    var ny = dy / i;
    var ny1 = ny;
    i = edgeWidth * ny;
    var ix = -edgeWidth * nx;
    var fns = [];
    if (isRounded) {
      c.setLineJoin("round");
    } else {
      if (2 < pts.length) {
        c.setMiterLimit(1.42);
      }
    }
    c.begin();
    dx = nx;
    dy = ny;
    if (markerStart && !openEnded) {
      this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);
    } else {
      var x2 = pts[0].x + i / 2 + spacing * nx;
      var y2 = pts[0].y + ix / 2 + spacing * ny;
      var x1 = pts[0].x - i / 2 + spacing * nx;
      var outStartY = pts[0].y - ix / 2 + spacing * ny;
      if (openEnded) {
        c.moveTo(x2, y2);
        fns.push(function() {
          c.lineTo(x1, outStartY);
        });
      } else {
        c.moveTo(x1, outStartY);
        c.lineTo(x2, y2);
      }
    }
    var tmp = y2 = x2 = 0;
    for (i = 0;i < pts.length - 2;i++) {
      if (ix = mxUtils.relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y), x2 = pts[i + 2].x - pts[i + 1].x, y2 = pts[i + 2].y - pts[i + 1].y, tmp = Math.sqrt(x2 * x2 + y2 * y2), 0 != tmp) {
        nx1 = x2 / tmp;
        ny1 = y2 / tmp;
        tmp = Math.max(Math.sqrt((nx * nx1 + ny * ny1 + 1) / 2), 0.04);
        x2 = nx + nx1;
        y2 = ny + ny1;
        var strokeWidthFactor = Math.sqrt(x2 * x2 + y2 * y2);
        if (0 != strokeWidthFactor) {
          x2 /= strokeWidthFactor;
          y2 /= strokeWidthFactor;
          strokeWidthFactor = Math.max(tmp, Math.min(this.strokewidth / 200 + 0.04, 0.35));
          tmp = 0 != ix && isRounded ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);
          var outX = pts[i + 1].x + y2 * edgeWidth / 2 / tmp;
          var outY = pts[i + 1].y - x2 * edgeWidth / 2 / tmp;
          y2 = pts[i + 1].x - y2 * edgeWidth / 2 / tmp;
          x2 = pts[i + 1].y + x2 * edgeWidth / 2 / tmp;
          if (0 != ix && isRounded) {
            if (-1 == ix) {
              ix = y2 + ny1 * edgeWidth;
              tmp = x2 - nx1 * edgeWidth;
              c.lineTo(y2 + ny * edgeWidth, x2 - nx * edgeWidth);
              c.quadTo(outX, outY, ix, tmp);
              (function(y2, y) {
                fns.push(function() {
                  c.lineTo(y2, y);
                });
              })(y2, x2);
            } else {
              c.lineTo(outX, outY);
              (function(x, x2) {
                var c1x = outX - ny * edgeWidth;
                var y2 = outY + nx * edgeWidth;
                var x1 = outX - ny1 * edgeWidth;
                var y = outY + nx1 * edgeWidth;
                fns.push(function() {
                  c.quadTo(x, x2, c1x, y2);
                });
                fns.push(function() {
                  c.lineTo(x1, y);
                });
              })(y2, x2);
            }
          } else {
            c.lineTo(outX, outY);
            (function(y2, y) {
              fns.push(function() {
                c.lineTo(y2, y);
              });
            })(y2, x2);
          }
          nx = nx1;
          ny = ny1;
        }
      }
    }
    i = edgeWidth * ny1;
    ix = -edgeWidth * nx1;
    if (markerEnd && !openEnded) {
      this.paintMarker(c, pe.x, pe.y, -nx, -ny, strokeWidth, endWidth, edgeWidth, spacing, false);
    } else {
      c.lineTo(pe.x - spacing * nx1 + i / 2, pe.y - spacing * ny1 + ix / 2);
      var value = pe.x - spacing * nx1 - i / 2;
      var y = pe.y - spacing * ny1 - ix / 2;
      if (openEnded) {
        c.moveTo(value, y);
        fns.splice(0, 0, function() {
          c.moveTo(value, y);
        });
      } else {
        c.lineTo(value, y);
      }
    }
    for (i = fns.length - 1;0 <= i;i--) {
      fns[i]();
    }
    if (openEnded) {
      c.end();
      c.stroke();
    } else {
      c.close();
      c.fillAndStroke();
    }
    c.setShadow(false);
    c.setMiterLimit(4);
    if (isRounded) {
      c.setLineJoin("flat");
    }
    if (2 < pts.length) {
      c.setMiterLimit(4);
      if (markerStart) {
        if (!openEnded) {
          c.begin();
          this.paintMarker(c, pts[0].x, pts[0].y, dx, dy, startSize, startWidth, edgeWidth, spacing, true);
          c.stroke();
          c.end();
        }
      }
      if (markerEnd) {
        if (!openEnded) {
          c.begin();
          this.paintMarker(c, pe.x, pe.y, -nx, -ny, strokeWidth, endWidth, edgeWidth, spacing, true);
          c.stroke();
          c.end();
        }
      }
    }
  }
};
mxArrowConnector.prototype.paintMarker = function(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {
  arrowWidth = edgeWidth / arrowWidth;
  var orthx = edgeWidth * ny / 2;
  edgeWidth = -edgeWidth * nx / 2;
  var spaceX = (spacing + size) * nx;
  size = (spacing + size) * ny;
  if (initialMove) {
    c.moveTo(ptX - orthx + spaceX, ptY - edgeWidth + size);
  } else {
    c.lineTo(ptX - orthx + spaceX, ptY - edgeWidth + size);
  }
  c.lineTo(ptX - orthx / arrowWidth + spaceX, ptY - edgeWidth / arrowWidth + size);
  c.lineTo(ptX + spacing * nx, ptY + spacing * ny);
  c.lineTo(ptX + orthx / arrowWidth + spaceX, ptY + edgeWidth / arrowWidth + size);
  c.lineTo(ptX + orthx + spaceX, ptY + edgeWidth + size);
};
mxArrowConnector.prototype.isArrowRounded = function() {
  return this.isRounded;
};
mxArrowConnector.prototype.getStartArrowWidth = function() {
  return mxConstants.ARROW_WIDTH;
};
mxArrowConnector.prototype.getEndArrowWidth = function() {
  return mxConstants.ARROW_WIDTH;
};
mxArrowConnector.prototype.getEdgeWidth = function() {
  return mxConstants.ARROW_WIDTH / 3;
};
mxArrowConnector.prototype.isOpenEnded = function() {
  return false;
};
mxArrowConnector.prototype.isMarkerStart = function() {
  return mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE;
};
mxArrowConnector.prototype.isMarkerEnd = function() {
  return mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE;
};
function mxText(value, bounds, align, valign, color, family, size, fontStyle, spacingRight, spacingBottom, spacing, spacingLeft, spacingTop, horizontal, background, border, wrap, clipped, overflow, labelPadding, textDirection) {
  mxShape.call(this);
  this.value = value;
  this.bounds = bounds;
  this.color = null != color ? color : "black";
  this.align = null != align ? align : mxConstants.ALIGN_CENTER;
  this.valign = null != valign ? valign : mxConstants.ALIGN_MIDDLE;
  this.family = null != family ? family : mxConstants.DEFAULT_FONTFAMILY;
  this.size = null != size ? size : mxConstants.DEFAULT_FONTSIZE;
  this.fontStyle = null != fontStyle ? fontStyle : mxConstants.DEFAULT_FONTSTYLE;
  this.spacing = parseInt(spacingRight || 2);
  this.spacingTop = this.spacing + parseInt(spacingBottom || 0);
  this.spacingRight = this.spacing + parseInt(spacing || 0);
  this.spacingBottom = this.spacing + parseInt(spacingLeft || 0);
  this.spacingLeft = this.spacing + parseInt(spacingTop || 0);
  this.horizontal = null != horizontal ? horizontal : true;
  this.background = background;
  this.border = border;
  this.wrap = null != wrap ? wrap : false;
  this.clipped = null != clipped ? clipped : false;
  this.overflow = null != overflow ? overflow : "visible";
  this.labelPadding = null != labelPadding ? labelPadding : 0;
  this.textDirection = textDirection;
  this.rotation = 0;
  this.updateMargin();
}
mxUtils.extend(mxText, mxShape);
mxText.prototype.baseSpacingTop = 0;
mxText.prototype.baseSpacingBottom = 0;
mxText.prototype.baseSpacingLeft = 0;
mxText.prototype.baseSpacingRight = 0;
mxText.prototype.replaceLinefeeds = true;
mxText.prototype.verticalTextRotation = -90;
mxText.prototype.ignoreClippedStringSize = true;
mxText.prototype.ignoreStringSize = false;
mxText.prototype.textWidthPadding = 8 != document.documentMode || mxClient.IS_EM ? 3 : 4;
mxText.prototype.lastValue = null;
mxText.prototype.cacheEnabled = true;
mxText.prototype.isHtmlAllowed = function() {
  return 8 != document.documentMode || mxClient.IS_EM;
};
mxText.prototype.getSvgScreenOffset = function() {
  return 0;
};
mxText.prototype.checkBounds = function() {
  return!isNaN(this.scale) && (isFinite(this.scale) && (0 < this.scale && (null != this.bounds && (!isNaN(this.bounds.x) && (!isNaN(this.bounds.y) && (!isNaN(this.bounds.width) && !isNaN(this.bounds.height)))))));
};
mxText.prototype.configurePointerEvents = function(c) {
};
mxText.prototype.paint = function(c, update) {
  var h = this.scale;
  var x = this.bounds.x / h;
  var y = this.bounds.y / h;
  var w = this.bounds.width / h;
  h = this.bounds.height / h;
  this.updateTransform(c, x, y, w, h);
  this.configureCanvas(c, x, y, w, h);
  if (update) {
    c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);
  } else {
    var format = (update = mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML) ? "html" : "";
    var val = this.value;
    if (!update) {
      if (!("html" != format)) {
        val = mxUtils.htmlEntities(val, false);
      }
    }
    if (!("html" != format)) {
      if (!mxUtils.isNode(this.value)) {
        val = mxUtils.replaceTrailingNewlines(val, "<div><br></div>");
      }
    }
    val = !mxUtils.isNode(this.value) && (this.replaceLinefeeds && "html" == format) ? val.replace(/\n/g, "<br/>") : val;
    var dir = this.textDirection;
    if (!(dir != mxConstants.TEXT_DIRECTION_AUTO)) {
      if (!update) {
        dir = this.getAutoDirection();
      }
    }
    if (dir != mxConstants.TEXT_DIRECTION_LTR) {
      if (dir != mxConstants.TEXT_DIRECTION_RTL) {
        dir = null;
      }
    }
    c.text(x, y, w, h, val, this.align, this.valign, this.wrap, format, this.overflow, this.clipped, this.getTextRotation(), dir);
  }
};
mxText.prototype.redraw = function() {
  if (this.visible && (this.checkBounds() && (this.cacheEnabled && (this.lastValue == this.value && (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML))))) {
    if ("DIV" == this.node.nodeName) {
      if (mxClient.IS_SVG) {
        this.redrawHtmlShapeWithCss3();
      } else {
        this.updateSize(this.node, null == this.state || null == this.state.view.textDiv);
        if (mxClient.IS_IE && (null == document.documentMode || 8 >= document.documentMode)) {
          this.updateHtmlFilter();
        } else {
          this.updateHtmlTransform();
        }
      }
      this.updateBoundingBox();
    } else {
      var canvas = this.createCanvas();
      if (null != canvas && null != canvas.updateText) {
        canvas.pointerEvents = this.pointerEvents;
        this.paint(canvas, true);
        this.destroyCanvas(canvas);
        this.updateBoundingBox();
      } else {
        mxShape.prototype.redraw.apply(this, arguments);
      }
    }
  } else {
    mxShape.prototype.redraw.apply(this, arguments);
    if (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML) {
      this.lastValue = this.value;
    } else {
      this.lastValue = null;
    }
  }
};
mxText.prototype.resetStyles = function() {
  mxShape.prototype.resetStyles.apply(this, arguments);
  this.color = "black";
  this.align = mxConstants.ALIGN_CENTER;
  this.valign = mxConstants.ALIGN_MIDDLE;
  this.family = mxConstants.DEFAULT_FONTFAMILY;
  this.size = mxConstants.DEFAULT_FONTSIZE;
  this.fontStyle = mxConstants.DEFAULT_FONTSTYLE;
  this.spacingLeft = this.spacingBottom = this.spacingRight = this.spacingTop = this.spacing = 2;
  this.horizontal = true;
  delete this.background;
  delete this.border;
  this.textDirection = mxConstants.DEFAULT_TEXT_DIRECTION;
  delete this.margin;
};
mxText.prototype.apply = function(state) {
  var old = this.spacing;
  mxShape.prototype.apply.apply(this, arguments);
  if (null != this.style) {
    this.fontStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSTYLE, this.fontStyle);
    this.family = mxUtils.getValue(this.style, mxConstants.STYLE_FONTFAMILY, this.family);
    this.size = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, this.size);
    this.color = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, this.color);
    this.align = mxUtils.getValue(this.style, mxConstants.STYLE_ALIGN, this.align);
    this.valign = mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_ALIGN, this.valign);
    this.spacing = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing));
    this.spacingTop = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_TOP, this.spacingTop - old)) + this.spacing;
    this.spacingRight = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_RIGHT, this.spacingRight - old)) + this.spacing;
    this.spacingBottom = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_BOTTOM, this.spacingBottom - old)) + this.spacing;
    this.spacingLeft = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_LEFT, this.spacingLeft - old)) + this.spacing;
    this.horizontal = mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, this.horizontal);
    this.background = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, this.background);
    this.border = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BORDERCOLOR, this.border);
    this.textDirection = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
    this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_OPACITY, 100);
    this.updateMargin();
  }
  this.flipH = this.flipV = null;
};
mxText.prototype.getAutoDirection = function() {
  var tmp = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(this.value);
  return null != tmp && (0 < tmp.length && "z" < tmp[0]) ? mxConstants.TEXT_DIRECTION_RTL : mxConstants.TEXT_DIRECTION_LTR;
};
mxText.prototype.getContentNode = function() {
  var result = this.node;
  if (null != result) {
    result = null == result.ownerSVGElement ? this.node.firstChild.firstChild : result.firstChild.firstChild.firstChild.firstChild.firstChild;
  }
  return result;
};
mxText.prototype.updateBoundingBox = function() {
  var node = this.node;
  this.boundingBox = this.bounds.clone();
  var bbox = this.getTextRotation();
  var td = null != this.style ? mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER) : null;
  var oh = null != this.style ? mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE) : null;
  if (!(this.ignoreStringSize || (null == node || ("fill" == this.overflow || this.clipped && (this.ignoreClippedStringSize && (td == mxConstants.ALIGN_CENTER && oh == mxConstants.ALIGN_MIDDLE)))))) {
    oh = td = null;
    if (null != node.ownerSVGElement) {
      if (null != node.firstChild && (null != node.firstChild.firstChild && "foreignObject" == node.firstChild.firstChild.nodeName)) {
        node = node.firstChild.firstChild.firstChild.firstChild;
        oh = node.offsetHeight * this.scale;
        td = "width" == this.overflow ? this.boundingBox.width : node.offsetWidth * this.scale;
      } else {
        try {
          var sizeDiv = node.getBBox();
          if ("string" == typeof this.value && 0 == mxUtils.trim(this.value)) {
            this.boundingBox = null;
          } else {
            this.boundingBox = 0 == sizeDiv.width && 0 == sizeDiv.height ? null : new mxRectangle(sizeDiv.x, sizeDiv.y, sizeDiv.width, sizeDiv.height);
          }
          return;
        } catch (f) {
        }
      }
    } else {
      td = null != this.state ? this.state.view.textDiv : null;
      if (null == this.offsetWidth || null == this.offsetHeight) {
        if (null != td) {
          this.updateFont(td);
          this.updateSize(td, false);
          this.updateInnerHtml(td);
          node = td;
        }
        sizeDiv = node;
        if (8 != document.documentMode || mxClient.IS_EM) {
          if (null != sizeDiv.firstChild) {
            if ("DIV" == sizeDiv.firstChild.nodeName) {
              sizeDiv = sizeDiv.firstChild;
            }
          }
        } else {
          oh = Math.round(this.bounds.width / this.scale);
          if (this.wrap && 0 < oh) {
            node.style.wordWrap = mxConstants.WORD_WRAP;
            node.style.whiteSpace = "normal";
            if ("break-word" != node.style.wordWrap) {
              node = sizeDiv.getElementsByTagName("div");
              if (0 < node.length) {
                sizeDiv = node[node.length - 1];
              }
              td = sizeDiv.offsetWidth + 2;
              node = this.node.getElementsByTagName("div");
              if (this.clipped) {
                td = Math.min(oh, td);
              }
              if (1 < node.length) {
                node[node.length - 2].style.width = td + "px";
              }
            }
          } else {
            node.style.whiteSpace = "nowrap";
          }
        }
        this.offsetWidth = sizeDiv.offsetWidth + this.textWidthPadding;
        this.offsetHeight = sizeDiv.offsetHeight;
      }
      td = this.offsetWidth * this.scale;
      oh = this.offsetHeight * this.scale;
    }
    if (null != td) {
      if (null != oh) {
        this.boundingBox = new mxRectangle(this.bounds.x, this.bounds.y, td, oh);
      }
    }
  }
  if (null != this.boundingBox) {
    if (0 != bbox) {
      bbox = mxUtils.getBoundingBox(new mxRectangle(this.margin.x * this.boundingBox.width, this.margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), bbox, new mxPoint(0, 0));
      this.unrotatedBoundingBox = mxRectangle.fromRectangle(this.boundingBox);
      this.unrotatedBoundingBox.x += this.margin.x * this.unrotatedBoundingBox.width;
      this.unrotatedBoundingBox.y += this.margin.y * this.unrotatedBoundingBox.height;
      this.boundingBox.x += bbox.x;
      this.boundingBox.y += bbox.y;
      this.boundingBox.width = bbox.width;
      this.boundingBox.height = bbox.height;
    } else {
      this.boundingBox.x += this.margin.x * this.boundingBox.width;
      this.boundingBox.y += this.margin.y * this.boundingBox.height;
      this.unrotatedBoundingBox = null;
    }
  }
};
mxText.prototype.getShapeRotation = function() {
  return 0;
};
mxText.prototype.getTextRotation = function() {
  return null != this.state && null != this.state.shape ? this.state.shape.getTextRotation() : 0;
};
mxText.prototype.isPaintBoundsInverted = function() {
  return!this.horizontal && (null != this.state && this.state.view.graph.model.isVertex(this.state.cell));
};
mxText.prototype.configureCanvas = function(c, x, y, w, h) {
  mxShape.prototype.configureCanvas.apply(this, arguments);
  c.setFontColor(this.color);
  c.setFontBackgroundColor(this.background);
  c.setFontBorderColor(this.border);
  c.setFontFamily(this.family);
  c.setFontSize(this.size);
  c.setFontStyle(this.fontStyle);
};
mxText.prototype.getHtmlValue = function() {
  var val = this.value;
  if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
    val = mxUtils.htmlEntities(val, false);
  }
  val = mxUtils.replaceTrailingNewlines(val, "<div><br></div>");
  return val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
};
mxText.prototype.getTextCss = function() {
  var css = "display: inline-block; font-size: " + this.size + "px; font-family: " + this.family + "; color: " + this.color + "; line-height: " + (mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT) + "; pointer-events: " + (this.pointerEvents ? "all" : "none") + "; ";
  if ((this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
    css += "font-weight: bold; ";
  }
  if ((this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
    css += "font-style: italic; ";
  }
  var txtDecor = [];
  if ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    txtDecor.push("underline");
  }
  if ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    txtDecor.push("line-through");
  }
  if (0 < txtDecor.length) {
    css += "text-decoration: " + txtDecor.join(" ") + "; ";
  }
  return css;
};
mxText.prototype.redrawHtmlShape = function() {
  if (mxClient.IS_SVG) {
    this.redrawHtmlShapeWithCss3();
  } else {
    var style = this.node.style;
    style.whiteSpace = "normal";
    style.overflow = "";
    style.width = "";
    style.height = "";
    this.updateValue();
    this.updateFont(this.node);
    this.updateSize(this.node, null == this.state || null == this.state.view.textDiv);
    this.offsetHeight = this.offsetWidth = null;
    if (mxClient.IS_IE && (null == document.documentMode || 8 >= document.documentMode)) {
      this.updateHtmlFilter();
    } else {
      this.updateHtmlTransform();
    }
  }
};
mxText.prototype.redrawHtmlShapeWithCss3 = function() {
  var w = Math.max(0, Math.round(this.bounds.width / this.scale));
  var h = Math.max(0, Math.round(this.bounds.height / this.scale));
  var flex = "position: absolute; left: " + Math.round(this.bounds.x) + "px; top: " + Math.round(this.bounds.y) + "px; pointer-events: none; ";
  var border = this.getTextCss();
  mxSvgCanvas2D.createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, null != this.background ? mxUtils.htmlEntities(this.background) : null, null != this.border ? mxUtils.htmlEntities(this.border) : null, flex, border, this.scale, mxUtils.bind(this, function(tr, flex, value, item, name, editor) {
    tr = this.getTextRotation();
    tr = (1 != this.scale ? "scale(" + this.scale + ") " : "") + (0 != tr ? "rotate(" + tr + "deg) " : "") + (0 != this.margin.x || 0 != this.margin.y ? "translate(" + 100 * this.margin.x + "%," + 100 * this.margin.y + "%)" : "");
    if ("" != tr) {
      tr = "transform-origin: 0 0; transform: " + tr + "; ";
    }
    if ("block" == this.overflow) {
      if (this.valign == mxConstants.ALIGN_MIDDLE) {
        tr += "max-height: " + (h + 1) + "px;";
      }
    }
    if ("" == editor) {
      value += item;
      item = "display:inline-block; min-width: 100%; " + tr;
    } else {
      item += tr;
      if (mxClient.IS_SF) {
        item += "-webkit-clip-path: content-box;";
      }
    }
    if ("block" == this.overflow) {
      item += "width: 100%; ";
    }
    if (100 > this.opacity) {
      name += "opacity: " + this.opacity / 100 + "; ";
    }
    this.node.setAttribute("style", value);
    value = mxUtils.isNode(this.value) ? this.value.outerHTML : this.getHtmlValue();
    if (null == this.node.firstChild) {
      this.node.innerHTML = "<div><div>" + value + "</div></div>";
      if (mxClient.IS_IE11) {
        this.fixFlexboxForIe11(this.node);
      }
    }
    this.node.firstChild.firstChild.setAttribute("style", name);
    this.node.firstChild.setAttribute("style", item);
  }));
};
mxText.prototype.fixFlexboxForIe11 = function(dx) {
  var internalNodes = dx.querySelectorAll('div[style*="display: flex; justify-content: flex-end;"]');
  for (var i = 0;i < internalNodes.length;i++) {
    internalNodes[i].style.justifyContent = "flex-start";
    internalNodes[i].style.flexDirection = "row-reverse";
  }
  if (!this.wrap) {
    internalNodes = dx.querySelectorAll('div[style*="display: flex; justify-content: center;"]');
    dx = -window.innerWidth;
    for (i = 0;i < internalNodes.length;i++) {
      internalNodes[i].style.marginLeft = dx + "px";
      internalNodes[i].style.marginRight = dx + "px";
    }
  }
};
mxText.prototype.updateHtmlTransform = function() {
  var theta = this.getTextRotation();
  var style = this.node.style;
  var dx = this.margin.x;
  var dy = this.margin.y;
  if (0 != theta) {
    mxUtils.setPrefixedStyle(style, "transformOrigin", 100 * -dx + "% " + 100 * -dy + "%");
    mxUtils.setPrefixedStyle(style, "transform", "translate(" + 100 * dx + "%," + 100 * dy + "%) scale(" + this.scale + ") rotate(" + theta + "deg)");
  } else {
    mxUtils.setPrefixedStyle(style, "transformOrigin", "0% 0%");
    mxUtils.setPrefixedStyle(style, "transform", "scale(" + this.scale + ") translate(" + 100 * dx + "%," + 100 * dy + "%)");
  }
  style.left = Math.round(this.bounds.x - Math.ceil(dx * ("fill" != this.overflow && "width" != this.overflow ? 3 : 1))) + "px";
  style.top = Math.round(this.bounds.y - dy * ("fill" != this.overflow ? 3 : 1)) + "px";
  style.opacity = 100 > this.opacity ? this.opacity / 100 : "";
};
mxText.prototype.updateInnerHtml = function(elt) {
  if (mxUtils.isNode(this.value)) {
    elt.innerHTML = this.value.outerHTML;
  } else {
    var val = this.value;
    if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
      val = mxUtils.htmlEntities(val, false);
    }
    val = mxUtils.replaceTrailingNewlines(val, "<div>&nbsp;</div>");
    val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
    elt.innerHTML = '<div style="display:inline-block;_display:inline;">' + val + "</div>";
  }
};
mxText.prototype.updateHtmlFilter = function() {
  var style = this.node.style;
  var dx = this.margin.x;
  var dy = this.margin.y;
  var s = this.scale;
  mxUtils.setOpacity(this.node, this.opacity);
  var oh = 0;
  var td = null != this.state ? this.state.view.textDiv : null;
  var sizeDiv = this.node;
  if (null != td) {
    td.style.overflow = "";
    td.style.height = "";
    td.style.width = "";
    this.updateFont(td);
    this.updateSize(td, false);
    this.updateInnerHtml(td);
    var w = Math.round(this.bounds.width / this.scale);
    if (this.wrap && 0 < w) {
      td.style.whiteSpace = "normal";
      td.style.wordWrap = mxConstants.WORD_WRAP;
      var ow = w;
      if (this.clipped) {
        ow = Math.min(ow, this.bounds.width);
      }
      td.style.width = ow + "px";
    } else {
      td.style.whiteSpace = "nowrap";
    }
    sizeDiv = td;
    if (null != sizeDiv.firstChild) {
      if ("DIV" == sizeDiv.firstChild.nodeName) {
        sizeDiv = sizeDiv.firstChild;
        if (this.wrap) {
          if ("break-word" == td.style.wordWrap) {
            sizeDiv.style.width = "100%";
          }
        }
      }
    }
    if (!this.clipped) {
      if (this.wrap) {
        if (0 < w) {
          ow = sizeDiv.offsetWidth + this.textWidthPadding;
          td.style.width = ow + "px";
        }
      }
    }
    oh = sizeDiv.offsetHeight + 2;
  } else {
    if (null != sizeDiv.firstChild) {
      if ("DIV" == sizeDiv.firstChild.nodeName) {
        sizeDiv = sizeDiv.firstChild;
        oh = sizeDiv.offsetHeight;
      }
    }
  }
  ow = sizeDiv.offsetWidth + this.textWidthPadding;
  if (this.clipped) {
    oh = Math.min(oh, this.bounds.height);
  }
  w = this.bounds.width / s;
  td = this.bounds.height / s;
  if ("fill" == this.overflow) {
    oh = td;
    ow = w;
  } else {
    if ("width" == this.overflow) {
      oh = sizeDiv.scrollHeight;
      ow = w;
    }
  }
  this.offsetWidth = ow;
  this.offsetHeight = oh;
  if ("fill" != this.overflow) {
    if ("width" != this.overflow) {
      if (this.clipped) {
        ow = Math.min(w, ow);
      }
      w = ow;
      if (this.wrap) {
        style.width = Math.round(w) + "px";
      }
    }
  }
  td = oh * s;
  w *= s;
  var rad = this.getTextRotation() * (Math.PI / 180);
  ow = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));
  oh = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));
  rad %= 2 * Math.PI;
  if (0 > rad) {
    rad += 2 * Math.PI;
  }
  rad %= Math.PI;
  if (rad > Math.PI / 2) {
    rad = Math.PI - rad;
  }
  sizeDiv = Math.cos(rad);
  var sin = Math.sin(-rad);
  dx = w * -(dx + 0.5);
  dy = td * -(dy + 0.5);
  if (0 != rad) {
    rad = "progid:DXImageTransform.Microsoft.Matrix(M11=" + ow + ", M12=" + oh + ", M21=" + -oh + ", M22=" + ow + ", sizingMethod='auto expand')";
    style.filter = null != style.filter && 0 < style.filter.length ? style.filter + (" " + rad) : rad;
  }
  style.zoom = s;
  style.left = Math.round(this.bounds.x + ((w - w * sizeDiv + td * sin) / 2 - ow * dx - oh * dy) - w / 2) + "px";
  style.top = Math.round(this.bounds.y + ((td - td * sizeDiv + w * sin) / 2 + oh * dx - ow * dy) - td / 2) + "px";
};
mxText.prototype.updateValue = function() {
  if (mxUtils.isNode(this.value)) {
    this.node.innerText = "";
    this.node.appendChild(this.value);
  } else {
    var val = this.value;
    if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
      val = mxUtils.htmlEntities(val, false);
    }
    val = mxUtils.replaceTrailingNewlines(val, "<div><br></div>");
    val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
    var value = null != this.background && this.background != mxConstants.NONE ? this.background : null;
    var bd = null != this.border && this.border != mxConstants.NONE ? this.border : null;
    if ("fill" == this.overflow || "width" == this.overflow) {
      if (null != value) {
        this.node.style.backgroundColor = value;
      }
      if (null != bd) {
        this.node.style.border = "1px solid " + bd;
      }
    } else {
      var css = "";
      if (null != value) {
        css += "background-color:" + mxUtils.htmlEntities(value) + ";";
      }
      if (null != bd) {
        css += "border:1px solid " + mxUtils.htmlEntities(bd) + ";";
      }
      val = '<div style="zoom:1;' + css + "display:inline-block;_display:inline;text-decoration:inherit;padding-bottom:1px;padding-right:1px;line-height:" + (mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT) + '">' + val + "</div>";
    }
    this.node.innerHTML = val;
    val = this.node.getElementsByTagName("div");
    if (0 < val.length) {
      value = this.textDirection;
      if (value == mxConstants.TEXT_DIRECTION_AUTO) {
        if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
          value = this.getAutoDirection();
        }
      }
      if (value == mxConstants.TEXT_DIRECTION_LTR || value == mxConstants.TEXT_DIRECTION_RTL) {
        val[val.length - 1].setAttribute("dir", value);
      } else {
        val[val.length - 1].removeAttribute("dir");
      }
    }
  }
};
mxText.prototype.updateFont = function(style) {
  style = style.style;
  style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
  style.fontSize = this.size + "px";
  style.fontFamily = this.family;
  style.verticalAlign = "top";
  style.color = this.color;
  style.fontWeight = (this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD ? "bold" : "";
  style.fontStyle = (this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC ? "italic" : "";
  var txtDecor = [];
  if ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    txtDecor.push("underline");
  }
  if ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    txtDecor.push("line-through");
  }
  style.textDecoration = txtDecor.join(" ");
  style.textAlign = this.align == mxConstants.ALIGN_CENTER ? "center" : this.align == mxConstants.ALIGN_RIGHT ? "right" : "left";
};
mxText.prototype.updateSize = function(node, sizeDiv) {
  var w = Math.max(0, Math.round(this.bounds.width / this.scale));
  var tmp = Math.max(0, Math.round(this.bounds.height / this.scale));
  var style = node.style;
  if (this.clipped) {
    style.overflow = "hidden";
    style.maxHeight = tmp + "px";
    style.maxWidth = w + "px";
  } else {
    if ("fill" == this.overflow) {
      style.width = w + 1 + "px";
      style.height = tmp + 1 + "px";
      style.overflow = "hidden";
    } else {
      if ("width" == this.overflow) {
        style.width = w + 1 + "px";
        style.maxHeight = tmp + 1 + "px";
        style.overflow = "hidden";
      } else {
        if ("block" == this.overflow) {
          style.width = w + 1 + "px";
        }
      }
    }
  }
  if (this.wrap && 0 < w) {
    if (style.wordWrap = mxConstants.WORD_WRAP, style.whiteSpace = "normal", style.width = w + "px", sizeDiv && ("fill" != this.overflow && "width" != this.overflow)) {
      sizeDiv = node;
      if (null != sizeDiv.firstChild) {
        if ("DIV" == sizeDiv.firstChild.nodeName) {
          sizeDiv = sizeDiv.firstChild;
          if ("break-word" == node.style.wordWrap) {
            sizeDiv.style.width = "100%";
          }
        }
      }
      tmp = sizeDiv.offsetWidth;
      if (0 == tmp) {
        var prev = node.parentNode;
        node.style.visibility = "hidden";
        document.body.appendChild(node);
        tmp = sizeDiv.offsetWidth;
        node.style.visibility = "";
        prev.appendChild(node);
      }
      tmp += 3;
      if (this.clipped) {
        tmp = Math.min(tmp, w);
      }
      style.width = tmp + "px";
    }
  } else {
    style.whiteSpace = "nowrap";
  }
};
mxText.prototype.updateMargin = function() {
  this.margin = mxUtils.getAlignmentAsPoint(this.align, this.valign);
};
mxText.prototype.getSpacing = function(flex) {
  return new mxPoint(this.align == mxConstants.ALIGN_CENTER ? (this.spacingLeft - this.spacingRight) / 2 : this.align == mxConstants.ALIGN_RIGHT ? -this.spacingRight - (flex ? 0 : this.baseSpacingRight) : this.spacingLeft + (flex ? 0 : this.baseSpacingLeft), this.valign == mxConstants.ALIGN_MIDDLE ? (this.spacingTop - this.spacingBottom) / 2 : this.valign == mxConstants.ALIGN_BOTTOM ? -this.spacingBottom - (flex ? 0 : this.baseSpacingBottom) : this.spacingTop + (flex ? 0 : this.baseSpacingTop));
};
function mxTriangle() {
  mxActor.call(this);
}
mxUtils.extend(mxTriangle, mxActor);
mxTriangle.prototype.isRoundable = function() {
  return true;
};
mxTriangle.prototype.redrawPath = function(c, x, y, w, h) {
  x = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  this.addPoints(c, [new mxPoint(0, 0), new mxPoint(w, 0.5 * h), new mxPoint(0, h)], this.isRounded, x, true);
};
function mxHexagon() {
  mxActor.call(this);
}
mxUtils.extend(mxHexagon, mxActor);
mxHexagon.prototype.redrawPath = function(c, x, y, w, h) {
  x = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  this.addPoints(c, [new mxPoint(0.25 * w, 0), new mxPoint(0.75 * w, 0), new mxPoint(w, 0.5 * h), new mxPoint(0.75 * w, h), new mxPoint(0.25 * w, h), new mxPoint(0, 0.5 * h)], this.isRounded, x, true);
};
function mxLine(bounds, stroke, strokewidth, vertical) {
  mxShape.call(this);
  this.bounds = bounds;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
  this.vertical = null != vertical ? vertical : this.vertical;
}
mxUtils.extend(mxLine, mxShape);
mxLine.prototype.vertical = false;
mxLine.prototype.paintVertexShape = function(c, x, y, w, h) {
  c.begin();
  if (this.vertical) {
    var y2 = x + w / 2;
    c.moveTo(y2, y);
    c.lineTo(y2, y + h);
  } else {
    y2 = y + h / 2;
    c.moveTo(x, y2);
    c.lineTo(x + w, y2);
  }
  c.stroke();
};
function mxImageShape(bounds, image, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.image = image;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
  this.shadow = false;
}
mxUtils.extend(mxImageShape, mxRectangleShape);
mxImageShape.prototype.preserveImageAspect = true;
mxImageShape.prototype.getSvgScreenOffset = function() {
  return 0;
};
mxImageShape.prototype.apply = function(state) {
  mxShape.prototype.apply.apply(this, arguments);
  this.gradient = this.stroke = this.fill = null;
  if (null != this.style) {
    this.preserveImageAspect = 1 == mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_ASPECT, 1);
    this.imageBackground = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null);
    this.imageBorder = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);
    this.flipH = this.flipH || 1 == mxUtils.getValue(this.style, "imageFlipH", 0);
    this.flipV = this.flipV || 1 == mxUtils.getValue(this.style, "imageFlipV", 0);
    this.clipPath = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null);
  }
};
mxImageShape.prototype.isHtmlAllowed = function() {
  return!this.preserveImageAspect;
};
mxImageShape.prototype.createHtml = function() {
  var node = document.createElement("div");
  node.style.position = "absolute";
  return node;
};
mxImageShape.prototype.isRoundable = function() {
  return false;
};
mxImageShape.prototype.getImageDataUri = function() {
  return this.image;
};
mxImageShape.prototype.configurePointerEvents = function(c) {
};
mxImageShape.prototype.paintVertexShape = function(c, x, y, w, h) {
  if (null != this.image) {
    if (null != this.imageBackground) {
      c.setFillColor(this.imageBackground);
      c.setStrokeColor(this.imageBorder);
      c.rect(x, y, w, h);
      c.fillAndStroke();
    }
    c.image(x, y, w, h, this.getImageDataUri(), this.preserveImageAspect, false, false, this.clipPath);
    if (null != this.imageBorder) {
      c.setShadow(false);
      c.setStrokeColor(this.imageBorder);
      c.rect(x, y, w, h);
      c.stroke();
    }
  } else {
    mxRectangleShape.prototype.paintBackground.apply(this, arguments);
  }
};
mxImageShape.prototype.redrawHtmlShape = function() {
  this.node.style.left = Math.round(this.bounds.x) + "px";
  this.node.style.top = Math.round(this.bounds.y) + "px";
  this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + "px";
  this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + "px";
  this.node.innerText = "";
  if (null != this.image) {
    var img = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, "");
    var stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, "");
    this.node.style.backgroundColor = img;
    this.node.style.borderColor = stroke;
    img = document.createElement("img");
    img.setAttribute("border", "0");
    img.style.position = "absolute";
    img.src = this.image;
    stroke = 100 > this.opacity ? "alpha(opacity=" + this.opacity + ")" : "";
    this.node.style.filter = stroke;
    if (this.flipH && this.flipV) {
      stroke += "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
    } else {
      if (this.flipH) {
        stroke += "progid:DXImageTransform.Microsoft.BasicImage(mirror=1)";
      } else {
        if (this.flipV) {
          stroke += "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
        }
      }
    }
    if (img.style.filter != stroke) {
      img.style.filter = stroke;
    }
    if ("image" == img.nodeName) {
      img.style.rotation = this.rotation;
    } else {
      if (0 != this.rotation) {
        mxUtils.setPrefixedStyle(img.style, "transform", "rotate(" + this.rotation + "deg)");
      } else {
        mxUtils.setPrefixedStyle(img.style, "transform", "");
      }
    }
    img.style.width = this.node.style.width;
    img.style.height = this.node.style.height;
    this.node.style.backgroundImage = "";
    this.node.appendChild(img);
  } else {
    this.setTransparentBackgroundImage(this.node);
  }
};
function mxLabel(bounds, fill, stroke, strokewidth) {
  mxRectangleShape.call(this, bounds, fill, stroke, strokewidth);
}
mxUtils.extend(mxLabel, mxRectangleShape);
mxLabel.prototype.imageSize = mxConstants.DEFAULT_IMAGESIZE;
mxLabel.prototype.spacing = 2;
mxLabel.prototype.indicatorSize = 10;
mxLabel.prototype.indicatorSpacing = 2;
mxLabel.prototype.init = function(container) {
  mxShape.prototype.init.apply(this, arguments);
  if (null != this.indicatorShape) {
    this.indicator = new this.indicatorShape;
    this.indicator.dialect = this.dialect;
    this.indicator.init(this.node);
  }
};
mxLabel.prototype.redraw = function() {
  if (null != this.indicator) {
    this.indicator.fill = this.indicatorColor;
    this.indicator.stroke = this.indicatorStrokeColor;
    this.indicator.gradient = this.indicatorGradientColor;
    this.indicator.direction = this.indicatorDirection;
    this.indicator.redraw();
  }
  mxShape.prototype.redraw.apply(this, arguments);
};
mxLabel.prototype.isHtmlAllowed = function() {
  return mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) && (null == this.indicatorColor && null == this.indicatorShape);
};
mxLabel.prototype.paintForeground = function(c, x, y, w, h) {
  this.paintImage(c, x, y, w, h);
  this.paintIndicator(c, x, y, w, h);
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
mxLabel.prototype.paintImage = function(c, bounds, y, w, h) {
  if (null != this.image) {
    bounds = this.getImageBounds(bounds, y, w, h);
    y = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null);
    c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.image, false, false, false, y);
  }
};
mxLabel.prototype.getImageBounds = function(x, y, w, h) {
  var align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);
  var valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
  var width = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_WIDTH, mxConstants.DEFAULT_IMAGESIZE);
  var height = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_HEIGHT, mxConstants.DEFAULT_IMAGESIZE);
  var spacing = mxUtils.getNumber(this.style, mxConstants.STYLE_SPACING, this.spacing) + 5;
  x = align == mxConstants.ALIGN_CENTER ? x + (w - width) / 2 : align == mxConstants.ALIGN_RIGHT ? x + (w - width - spacing) : x + spacing;
  y = valign == mxConstants.ALIGN_TOP ? y + spacing : valign == mxConstants.ALIGN_BOTTOM ? y + (h - height - spacing) : y + (h - height) / 2;
  return new mxRectangle(x, y, width, height);
};
mxLabel.prototype.paintIndicator = function(c, bounds, y, w, h) {
  if (null != this.indicator) {
    this.indicator.bounds = this.getIndicatorBounds(bounds, y, w, h);
    this.indicator.paint(c);
  } else {
    if (null != this.indicatorImage) {
      bounds = this.getIndicatorBounds(bounds, y, w, h);
      c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImage, false, false, false);
    }
  }
};
mxLabel.prototype.getIndicatorBounds = function(x, y, w, h) {
  var align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);
  var valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
  var width = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_WIDTH, this.indicatorSize);
  var height = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_HEIGHT, this.indicatorSize);
  var spacing = this.spacing + 5;
  x = align == mxConstants.ALIGN_RIGHT ? x + (w - width - spacing) : align == mxConstants.ALIGN_CENTER ? x + (w - width) / 2 : x + spacing;
  y = valign == mxConstants.ALIGN_BOTTOM ? y + (h - height - spacing) : valign == mxConstants.ALIGN_TOP ? y + spacing : y + (h - height) / 2;
  return new mxRectangle(x, y, width, height);
};
mxLabel.prototype.redrawHtmlShape = function() {
  for (mxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments);this.node.hasChildNodes();) {
    this.node.removeChild(this.node.lastChild);
  }
  if (null != this.image) {
    var node = document.createElement("img");
    node.style.position = "relative";
    node.setAttribute("border", "0");
    var bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
    bounds.x -= this.bounds.x;
    bounds.y -= this.bounds.y;
    node.style.left = Math.round(bounds.x) + "px";
    node.style.top = Math.round(bounds.y) + "px";
    node.style.width = Math.round(bounds.width) + "px";
    node.style.height = Math.round(bounds.height) + "px";
    node.src = this.image;
    this.node.appendChild(node);
  }
};
function mxCylinder(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxCylinder, mxShape);
mxCylinder.prototype.maxHeight = 40;
mxCylinder.prototype.paintVertexShape = function(c, x, y, w, h) {
  c.translate(x, y);
  c.begin();
  this.redrawPath(c, x, y, w, h, false);
  c.fillAndStroke();
  if (!(this.outline && (null != this.style && 0 != mxUtils.getValue(this.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0)))) {
    c.setShadow(false);
    c.begin();
    this.redrawPath(c, x, y, w, h, true);
    c.stroke();
  }
};
mxCylinder.prototype.getCylinderSize = function(x, y, w, h) {
  return Math.min(this.maxHeight, Math.round(h / 5));
};
mxCylinder.prototype.redrawPath = function(c, dy, y, w, h, isForeground) {
  dy = this.getCylinderSize(dy, y, w, h);
  if (isForeground && null != this.fill || !isForeground && null == this.fill) {
    c.moveTo(0, dy);
    c.curveTo(0, 2 * dy, w, 2 * dy, w, dy);
    if (!isForeground) {
      c.stroke();
      c.begin();
    }
  }
  if (!isForeground) {
    c.moveTo(0, dy);
    c.curveTo(0, -dy / 3, w, -dy / 3, w, dy);
    c.lineTo(w, h - dy);
    c.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);
    c.close();
  }
};
function mxConnector(points, stroke, strokewidth) {
  mxPolyline.call(this, points, stroke, strokewidth);
}
mxUtils.extend(mxConnector, mxPolyline);
mxConnector.prototype.updateBoundingBox = function() {
  this.useSvgBoundingBox = null != this.style && 1 == this.style[mxConstants.STYLE_CURVED];
  mxShape.prototype.updateBoundingBox.apply(this, arguments);
};
mxConnector.prototype.paintEdgeShape = function(c, pts) {
  var sourceMarker = this.createMarker(c, pts, true);
  var targetMarker = this.createMarker(c, pts, false);
  mxPolyline.prototype.paintEdgeShape.apply(this, arguments);
  c.setFillColor(this.stroke);
  c.setShadow(false);
  c.setDashed(false);
  if (null != sourceMarker) {
    sourceMarker();
  }
  if (null != targetMarker) {
    targetMarker();
  }
};
mxConnector.prototype.createMarker = function(c, pe, source) {
  var result = null;
  var size = pe.length;
  var type = mxUtils.getValue(this.style, source ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW);
  var p0 = source ? pe[1] : pe[size - 2];
  pe = source ? pe[0] : pe[size - 1];
  if (null != type && (null != p0 && null != pe)) {
    result = pe.x - p0.x;
    size = pe.y - p0.y;
    var k = Math.sqrt(result * result + size * size);
    p0 = result / k;
    result = size / k;
    size = mxUtils.getNumber(this.style, source ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);
    result = mxMarker.createMarker(c, this, type, pe, p0, result, size, source, this.strokewidth, 0 != this.style[source ? mxConstants.STYLE_STARTFILL : mxConstants.STYLE_ENDFILL]);
  }
  return result;
};
mxConnector.prototype.augmentBoundingBox = function(bbox) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  var size = 0;
  if (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE) {
    size = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1;
  }
  if (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE) {
    size = Math.max(size, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1;
  }
  bbox.grow(size * this.scale);
};
function mxSwimlane(bounds, fill, stroke, strokewidth) {
  mxShape.call(this);
  this.bounds = bounds;
  this.fill = fill;
  this.stroke = stroke;
  this.strokewidth = null != strokewidth ? strokewidth : 1;
}
mxUtils.extend(mxSwimlane, mxShape);
mxSwimlane.prototype.imageSize = 16;
mxSwimlane.prototype.apply = function(state) {
  mxShape.prototype.apply.apply(this, arguments);
  if (null != this.style) {
    this.laneFill = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE);
  }
};
mxSwimlane.prototype.isRoundable = function() {
  return true;
};
mxSwimlane.prototype.getTitleSize = function() {
  return Math.max(0, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
};
mxSwimlane.prototype.getLabelBounds = function(bounds) {
  var sourceEdge = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0);
  var targetEdge = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0);
  bounds = new mxRectangle(bounds.x, bounds.y, bounds.width, bounds.height);
  var horizontal = this.isHorizontal();
  var tmp = this.getTitleSize();
  var shapeVertical = this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH;
  horizontal = horizontal == !shapeVertical;
  sourceEdge = !horizontal && sourceEdge != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
  targetEdge = horizontal && targetEdge != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
  if (shapeVertical) {
    tmp = Math.min(bounds.width, tmp * this.scale);
    if (sourceEdge || targetEdge) {
      bounds.x += bounds.width - tmp;
    }
    bounds.width = tmp;
  } else {
    tmp = Math.min(bounds.height, tmp * this.scale);
    if (sourceEdge || targetEdge) {
      bounds.y += bounds.height - tmp;
    }
    bounds.height = tmp;
  }
  return bounds;
};
mxSwimlane.prototype.getGradientBounds = function(w, x, y, width, h) {
  w = this.getTitleSize();
  return this.isHorizontal() ? new mxRectangle(x, y, width, Math.min(w, h)) : new mxRectangle(x, y, Math.min(w, width), h);
};
mxSwimlane.prototype.getSwimlaneArcSize = function(w, h, start) {
  if ("1" == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
    return Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));
  }
  w = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
  return start * w * 3;
};
mxSwimlane.prototype.isHorizontal = function() {
  return 1 == mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1);
};
mxSwimlane.prototype.paintVertexShape = function(c, x, y, w, h) {
  if (!this.outline) {
    var start = this.getTitleSize();
    var r = 0;
    start = this.isHorizontal() ? Math.min(start, h) : Math.min(start, w);
    c.translate(x, y);
    if (this.isRounded) {
      r = this.getSwimlaneArcSize(w, h, start);
      r = Math.min((this.isHorizontal() ? h : w) - start, Math.min(start, r));
      this.paintRoundedSwimlane(c, x, y, w, h, start, r);
    } else {
      this.paintSwimlane(c, x, y, w, h, start);
    }
    var sep = mxUtils.getValue(this.style, mxConstants.STYLE_SEPARATORCOLOR, mxConstants.NONE);
    this.paintSeparator(c, x, y, w, h, start, sep);
    if (null != this.image) {
      h = this.getImageBounds(x, y, w, h);
      sep = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null);
      c.image(h.x - x, h.y - y, h.width, h.height, this.image, false, false, false, sep);
    }
    if (this.glass) {
      c.setShadow(false);
      this.paintGlassEffect(c, 0, 0, w, start, r);
    }
  }
};
mxSwimlane.prototype.configurePointerEvents = function(c) {
  var b = true;
  var sourceEdge = true;
  var targetEdge = true;
  if (null != this.style) {
    b = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
    sourceEdge = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1);
    targetEdge = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1);
  }
  if (b || (sourceEdge || targetEdge)) {
    mxShape.prototype.configurePointerEvents.apply(this, arguments);
  }
};
mxSwimlane.prototype.paintSwimlane = function(c, x, y, w, h, y2) {
  var fill = this.laneFill;
  var k = true;
  var l = true;
  var m = true;
  var n = true;
  if (null != this.style) {
    k = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
    l = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1);
    m = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1);
    n = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1);
  }
  if (this.isHorizontal()) {
    c.begin();
    c.moveTo(0, y2);
    c.lineTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, y2);
    if (m) {
      c.fillAndStroke();
    } else {
      c.fill();
    }
    if (y2 < h) {
      if (!(fill != mxConstants.NONE && k)) {
        c.pointerEvents = false;
      }
      if (fill != mxConstants.NONE) {
        c.setFillColor(fill);
      }
      c.begin();
      c.moveTo(0, y2);
      c.lineTo(0, h);
      c.lineTo(w, h);
      c.lineTo(w, y2);
      if (n) {
        if (fill == mxConstants.NONE) {
          c.stroke();
        } else {
          if (n) {
            c.fillAndStroke();
          }
        }
      } else {
        if (fill != mxConstants.NONE) {
          c.fill();
        }
      }
    }
  } else {
    c.begin();
    c.moveTo(y2, 0);
    c.lineTo(0, 0);
    c.lineTo(0, h);
    c.lineTo(y2, h);
    if (m) {
      c.fillAndStroke();
    } else {
      c.fill();
    }
    if (y2 < w) {
      if (!(fill != mxConstants.NONE && k)) {
        c.pointerEvents = false;
      }
      if (fill != mxConstants.NONE) {
        c.setFillColor(fill);
      }
      c.begin();
      c.moveTo(y2, 0);
      c.lineTo(w, 0);
      c.lineTo(w, h);
      c.lineTo(y2, h);
      if (n) {
        if (fill == mxConstants.NONE) {
          c.stroke();
        } else {
          if (n) {
            c.fillAndStroke();
          }
        }
      } else {
        if (fill != mxConstants.NONE) {
          c.fill();
        }
      }
    }
  }
  if (l) {
    this.paintDivider(c, x, y, w, h, y2, fill == mxConstants.NONE);
  }
};
mxSwimlane.prototype.paintRoundedSwimlane = function(c, x, y, w, h, y2, r) {
  var fill = this.laneFill;
  var l = true;
  var m = true;
  var n = true;
  var p = true;
  if (null != this.style) {
    l = "1" == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1");
    m = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1);
    n = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1);
    p = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1);
  }
  if (this.isHorizontal()) {
    c.begin();
    c.moveTo(w, y2);
    c.lineTo(w, r);
    c.quadTo(w, 0, w - Math.min(w / 2, r), 0);
    c.lineTo(Math.min(w / 2, r), 0);
    c.quadTo(0, 0, 0, r);
    c.lineTo(0, y2);
    if (n) {
      c.fillAndStroke();
    } else {
      c.fill();
    }
    if (y2 < h) {
      if (!(fill != mxConstants.NONE && l)) {
        c.pointerEvents = false;
      }
      if (fill != mxConstants.NONE) {
        c.setFillColor(fill);
      }
      c.begin();
      c.moveTo(0, y2);
      c.lineTo(0, h - r);
      c.quadTo(0, h, Math.min(w / 2, r), h);
      c.lineTo(w - Math.min(w / 2, r), h);
      c.quadTo(w, h, w, h - r);
      c.lineTo(w, y2);
      if (p) {
        if (fill == mxConstants.NONE) {
          c.stroke();
        } else {
          if (p) {
            c.fillAndStroke();
          }
        }
      } else {
        if (fill != mxConstants.NONE) {
          c.fill();
        }
      }
    }
  } else {
    c.begin();
    c.moveTo(y2, 0);
    c.lineTo(r, 0);
    c.quadTo(0, 0, 0, Math.min(h / 2, r));
    c.lineTo(0, h - Math.min(h / 2, r));
    c.quadTo(0, h, r, h);
    c.lineTo(y2, h);
    if (n) {
      c.fillAndStroke();
    } else {
      c.fill();
    }
    if (y2 < w) {
      if (!(fill != mxConstants.NONE && l)) {
        c.pointerEvents = false;
      }
      if (fill != mxConstants.NONE) {
        c.setFillColor(fill);
      }
      c.begin();
      c.moveTo(y2, h);
      c.lineTo(w - r, h);
      c.quadTo(w, h, w, h - Math.min(h / 2, r));
      c.lineTo(w, Math.min(h / 2, r));
      c.quadTo(w, 0, w - r, 0);
      c.lineTo(y2, 0);
      if (p) {
        if (fill == mxConstants.NONE) {
          c.stroke();
        } else {
          if (p) {
            c.fillAndStroke();
          }
        }
      } else {
        if (fill != mxConstants.NONE) {
          c.fill();
        }
      }
    }
  }
  if (m) {
    this.paintDivider(c, x, y, w, h, y2, fill == mxConstants.NONE);
  }
};
mxSwimlane.prototype.paintDivider = function(c, x, y, w, h, y2, shadow) {
  if (0 != y2) {
    if (!shadow) {
      c.setShadow(false);
    }
    c.begin();
    if (this.isHorizontal()) {
      c.moveTo(0, y2);
      c.lineTo(w, y2);
    } else {
      c.moveTo(y2, 0);
      c.lineTo(y2, h);
    }
    c.stroke();
  }
};
mxSwimlane.prototype.paintSeparator = function(c, x, y, w, h, y2, color) {
  if (color != mxConstants.NONE) {
    c.setStrokeColor(color);
    c.setDashed(true);
    c.begin();
    if (this.isHorizontal()) {
      c.moveTo(w, y2);
      c.lineTo(w, h);
    } else {
      c.moveTo(y2, 0);
      c.lineTo(w, 0);
    }
    c.stroke();
    c.setDashed(false);
  }
};
mxSwimlane.prototype.getImageBounds = function(x, y, w, h) {
  return this.isHorizontal() ? new mxRectangle(x + w - this.imageSize, y, this.imageSize, this.imageSize) : new mxRectangle(x, y, this.imageSize, this.imageSize);
};
function mxGraphLayout(graph) {
  this.graph = graph;
}
mxGraphLayout.prototype.graph = null;
mxGraphLayout.prototype.useBoundingBox = true;
mxGraphLayout.prototype.parent = null;
mxGraphLayout.prototype.moveCell = function(y, x, cell) {
};
mxGraphLayout.prototype.resizeCell = function(cell, bounds) {
};
mxGraphLayout.prototype.execute = function(parent) {
};
mxGraphLayout.prototype.getGraph = function() {
  return this.graph;
};
mxGraphLayout.prototype.getConstraint = function(key, cell, edge, source) {
  return this.graph.getCurrentCellStyle(cell)[key];
};
mxGraphLayout.traverse = function(cell, directed, y2, edge, currentComp) {
  if (null != y2 && (null != cell && ((directed = null != directed ? directed : true, currentComp = currentComp || new mxDictionary, !currentComp.get(cell) && (currentComp.put(cell, true), edge = y2(cell, edge), null == edge || edge)) && (edge = this.graph.model.getEdgeCount(cell), 0 < edge)))) {
    for (var i = 0;i < edge;i++) {
      var source = this.graph.model.getEdgeAt(cell, i);
      var next = this.graph.model.getTerminal(source, true) == cell;
      if (!directed || next) {
        next = this.graph.view.getVisibleTerminal(source, !next);
        this.traverse(next, directed, y2, source, currentComp);
      }
    }
  }
};
mxGraphLayout.prototype.isAncestor = function(parent, cell, traverseAncestors) {
  if (!traverseAncestors) {
    return this.graph.model.getParent(cell) == parent;
  }
  if (cell == parent) {
    return false;
  }
  for (;null != cell && cell != parent;) {
    cell = this.graph.model.getParent(cell);
  }
  return cell == parent;
};
mxGraphLayout.prototype.isVertexMovable = function(cell) {
  return this.graph.isCellMovable(cell);
};
mxGraphLayout.prototype.isVertexIgnored = function(cell) {
  return!this.graph.getModel().isVertex(cell) || !this.graph.getModel().isVisible(cell);
};
mxGraphLayout.prototype.isEdgeIgnored = function(cell) {
  var model = this.graph.getModel();
  return!model.isEdge(cell) || (!this.graph.getModel().isVisible(cell) || (null == model.getTerminal(cell, true) || null == model.getTerminal(cell, false)));
};
mxGraphLayout.prototype.setEdgeStyleEnabled = function(edge, value) {
  this.graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE, value ? "0" : "1", [edge]);
};
mxGraphLayout.prototype.setOrthogonalEdge = function(edge, value) {
  this.graph.setCellStyles(mxConstants.STYLE_ORTHOGONAL, value ? "1" : "0", [edge]);
};
mxGraphLayout.prototype.getParentOffset = function(cell) {
  var result = new mxPoint;
  if (null != cell && cell != this.parent) {
    var model = this.graph.getModel();
    if (model.isAncestor(this.parent, cell)) {
      for (var node = model.getGeometry(cell);cell != this.parent;) {
        result.x += node.x;
        result.y += node.y;
        cell = model.getParent(cell);
        node = model.getGeometry(cell);
      }
    }
  }
  return result;
};
mxGraphLayout.prototype.setEdgePoints = function(cell, points) {
  if (null != cell) {
    var model = this.graph.model;
    var geometry = model.getGeometry(cell);
    if (null == geometry) {
      geometry = new mxGeometry;
      geometry.setRelative(true);
    } else {
      geometry = geometry.clone();
    }
    if (null != this.parent && null != points) {
      var tmp = model.getParent(cell);
      tmp = this.getParentOffset(tmp);
      for (var j = 0;j < points.length;j++) {
        points[j].x -= tmp.x;
        points[j].y -= tmp.y;
      }
    }
    geometry.points = points;
    model.setGeometry(cell, geometry);
  }
};
mxGraphLayout.prototype.setVertexLocation = function(cell, x, y) {
  var model = this.graph.getModel();
  var geometry = model.getGeometry(cell);
  var result = null;
  if (null != geometry) {
    result = new mxRectangle(x, y, geometry.width, geometry.height);
    if (this.useBoundingBox) {
      var state = this.graph.getView().getState(cell);
      if (null != state && (null != state.text && null != state.text.boundingBox)) {
        var scale = this.graph.getView().scale;
        var box = state.text.boundingBox;
        if (state.text.boundingBox.x < state.x) {
          x += (state.x - box.x) / scale;
          result.width = box.width;
        }
        if (state.text.boundingBox.y < state.y) {
          y += (state.y - box.y) / scale;
          result.height = box.height;
        }
      }
    }
    if (null != this.parent) {
      state = model.getParent(cell);
      if (null != state) {
        if (state != this.parent) {
          state = this.getParentOffset(state);
          x -= state.x;
          y -= state.y;
        }
      }
    }
    if (geometry.x != x || geometry.y != y) {
      geometry = geometry.clone();
      geometry.x = x;
      geometry.y = y;
      model.setGeometry(cell, geometry);
    }
  }
  return result;
};
mxGraphLayout.prototype.getVertexBounds = function(cell) {
  var geo = this.graph.getModel().getGeometry(cell);
  if (this.useBoundingBox) {
    var state = this.graph.getView().getState(cell);
    if (null != state && (null != state.text && null != state.text.boundingBox)) {
      var scale = this.graph.getView().scale;
      var tmp = state.text.boundingBox;
      var dx0 = Math.max(state.x - tmp.x, 0) / scale;
      var dy0 = Math.max(state.y - tmp.y, 0) / scale;
      geo = new mxRectangle(geo.x - dx0, geo.y - dy0, geo.width + dx0 + Math.max(tmp.x + tmp.width - (state.x + state.width), 0) / scale, geo.height + dy0 + Math.max(tmp.y + tmp.height - (state.y + state.height), 0) / scale);
    }
  }
  if (null != this.parent) {
    cell = this.graph.getModel().getParent(cell);
    geo = geo.clone();
    if (null != cell) {
      if (cell != this.parent) {
        cell = this.getParentOffset(cell);
        geo.x += cell.x;
        geo.y += cell.y;
      }
    }
  }
  return new mxRectangle(geo.x, geo.y, geo.width, geo.height);
};
mxGraphLayout.prototype.arrangeGroups = function(cells, border, topBorder, rightBorder, bottomBorder, leftBorder) {
  return this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);
};
function WeightedCellSorter(cell, weightedValue) {
  this.cell = cell;
  this.weightedValue = weightedValue;
}
WeightedCellSorter.prototype.weightedValue = 0;
WeightedCellSorter.prototype.nudge = false;
WeightedCellSorter.prototype.visited = false;
WeightedCellSorter.prototype.rankIndex = null;
WeightedCellSorter.prototype.cell = null;
WeightedCellSorter.prototype.compare = function(a, b) {
  return null != a && null != b ? b.weightedValue > a.weightedValue ? -1 : b.weightedValue < a.weightedValue ? 1 : b.nudge ? -1 : 1 : 0;
};
function mxStackLayout(graph, horizontal, spacing, x0, y0, border) {
  mxGraphLayout.call(this, graph);
  this.horizontal = null != horizontal ? horizontal : true;
  this.spacing = null != spacing ? spacing : 0;
  this.x0 = null != x0 ? x0 : 0;
  this.y0 = null != y0 ? y0 : 0;
  this.border = null != border ? border : 0;
}
mxStackLayout.prototype = new mxGraphLayout;
mxStackLayout.prototype.constructor = mxStackLayout;
mxStackLayout.prototype.horizontal = null;
mxStackLayout.prototype.spacing = null;
mxStackLayout.prototype.x0 = null;
mxStackLayout.prototype.y0 = null;
mxStackLayout.prototype.border = 0;
mxStackLayout.prototype.marginTop = 0;
mxStackLayout.prototype.marginLeft = 0;
mxStackLayout.prototype.marginRight = 0;
mxStackLayout.prototype.marginBottom = 0;
mxStackLayout.prototype.keepFirstLocation = false;
mxStackLayout.prototype.fill = false;
mxStackLayout.prototype.resizeParent = false;
mxStackLayout.prototype.resizeParentMax = false;
mxStackLayout.prototype.resizeLast = false;
mxStackLayout.prototype.wrap = null;
mxStackLayout.prototype.borderCollapse = true;
mxStackLayout.prototype.allowGaps = false;
mxStackLayout.prototype.gridSize = 0;
mxStackLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
mxStackLayout.prototype.moveCell = function(cell, i, value) {
  var model = this.graph.getModel();
  var parent = model.getParent(cell);
  var callback = this.isHorizontal();
  if (null != cell && null != parent) {
    var last = 0;
    var childCount = model.getChildCount(parent);
    value = callback ? i : value;
    i = this.graph.getView().getState(parent);
    if (null != i) {
      value -= callback ? i.x : i.y;
    }
    value /= this.graph.view.scale;
    for (i = 0;i < childCount;i++) {
      var tmp = model.getChildAt(parent, i);
      if (tmp != cell && (tmp = model.getGeometry(tmp), null != tmp)) {
        tmp = callback ? tmp.x + tmp.width / 2 : tmp.y + tmp.height / 2;
        if (last <= value && tmp > value) {
          break;
        }
        last = tmp;
      }
    }
    callback = parent.getIndex(cell);
    callback = Math.max(0, i - (i > callback ? 1 : 0));
    model.add(parent, cell, callback);
  }
};
mxStackLayout.prototype.getParentSize = function(parent) {
  var model = this.graph.getModel();
  var pgeo = model.getGeometry(parent);
  if (null != this.graph.container) {
    if (null == pgeo && model.isLayer(parent) || parent == this.graph.getView().currentRoot) {
      pgeo = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1);
    }
  }
  return pgeo;
};
mxStackLayout.prototype.getLayoutCells = function(cell) {
  var model = this.graph.getModel();
  var childCount = model.getChildCount(cell);
  var cells = [];
  for (var i = 0;i < childCount;i++) {
    var child = model.getChildAt(cell, i);
    if (!this.isVertexIgnored(child)) {
      if (this.isVertexMovable(child)) {
        cells.push(child);
      }
    }
  }
  if (this.allowGaps) {
    cells.sort(mxUtils.bind(this, function(geo1, geo2) {
      geo1 = this.graph.getCellGeometry(geo1);
      geo2 = this.graph.getCellGeometry(geo2);
      return this.horizontal ? geo1.x == geo2.x ? 0 : geo1.x > geo2.x > 0 ? 1 : -1 : geo1.y == geo2.y ? 0 : geo1.y > geo2.y > 0 ? 1 : -1;
    }));
  }
  return cells;
};
mxStackLayout.prototype.snap = function(value) {
  if (null != this.gridSize && (0 < this.gridSize && (value = Math.max(value, this.gridSize), 1 < value / this.gridSize))) {
    var mod = value % this.gridSize;
    value += mod > this.gridSize / 2 ? this.gridSize - mod : -mod;
  }
  return value;
};
mxStackLayout.prototype.execute = function(parent) {
  if (null != parent) {
    var pgeo = this.getParentSize(parent);
    var horizontal = this.isHorizontal();
    var model = this.graph.getModel();
    var fillValue = null;
    if (null != pgeo) {
      fillValue = horizontal ? pgeo.height - this.marginTop - this.marginBottom : pgeo.width - this.marginLeft - this.marginRight;
    }
    fillValue -= 2 * this.border;
    var x0 = this.x0 + this.border + this.marginLeft;
    var y0 = this.y0 + this.border + this.marginTop;
    if (this.graph.isSwimlane(parent)) {
      var last = this.graph.getCellStyle(parent);
      var start = mxUtils.getNumber(last, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE);
      last = 1 == mxUtils.getValue(last, mxConstants.STYLE_HORIZONTAL, true);
      if (null != pgeo) {
        start = last ? Math.min(start, pgeo.height) : Math.min(start, pgeo.width);
      }
      if (horizontal == last) {
        fillValue -= start;
      }
      if (last) {
        y0 += start;
      } else {
        x0 += start;
      }
    }
    model.beginUpdate();
    try {
      start = 0;
      last = null;
      var lastValue = 0;
      var lastChild = null;
      var cells = this.getLayoutCells(parent);
      for (var i = 0;i < cells.length;i++) {
        var child = cells[i];
        var geo = model.getGeometry(child);
        if (null != geo) {
          geo = geo.clone();
          if (null != this.wrap) {
            if (null != last) {
              if (horizontal && last.x + last.width + geo.width + 2 * this.spacing > this.wrap || !horizontal && last.y + last.height + geo.height + 2 * this.spacing > this.wrap) {
                last = null;
                if (horizontal) {
                  y0 += start + this.spacing;
                } else {
                  x0 += start + this.spacing;
                }
                start = 0;
              }
            }
          }
          start = Math.max(start, horizontal ? geo.height : geo.width);
          var sw = 0;
          if (!this.borderCollapse) {
            var childStyle = this.graph.getCellStyle(child);
            sw = mxUtils.getNumber(childStyle, mxConstants.STYLE_STROKEWIDTH, 1);
          }
          if (null != last) {
            var temp = lastValue + this.spacing + Math.floor(sw / 2);
            if (horizontal) {
              geo.x = this.snap((this.allowGaps ? Math.max(temp, geo.x) : temp) - this.marginLeft) + this.marginLeft;
            } else {
              geo.y = this.snap((this.allowGaps ? Math.max(temp, geo.y) : temp) - this.marginTop) + this.marginTop;
            }
          } else {
            if (!this.keepFirstLocation) {
              if (horizontal) {
                geo.x = this.allowGaps && geo.x > x0 ? Math.max(this.snap(geo.x - this.marginLeft) + this.marginLeft, x0) : x0;
              } else {
                geo.y = this.allowGaps && geo.y > y0 ? Math.max(this.snap(geo.y - this.marginTop) + this.marginTop, y0) : y0;
              }
            }
          }
          if (horizontal) {
            geo.y = y0;
          } else {
            geo.x = x0;
          }
          if (this.fill) {
            if (null != fillValue) {
              if (horizontal) {
                geo.height = fillValue;
              } else {
                geo.width = fillValue;
              }
            }
          }
          if (horizontal) {
            geo.width = this.snap(geo.width);
          } else {
            geo.height = this.snap(geo.height);
          }
          this.setChildGeometry(child, geo);
          lastChild = child;
          last = geo;
          lastValue = horizontal ? last.x + last.width + Math.floor(sw / 2) : last.y + last.height + Math.floor(sw / 2);
        }
      }
      if (this.resizeParent && (null != pgeo && (null != last && !this.graph.isCellCollapsed(parent)))) {
        this.updateParentGeometry(parent, pgeo, last);
      } else {
        if (this.resizeLast) {
          if (null != pgeo) {
            if (null != last) {
              if (null != lastChild) {
                if (horizontal) {
                  last.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;
                } else {
                  last.height = pgeo.height - last.y - this.spacing - this.marginBottom;
                }
                this.setChildGeometry(lastChild, last);
              }
            }
          }
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
mxStackLayout.prototype.setChildGeometry = function(child, geo) {
  var geo2 = this.graph.getCellGeometry(child);
  if (!(null != geo2 && (geo.x == geo2.x && (geo.y == geo2.y && (geo.width == geo2.width && geo.height == geo2.height))))) {
    this.graph.getModel().setGeometry(child, geo);
  }
};
mxStackLayout.prototype.updateParentGeometry = function(parent, pgeo, last) {
  var horizontal = this.isHorizontal();
  var model = this.graph.getModel();
  var pgeo2 = pgeo.clone();
  if (horizontal) {
    last = last.x + last.width + this.marginRight + this.border;
    pgeo2.width = this.resizeParentMax ? Math.max(pgeo2.width, last) : last;
  } else {
    last = last.y + last.height + this.marginBottom + this.border;
    pgeo2.height = this.resizeParentMax ? Math.max(pgeo2.height, last) : last;
  }
  if (!(pgeo.x == pgeo2.x && (pgeo.y == pgeo2.y && (pgeo.width == pgeo2.width && pgeo.height == pgeo2.height)))) {
    model.setGeometry(parent, pgeo2);
  }
};
function mxPartitionLayout(graph, horizontal, spacing, border) {
  mxGraphLayout.call(this, graph);
  this.horizontal = null != horizontal ? horizontal : true;
  this.spacing = spacing || 0;
  this.border = border || 0;
}
mxPartitionLayout.prototype = new mxGraphLayout;
mxPartitionLayout.prototype.constructor = mxPartitionLayout;
mxPartitionLayout.prototype.horizontal = null;
mxPartitionLayout.prototype.spacing = null;
mxPartitionLayout.prototype.border = null;
mxPartitionLayout.prototype.resizeVertices = true;
mxPartitionLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
mxPartitionLayout.prototype.moveCell = function(cell, callback, model) {
  model = this.graph.getModel();
  var parent = model.getParent(cell);
  if (null != cell && null != parent) {
    var i;
    var lastChild = 0;
    var childCount = model.getChildCount(parent);
    for (i = 0;i < childCount;i++) {
      var child = model.getChildAt(parent, i);
      child = this.getVertexBounds(child);
      if (null != child) {
        child = child.x + child.width / 2;
        if (lastChild < callback && child > callback) {
          break;
        }
        lastChild = child;
      }
    }
    callback = parent.getIndex(cell);
    callback = Math.max(0, i - (i > callback ? 1 : 0));
    model.add(parent, cell, callback);
  }
};
mxPartitionLayout.prototype.execute = function(parent) {
  var horizontal = this.isHorizontal();
  var model = this.graph.getModel();
  var pgeo = model.getGeometry(parent);
  if (null != this.graph.container) {
    if (null == pgeo && model.isLayer(parent) || parent == this.graph.getView().currentRoot) {
      pgeo = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1);
    }
  }
  if (null != pgeo) {
    var children = [];
    var n = model.getChildCount(parent);
    for (var i = 0;i < n;i++) {
      var child = model.getChildAt(parent, i);
      if (!this.isVertexIgnored(child)) {
        if (this.isVertexMovable(child)) {
          children.push(child);
        }
      }
    }
    n = children.length;
    if (0 < n) {
      var x0 = this.border;
      var y0 = this.border;
      var other = horizontal ? pgeo.height : pgeo.width;
      other -= 2 * this.border;
      parent = this.graph.isSwimlane(parent) ? this.graph.getStartSize(parent) : new mxRectangle;
      other -= horizontal ? parent.height : parent.width;
      x0 += parent.width;
      y0 += parent.height;
      parent = this.border + (n - 1) * this.spacing;
      pgeo = horizontal ? (pgeo.width - x0 - parent) / n : (pgeo.height - y0 - parent) / n;
      if (0 < pgeo) {
        model.beginUpdate();
        try {
          for (i = 0;i < n;i++) {
            child = children[i];
            var geo = model.getGeometry(child);
            if (null != geo) {
              geo = geo.clone();
              geo.x = x0;
              geo.y = y0;
              if (horizontal) {
                if (this.resizeVertices) {
                  geo.width = pgeo;
                  geo.height = other;
                }
                x0 += pgeo + this.spacing;
              } else {
                if (this.resizeVertices) {
                  geo.height = pgeo;
                  geo.width = other;
                }
                y0 += pgeo + this.spacing;
              }
              model.setGeometry(child, geo);
            }
          }
        } finally {
          model.endUpdate();
        }
      }
    }
  }
};
function mxCompactTreeLayout(graph, horizontal, invert) {
  mxGraphLayout.call(this, graph);
  this.horizontal = null != horizontal ? horizontal : true;
  this.invert = null != invert ? invert : false;
}
mxCompactTreeLayout.prototype = new mxGraphLayout;
mxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout;
mxCompactTreeLayout.prototype.horizontal = null;
mxCompactTreeLayout.prototype.invert = null;
mxCompactTreeLayout.prototype.resizeParent = true;
mxCompactTreeLayout.prototype.maintainParentLocation = false;
mxCompactTreeLayout.prototype.groupPadding = 10;
mxCompactTreeLayout.prototype.groupPaddingTop = 0;
mxCompactTreeLayout.prototype.groupPaddingRight = 0;
mxCompactTreeLayout.prototype.groupPaddingBottom = 0;
mxCompactTreeLayout.prototype.groupPaddingLeft = 0;
mxCompactTreeLayout.prototype.parentsChanged = null;
mxCompactTreeLayout.prototype.moveTree = false;
mxCompactTreeLayout.prototype.visited = null;
mxCompactTreeLayout.prototype.levelDistance = 10;
mxCompactTreeLayout.prototype.nodeDistance = 20;
mxCompactTreeLayout.prototype.resetEdges = true;
mxCompactTreeLayout.prototype.prefHozEdgeSep = 5;
mxCompactTreeLayout.prototype.prefVertEdgeOff = 4;
mxCompactTreeLayout.prototype.minEdgeJetty = 8;
mxCompactTreeLayout.prototype.channelBuffer = 4;
mxCompactTreeLayout.prototype.edgeRouting = true;
mxCompactTreeLayout.prototype.sortEdges = false;
mxCompactTreeLayout.prototype.alignRanks = false;
mxCompactTreeLayout.prototype.maxRankHeight = null;
mxCompactTreeLayout.prototype.root = null;
mxCompactTreeLayout.prototype.node = null;
mxCompactTreeLayout.prototype.isVertexIgnored = function(cell) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(cell).length;
};
mxCompactTreeLayout.prototype.isHorizontal = function() {
  return this.horizontal;
};
mxCompactTreeLayout.prototype.execute = function(parent, roots) {
  this.parent = parent;
  var model = this.graph.getModel();
  if (null == roots) {
    if (0 < this.graph.getEdges(parent, model.getParent(parent), this.invert, !this.invert, false).length) {
      this.root = parent;
    } else {
      if (roots = this.graph.findTreeRoots(parent, true, this.invert), 0 < roots.length) {
        for (var i = 0;i < roots.length;i++) {
          if (!this.isVertexIgnored(roots[i]) && 0 < this.graph.getEdges(roots[i], null, this.invert, !this.invert, false).length) {
            this.root = roots[i];
            break;
          }
        }
      }
    }
  } else {
    this.root = roots;
  }
  if (null != this.root) {
    this.parentsChanged = this.resizeParent ? {} : null;
    this.parentY = this.parentX = null;
    if (parent != this.root && (null != model.isVertex(parent) && this.maintainParentLocation)) {
      var geo = this.graph.getCellGeometry(parent);
      if (null != geo) {
        this.parentX = geo.x;
        this.parentY = geo.y;
      }
    }
    model.beginUpdate();
    try {
      if (this.visited = {}, this.node = this.dfs(this.root, parent), this.alignRanks && (this.maxRankHeight = [], this.findRankHeights(this.node, 0), this.setCellHeights(this.node, 0)), null != this.node) {
        this.layout(this.node);
        var x0 = this.graph.gridSize;
        roots = x0;
        if (!this.moveTree) {
          var rootBounds = this.getVertexBounds(this.root);
          if (null != rootBounds) {
            x0 = rootBounds.x;
            roots = rootBounds.y;
          }
        }
        rootBounds = null;
        rootBounds = this.isHorizontal() ? this.horizontalLayout(this.node, x0, roots) : this.verticalLayout(this.node, null, x0, roots);
        if (null != rootBounds) {
          var dy = i = 0;
          if (0 > rootBounds.x) {
            i = Math.abs(x0 - rootBounds.x);
          }
          if (0 > rootBounds.y) {
            dy = Math.abs(roots - rootBounds.y);
          }
          if (!(0 == i && 0 == dy)) {
            this.moveNode(this.node, i, dy);
          }
          if (this.resizeParent) {
            this.adjustParents();
          }
          if (this.edgeRouting) {
            this.localEdgeProcessing(this.node);
          }
        }
        if (null != this.parentX) {
          if (null != this.parentY) {
            geo = this.graph.getCellGeometry(parent);
            if (null != geo) {
              geo = geo.clone();
              geo.x = this.parentX;
              geo.y = this.parentY;
              model.setGeometry(parent, geo);
            }
          }
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
mxCompactTreeLayout.prototype.moveNode = function(state, dx, dy) {
  state.x += dx;
  state.y += dy;
  this.apply(state);
  for (state = state.child;null != state;) {
    this.moveNode(state, dx, dy);
    state = state.next;
  }
};
mxCompactTreeLayout.prototype.sortOutgoingEdges = function(source, edges) {
  var dict = new mxDictionary;
  edges.sort(function(p1, cell) {
    var terminal = p1.getTerminal(p1.getTerminal(false) == source);
    p1 = dict.get(terminal);
    if (null == p1) {
      p1 = mxCellPath.create(terminal).split(mxCellPath.PATH_SEPARATOR);
      dict.put(terminal, p1);
    }
    cell = cell.getTerminal(cell.getTerminal(false) == source);
    terminal = dict.get(cell);
    if (null == terminal) {
      terminal = mxCellPath.create(cell).split(mxCellPath.PATH_SEPARATOR);
      dict.put(cell, terminal);
    }
    return mxCellPath.compare(p1, terminal);
  });
};
mxCompactTreeLayout.prototype.findRankHeights = function(node, rank) {
  if (null == this.maxRankHeight[rank] || this.maxRankHeight[rank] < node.height) {
    this.maxRankHeight[rank] = node.height;
  }
  for (node = node.child;null != node;) {
    this.findRankHeights(node, rank + 1);
    node = node.next;
  }
};
mxCompactTreeLayout.prototype.setCellHeights = function(node, rank) {
  if (null != this.maxRankHeight[rank]) {
    if (this.maxRankHeight[rank] > node.height) {
      node.height = this.maxRankHeight[rank];
    }
  }
  for (node = node.child;null != node;) {
    this.setCellHeights(node, rank + 1);
    node = node.next;
  }
};
mxCompactTreeLayout.prototype.dfs = function(cell, parent) {
  var id = mxCellPath.create(cell);
  var node = null;
  if (null != cell && (null == this.visited[id] && !this.isVertexIgnored(cell))) {
    this.visited[id] = cell;
    node = this.createNode(cell);
    id = this.graph.getModel();
    var prev = null;
    var out = this.graph.getEdges(cell, parent, this.invert, !this.invert, false, true);
    var view = this.graph.getView();
    if (this.sortEdges) {
      this.sortOutgoingEdges(cell, out);
    }
    for (cell = 0;cell < out.length;cell++) {
      var edge = out[cell];
      if (!this.isEdgeIgnored(edge)) {
        if (this.resetEdges) {
          this.setEdgePoints(edge, null);
        }
        if (this.edgeRouting) {
          this.setEdgeStyleEnabled(edge, false);
          this.setEdgePoints(edge, null);
        }
        var tmp = view.getState(edge);
        edge = null != tmp ? tmp.getVisibleTerminal(this.invert) : view.getVisibleTerminal(edge, this.invert);
        tmp = this.dfs(edge, parent);
        if (null != tmp) {
          if (null != id.getGeometry(edge)) {
            if (null == prev) {
              node.child = tmp;
            } else {
              prev.next = tmp;
            }
            prev = tmp;
          }
        }
      }
    }
  }
  return node;
};
mxCompactTreeLayout.prototype.layout = function(node) {
  if (null != node) {
    for (var child = node.child;null != child;) {
      this.layout(child);
      child = child.next;
    }
    if (null != node.child) {
      this.attachParent(node, this.join(node));
    } else {
      this.layoutLeaf(node);
    }
  }
};
mxCompactTreeLayout.prototype.horizontalLayout = function(node, child, y0, bounds) {
  node.x += child + node.offsetX;
  node.y += y0 + node.offsetY;
  bounds = this.apply(node, bounds);
  child = node.child;
  if (null != child) {
    bounds = this.horizontalLayout(child, node.x, node.y, bounds);
    y0 = node.y + child.offsetY;
    for (var s = child.next;null != s;) {
      bounds = this.horizontalLayout(s, node.x + child.offsetX, y0, bounds);
      y0 += s.offsetY;
      s = s.next;
    }
  }
  return bounds;
};
mxCompactTreeLayout.prototype.verticalLayout = function(node, child, x0, s, bounds) {
  node.x += x0 + node.offsetY;
  node.y += s + node.offsetX;
  bounds = this.apply(node, bounds);
  child = node.child;
  if (null != child) {
    bounds = this.verticalLayout(child, node, node.x, node.y, bounds);
    x0 = node.x + child.offsetY;
    for (s = child.next;null != s;) {
      bounds = this.verticalLayout(s, node, x0, node.y + child.offsetX, bounds);
      x0 += s.offsetY;
      s = s.next;
    }
  }
  return bounds;
};
mxCompactTreeLayout.prototype.attachParent = function(node, y1) {
  var x = this.nodeDistance + this.levelDistance;
  var y2 = (y1 - node.width) / 2 - this.nodeDistance;
  y1 = y2 + node.width + 2 * this.nodeDistance - y1;
  node.child.offsetX = x + node.height;
  node.child.offsetY = y1;
  node.contour.upperHead = this.createLine(node.height, 0, this.createLine(x, y1, node.contour.upperHead));
  node.contour.lowerHead = this.createLine(node.height, 0, this.createLine(x, y2, node.contour.lowerHead));
};
mxCompactTreeLayout.prototype.layoutLeaf = function(node) {
  var dist = 2 * this.nodeDistance;
  node.contour.upperTail = this.createLine(node.height + dist, 0);
  node.contour.upperHead = node.contour.upperTail;
  node.contour.lowerTail = this.createLine(0, -node.width - dist);
  node.contour.lowerHead = this.createLine(node.height + dist, 0, node.contour.lowerTail);
};
mxCompactTreeLayout.prototype.join = function(node) {
  var dist = 2 * this.nodeDistance;
  var child = node.child;
  node.contour = child.contour;
  var h = child.width + dist;
  var sum = h;
  for (child = child.next;null != child;) {
    var d = this.merge(node.contour, child.contour);
    child.offsetY = d + h;
    child.offsetX = 0;
    h = child.width + dist;
    sum += d + h;
    child = child.next;
  }
  return sum;
};
mxCompactTreeLayout.prototype.merge = function(p1, p2) {
  var x = 0;
  var y = 0;
  var total = 0;
  var upper = p1.lowerHead;
  for (var lower = p2.upperHead;null != lower && null != upper;) {
    var d = this.offset(x, y, lower.dx, lower.dy, upper.dx, upper.dy);
    y += d;
    total += d;
    if (x + lower.dx <= upper.dx) {
      x += lower.dx;
      y += lower.dy;
      lower = lower.next;
    } else {
      x -= upper.dx;
      y -= upper.dy;
      upper = upper.next;
    }
  }
  if (null != lower) {
    x = this.bridge(p1.upperTail, 0, 0, lower, x, y);
    p1.upperTail = null != x.next ? p2.upperTail : x;
    p1.lowerTail = p2.lowerTail;
  } else {
    x = this.bridge(p2.lowerTail, x, y, upper, 0, 0);
    if (null == x.next) {
      p1.lowerTail = x;
    }
  }
  p1.lowerHead = p2.lowerHead;
  return total;
};
mxCompactTreeLayout.prototype.offset = function(p1, y, a1, a2, b1, b2) {
  if (b1 <= p1 || 0 >= p1 + a1) {
    return 0;
  }
  p1 = 0 < b1 * a2 - a1 * b2 ? 0 > p1 ? p1 * a2 / a1 - y : 0 < p1 ? p1 * b2 / b1 - y : -y : b1 < p1 + a1 ? b2 - (y + (b1 - p1) * a2 / a1) : b1 > p1 + a1 ? (a1 + p1) * b2 / b1 - (y + a2) : b2 - (y + a2);
  return 0 < p1 ? p1 : 0;
};
mxCompactTreeLayout.prototype.bridge = function(line1, dx, y1, line2, dy, y2) {
  dx = dy + line2.dx - dx;
  if (0 == line2.dx) {
    dy = line2.dy;
  } else {
    dy = dx * line2.dy;
    dy /= line2.dx;
  }
  dx = this.createLine(dx, dy, line2.next);
  line1.next = this.createLine(0, y2 + line2.dy - dy - y1, dx);
  return dx;
};
mxCompactTreeLayout.prototype.createNode = function(cell) {
  var node = {};
  node.cell = cell;
  node.x = 0;
  node.y = 0;
  node.width = 0;
  node.height = 0;
  cell = this.getVertexBounds(cell);
  if (null != cell) {
    if (this.isHorizontal()) {
      node.width = cell.height;
      node.height = cell.width;
    } else {
      node.width = cell.width;
      node.height = cell.height;
    }
  }
  node.offsetX = 0;
  node.offsetY = 0;
  node.contour = {};
  return node;
};
mxCompactTreeLayout.prototype.apply = function(state, bounds) {
  var model = this.graph.getModel();
  var cell = state.cell;
  var g = model.getGeometry(cell);
  if (null != cell) {
    if (null != g) {
      if (this.isVertexMovable(cell)) {
        g = this.setVertexLocation(cell, state.x, state.y);
        if (this.resizeParent) {
          state = model.getParent(cell);
          model = mxCellPath.create(state);
          if (null == this.parentsChanged[model]) {
            this.parentsChanged[model] = state;
          }
        }
      }
      bounds = null == bounds ? new mxRectangle(g.x, g.y, g.width, g.height) : new mxRectangle(Math.min(bounds.x, g.x), Math.min(bounds.y, g.y), Math.max(bounds.x + bounds.width, g.x + g.width), Math.max(bounds.y + bounds.height, g.y + g.height));
    }
  }
  return bounds;
};
mxCompactTreeLayout.prototype.createLine = function(dx, dy, next) {
  var line = {};
  line.dx = dx;
  line.dy = dy;
  line.next = next;
  return line;
};
mxCompactTreeLayout.prototype.adjustParents = function() {
  var tmp = [];
  for (var id in this.parentsChanged) {
    tmp.push(this.parentsChanged[id]);
  }
  this.arrangeGroups(mxUtils.sortCells(tmp, true), this.groupPadding, this.groupPaddingTop, this.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);
};
mxCompactTreeLayout.prototype.localEdgeProcessing = function(model) {
  this.processNodeOutgoing(model);
  for (model = model.child;null != model;) {
    this.localEdgeProcessing(model);
    model = model.next;
  }
};
mxCompactTreeLayout.prototype.processNodeOutgoing = function(node) {
  var child = node.child;
  var source = node.cell;
  var childCount = 0;
  for (var sortedCells = [];null != child;) {
    childCount++;
    var sortingCriterion = child.x;
    if (this.horizontal) {
      sortingCriterion = child.y;
    }
    sortedCells.push(new WeightedCellSorter(child, sortingCriterion));
    child = child.next;
  }
  sortedCells.sort(WeightedCellSorter.prototype.compare);
  sortingCriterion = node.width;
  var bounds = (childCount + 1) * this.prefHozEdgeSep;
  if (sortingCriterion > bounds + 2 * this.prefHozEdgeSep) {
    sortingCriterion -= 2 * this.prefHozEdgeSep;
  }
  node = sortingCriterion / childCount;
  child = node / 2;
  if (sortingCriterion > bounds + 2 * this.prefHozEdgeSep) {
    child += this.prefHozEdgeSep;
  }
  sortingCriterion = this.minEdgeJetty - this.prefVertEdgeOff;
  bounds = this.getVertexBounds(source);
  for (var j = 0;j < sortedCells.length;j++) {
    var target = sortedCells[j].cell.cell;
    var trg = this.getVertexBounds(target);
    target = this.graph.getEdgesBetween(source, target, false);
    var newPoints = [];
    var x;
    var y;
    for (var i = 0;i < target.length;i++) {
      if (this.horizontal) {
        x = bounds.x + bounds.width;
        y = bounds.y + child;
        newPoints.push(new mxPoint(x, y));
        x = bounds.x + bounds.width + sortingCriterion;
        newPoints.push(new mxPoint(x, y));
        y = trg.y + trg.height / 2;
      } else {
        x = bounds.x + child;
        y = bounds.y + bounds.height;
        newPoints.push(new mxPoint(x, y));
        y = bounds.y + bounds.height + sortingCriterion;
        newPoints.push(new mxPoint(x, y));
        x = trg.x + trg.width / 2;
      }
      newPoints.push(new mxPoint(x, y));
      this.setEdgePoints(target[i], newPoints);
    }
    if (j < childCount / 2) {
      sortingCriterion += this.prefVertEdgeOff;
    } else {
      if (j > childCount / 2) {
        sortingCriterion -= this.prefVertEdgeOff;
      }
    }
    child += node;
  }
};
function mxRadialTreeLayout(graph) {
  mxCompactTreeLayout.call(this, graph, false);
}
mxUtils.extend(mxRadialTreeLayout, mxCompactTreeLayout);
mxRadialTreeLayout.prototype.angleOffset = 0.5;
mxRadialTreeLayout.prototype.rootx = 0;
mxRadialTreeLayout.prototype.rooty = 0;
mxRadialTreeLayout.prototype.levelDistance = 120;
mxRadialTreeLayout.prototype.nodeDistance = 10;
mxRadialTreeLayout.prototype.autoRadius = false;
mxRadialTreeLayout.prototype.sortEdges = false;
mxRadialTreeLayout.prototype.rowMinX = [];
mxRadialTreeLayout.prototype.rowMaxX = [];
mxRadialTreeLayout.prototype.rowMinCenX = [];
mxRadialTreeLayout.prototype.rowMaxCenX = [];
mxRadialTreeLayout.prototype.rowRadi = [];
mxRadialTreeLayout.prototype.row = [];
mxRadialTreeLayout.prototype.isVertexIgnored = function(cell) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(cell).length;
};
mxRadialTreeLayout.prototype.execute = function(parent, evt) {
  this.parent = parent;
  this.edgeRouting = this.useBoundingBox = false;
  mxCompactTreeLayout.prototype.execute.apply(this, arguments);
  var i = null;
  var node = this.getVertexBounds(this.root);
  this.centerX = node.x + node.width / 2;
  this.centerY = node.y + node.height / 2;
  for (var j in this.visited) {
    var row = this.getVertexBounds(this.visited[j]);
    i = null != i ? i : row.clone();
    i.add(row);
  }
  this.calcRowDims([this.node], 0);
  var averTheta = 0;
  var maxRightGrad = 0;
  for (i = 0;i < this.row.length;i++) {
    j = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];
    averTheta = Math.max(averTheta, (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i]);
    maxRightGrad = Math.max(maxRightGrad, j);
  }
  for (i = 0;i < this.row.length;i++) {
    var xLeftLimit = this.centerX - this.nodeDistance - averTheta * this.rowRadi[i];
    var fullWidth = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i] - xLeftLimit;
    for (j = 0;j < this.row[i].length;j++) {
      row = this.row[i];
      node = row[j];
      row = this.getVertexBounds(node.cell);
      node.theta = (row.x + row.width / 2 - xLeftLimit) / fullWidth * Math.PI * 2;
    }
  }
  for (i = this.row.length - 2;0 <= i;i--) {
    row = this.row[i];
    for (j = 0;j < row.length;j++) {
      node = row[j];
      averTheta = node.child;
      for (xLeftLimit = maxRightGrad = 0;null != averTheta;) {
        xLeftLimit += averTheta.theta;
        maxRightGrad++;
        averTheta = averTheta.next;
      }
      if (0 < maxRightGrad) {
        averTheta = xLeftLimit / maxRightGrad;
        if (averTheta > node.theta && j < row.length - 1) {
          node.theta = Math.min(averTheta, row[j + 1].theta - Math.PI / 10);
        } else {
          if (averTheta < node.theta) {
            if (0 < j) {
              node.theta = Math.max(averTheta, row[j - 1].theta + Math.PI / 10);
            }
          }
        }
      }
    }
  }
  for (i = 0;i < this.row.length;i++) {
    for (j = 0;j < this.row[i].length;j++) {
      row = this.row[i];
      node = row[j];
      row = this.getVertexBounds(node.cell);
      this.setVertexLocation(node.cell, this.centerX - row.width / 2 + this.rowRadi[i] * Math.cos(node.theta), this.centerY - row.height / 2 + this.rowRadi[i] * Math.sin(node.theta));
    }
  }
};
mxRadialTreeLayout.prototype.calcRowDims = function(row, rowNum) {
  if (null != row && 0 != row.length) {
    this.rowMinX[rowNum] = this.centerX;
    this.rowMaxX[rowNum] = this.centerX;
    this.rowMinCenX[rowNum] = this.centerX;
    this.rowMaxCenX[rowNum] = this.centerX;
    this.row[rowNum] = [];
    var c = false;
    for (var i = 0;i < row.length;i++) {
      for (var child = null != row[i] ? row[i].child : null;null != child;) {
        var vertexBounds = this.getVertexBounds(child.cell);
        this.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);
        this.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);
        this.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);
        this.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);
        this.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;
        if (null != child.child) {
          c = true;
        }
        this.row[rowNum].push(child);
        child = child.next;
      }
    }
    if (c) {
      this.calcRowDims(this.row[rowNum], rowNum + 1);
    }
  }
};
function mxFastOrganicLayout(graph) {
  mxGraphLayout.call(this, graph);
}
mxFastOrganicLayout.prototype = new mxGraphLayout;
mxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;
mxFastOrganicLayout.prototype.useInputOrigin = true;
mxFastOrganicLayout.prototype.resetEdges = true;
mxFastOrganicLayout.prototype.disableEdgeStyle = true;
mxFastOrganicLayout.prototype.forceConstant = 50;
mxFastOrganicLayout.prototype.forceConstantSquared = 0;
mxFastOrganicLayout.prototype.minDistanceLimit = 2;
mxFastOrganicLayout.prototype.maxDistanceLimit = 500;
mxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;
mxFastOrganicLayout.prototype.initialTemp = 200;
mxFastOrganicLayout.prototype.temperature = 0;
mxFastOrganicLayout.prototype.maxIterations = 0;
mxFastOrganicLayout.prototype.iteration = 0;
mxFastOrganicLayout.prototype.allowedToRun = true;
mxFastOrganicLayout.prototype.isVertexIgnored = function(cell) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(cell).length;
};
mxFastOrganicLayout.prototype.execute = function(parent) {
  var model = this.graph.getModel();
  this.vertexArray = [];
  var cells = this.graph.getChildVertices(parent);
  for (var i = 0;i < cells.length;i++) {
    if (!this.isVertexIgnored(cells[i])) {
      this.vertexArray.push(cells[i]);
    }
  }
  var initialBounds = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;
  var n = this.vertexArray.length;
  this.indices = [];
  this.dispX = [];
  this.dispY = [];
  this.cellLocation = [];
  this.isMoveable = [];
  this.neighbours = [];
  this.radius = [];
  this.radiusSquared = [];
  if (0.001 > this.forceConstant) {
    this.forceConstant = 0.001;
  }
  this.forceConstantSquared = this.forceConstant * this.forceConstant;
  for (i = 0;i < this.vertexArray.length;i++) {
    var vertex = this.vertexArray[i];
    this.cellLocation[i] = [];
    var id = mxObjectIdentity.get(vertex);
    this.indices[id] = i;
    var bounds = this.getVertexBounds(vertex);
    var j = bounds.width;
    var height = bounds.height;
    var x = bounds.x;
    var y = bounds.y;
    this.cellLocation[i][0] = x + j / 2;
    this.cellLocation[i][1] = y + height / 2;
    this.radius[i] = Math.min(j, height);
    this.radiusSquared[i] = this.radius[i] * this.radius[i];
  }
  model.beginUpdate();
  try {
    for (i = 0;i < n;i++) {
      this.dispX[i] = 0;
      this.dispY[i] = 0;
      this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);
      var edges = this.graph.getConnections(this.vertexArray[i], parent);
      cells = this.graph.getOpposites(edges, this.vertexArray[i]);
      this.neighbours[i] = [];
      for (j = 0;j < cells.length;j++) {
        if (this.resetEdges) {
          this.graph.resetEdge(edges[j]);
        }
        if (this.disableEdgeStyle) {
          this.setEdgeStyleEnabled(edges[j], false);
        }
        id = mxObjectIdentity.get(cells[j]);
        var index = this.indices[id];
        this.neighbours[i][j] = null != index ? index : i;
      }
    }
    this.temperature = this.initialTemp;
    if (0 == this.maxIterations) {
      this.maxIterations = 20 * Math.sqrt(n);
    }
    for (this.iteration = 0;this.iteration < this.maxIterations;this.iteration++) {
      if (!this.allowedToRun) {
        return;
      }
      this.calcRepulsion();
      this.calcAttraction();
      this.calcPositions();
      this.reduceTemperature();
    }
    parent = cells = null;
    for (i = 0;i < this.vertexArray.length;i++) {
      vertex = this.vertexArray[i];
      if (this.isVertexMovable(vertex)) {
        bounds = this.getVertexBounds(vertex);
        if (null != bounds) {
          this.cellLocation[i][0] -= bounds.width / 2;
          this.cellLocation[i][1] -= bounds.height / 2;
          x = this.graph.snap(Math.round(this.cellLocation[i][0]));
          y = this.graph.snap(Math.round(this.cellLocation[i][1]));
          this.setVertexLocation(vertex, x, y);
          cells = null == cells ? x : Math.min(cells, x);
          parent = null == parent ? y : Math.min(parent, y);
        }
      }
    }
    i = -(cells || 0) + 1;
    vertex = -(parent || 0) + 1;
    if (null != initialBounds) {
      i += initialBounds.x;
      vertex += initialBounds.y;
    }
    this.graph.moveCells(this.vertexArray, i, vertex);
  } finally {
    model.endUpdate();
  }
};
mxFastOrganicLayout.prototype.calcPositions = function() {
  for (var index = 0;index < this.vertexArray.length;index++) {
    if (this.isMoveable[index]) {
      var deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);
      if (0.001 > deltaLength) {
        deltaLength = 0.001;
      }
      var c = this.dispX[index] / deltaLength * Math.min(deltaLength, this.temperature);
      deltaLength = this.dispY[index] / deltaLength * Math.min(deltaLength, this.temperature);
      this.dispX[index] = 0;
      this.dispY[index] = 0;
      this.cellLocation[index][0] += c;
      this.cellLocation[index][1] += deltaLength;
    }
  }
};
mxFastOrganicLayout.prototype.calcAttraction = function() {
  for (var i = 0;i < this.vertexArray.length;i++) {
    for (var k = 0;k < this.neighbours[i].length;k++) {
      var j = this.neighbours[i][k];
      if (i != j && (this.isMoveable[i] && this.isMoveable[j])) {
        var xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];
        var yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];
        var deltaLengthSquared = xDelta * xDelta + yDelta * yDelta - this.radiusSquared[i] - this.radiusSquared[j];
        if (deltaLengthSquared < this.minDistanceLimitSquared) {
          deltaLengthSquared = this.minDistanceLimitSquared;
        }
        var deltaLength = Math.sqrt(deltaLengthSquared);
        deltaLengthSquared /= this.forceConstant;
        xDelta = xDelta / deltaLength * deltaLengthSquared;
        yDelta = yDelta / deltaLength * deltaLengthSquared;
        this.dispX[i] -= xDelta;
        this.dispY[i] -= yDelta;
        this.dispX[j] += xDelta;
        this.dispY[j] += yDelta;
      }
    }
  }
};
mxFastOrganicLayout.prototype.calcRepulsion = function() {
  var vertexCount = this.vertexArray.length;
  for (var i = 0;i < vertexCount;i++) {
    for (var j = i;j < vertexCount;j++) {
      if (!this.allowedToRun) {
        return;
      }
      if (j != i && (this.isMoveable[i] && this.isMoveable[j])) {
        var xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];
        var yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];
        if (0 == xDelta) {
          xDelta = 0.01 + Math.random();
        }
        if (0 == yDelta) {
          yDelta = 0.01 + Math.random();
        }
        var deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);
        var force = deltaLength - this.radius[i] - this.radius[j];
        if (!(force > this.maxDistanceLimit)) {
          if (force < this.minDistanceLimit) {
            force = this.minDistanceLimit;
          }
          force = this.forceConstantSquared / force;
          xDelta = xDelta / deltaLength * force;
          yDelta = yDelta / deltaLength * force;
          this.dispX[i] += xDelta;
          this.dispY[i] += yDelta;
          this.dispX[j] -= xDelta;
          this.dispY[j] -= yDelta;
        }
      }
    }
  }
};
mxFastOrganicLayout.prototype.reduceTemperature = function() {
  this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
};
function mxCircleLayout(graph, radius) {
  mxGraphLayout.call(this, graph);
  this.radius = null != radius ? radius : 100;
}
mxCircleLayout.prototype = new mxGraphLayout;
mxCircleLayout.prototype.constructor = mxCircleLayout;
mxCircleLayout.prototype.radius = null;
mxCircleLayout.prototype.moveCircle = false;
mxCircleLayout.prototype.x0 = 0;
mxCircleLayout.prototype.y0 = 0;
mxCircleLayout.prototype.resetEdges = true;
mxCircleLayout.prototype.disableEdgeStyle = true;
mxCircleLayout.prototype.execute = function(parent) {
  var model = this.graph.getModel();
  model.beginUpdate();
  try {
    var max = 0;
    var top = null;
    var left = null;
    var vertices = [];
    var childCount = model.getChildCount(parent);
    for (var i = 0;i < childCount;i++) {
      var cell = model.getChildAt(parent, i);
      if (this.isVertexIgnored(cell)) {
        if (!this.isEdgeIgnored(cell)) {
          if (this.resetEdges) {
            this.graph.resetEdge(cell);
          }
          if (this.disableEdgeStyle) {
            this.setEdgeStyleEnabled(cell, false);
          }
        }
      } else {
        vertices.push(cell);
        var bounds = this.getVertexBounds(cell);
        top = null == top ? bounds.y : Math.min(top, bounds.y);
        left = null == left ? bounds.x : Math.min(left, bounds.x);
        max = Math.max(max, Math.max(bounds.width, bounds.height));
      }
    }
    var r = this.getRadius(vertices.length, max);
    if (this.moveCircle) {
      left = this.x0;
      top = this.y0;
    }
    this.circle(vertices, r, left, top);
  } finally {
    model.endUpdate();
  }
};
mxCircleLayout.prototype.getRadius = function(count, max) {
  return Math.max(count * max / Math.PI, this.radius);
};
mxCircleLayout.prototype.circle = function(vertices, r, left, top) {
  var vertexCount = vertices.length;
  var phi = 2 * Math.PI / vertexCount;
  for (var i = 0;i < vertexCount;i++) {
    if (this.isVertexMovable(vertices[i])) {
      this.setVertexLocation(vertices[i], Math.round(left + r + r * Math.cos(i * phi - Math.PI / 2)), Math.round(top + r + r * Math.sin(i * phi - Math.PI / 2)));
    }
  }
};
function mxParallelEdgeLayout(graph) {
  mxGraphLayout.call(this, graph);
}
mxParallelEdgeLayout.prototype = new mxGraphLayout;
mxParallelEdgeLayout.prototype.constructor = mxParallelEdgeLayout;
mxParallelEdgeLayout.prototype.spacing = 20;
mxParallelEdgeLayout.prototype.checkOverlap = false;
mxParallelEdgeLayout.prototype.execute = function(parent, cells) {
  parent = this.findParallels(parent, cells);
  this.graph.model.beginUpdate();
  try {
    for (var i in parent) {
      var parallels = parent[i];
      if (1 < parallels.length) {
        this.layout(parallels);
      }
    }
  } finally {
    this.graph.model.endUpdate();
  }
};
mxParallelEdgeLayout.prototype.findParallels = function(cell, cells) {
  var lookup = [];
  var addCell = mxUtils.bind(this, function(cell) {
    if (!this.isEdgeIgnored(cell)) {
      var id = this.getEdgeId(cell);
      if (null != id) {
        if (null == lookup[id]) {
          lookup[id] = [];
        }
        lookup[id].push(cell);
      }
    }
  });
  if (null != cells) {
    for (var i = 0;i < cells.length;i++) {
      addCell(cells[i]);
    }
  } else {
    cells = this.graph.getModel();
    var childCount = cells.getChildCount(cell);
    for (i = 0;i < childCount;i++) {
      addCell(cells.getChildAt(cell, i));
    }
  }
  return lookup;
};
mxParallelEdgeLayout.prototype.getEdgeId = function(source) {
  var cell = this.graph.getView();
  var vertex = cell.getVisibleTerminal(source, true);
  cell = cell.getVisibleTerminal(source, false);
  var tmp = "";
  if (null != vertex && null != cell) {
    vertex = mxObjectIdentity.get(vertex);
    cell = mxObjectIdentity.get(cell);
    if (this.checkOverlap && (source = this.graph.view.getState(source), null != source && null != source.absolutePoints)) {
      tmp = [];
      for (var i = 0;i < source.absolutePoints.length;i++) {
        var pt = source.absolutePoints[i];
        if (null != pt) {
          tmp.push(pt.x, pt.y);
        }
      }
      tmp = tmp.join(",");
    }
    return(vertex > cell ? cell + "-" + vertex : vertex + "-" + cell) + tmp;
  }
  return null;
};
mxParallelEdgeLayout.prototype.layout = function(parallels) {
  var source = parallels[0];
  var y = this.graph.getView();
  var trg = this.graph.getModel();
  var src = trg.getGeometry(y.getVisibleTerminal(source, true));
  trg = trg.getGeometry(y.getVisibleTerminal(source, false));
  if (src == trg) {
    source = src.x + src.width + this.spacing;
    y = src.y + src.height / 2;
    for (var dx = 0;dx < parallels.length;dx++) {
      this.route(parallels[dx], source, y);
      source += this.spacing;
    }
  } else {
    if (null != src && null != trg) {
      source = src.x + src.width / 2;
      y = src.y + src.height / 2;
      dx = trg.x + trg.width / 2 - source;
      var dy = trg.y + trg.height / 2 - y;
      trg = Math.sqrt(dx * dx + dy * dy);
      if (0 < trg) {
        src = dy * this.spacing / trg;
        trg = dx * this.spacing / trg;
        source = source + dx / 2 + src * (parallels.length - 1) / 2;
        y = y + dy / 2 - trg * (parallels.length - 1) / 2;
        for (dx = 0;dx < parallels.length;dx++) {
          this.route(parallels[dx], source, y);
          source -= src;
          y += trg;
        }
      }
    }
  }
};
mxParallelEdgeLayout.prototype.route = function(cell, source, y) {
  if (this.graph.isCellMovable(cell)) {
    this.setEdgePoints(cell, [new mxPoint(source, y)]);
  }
};
function mxCompositeLayout(graph, layouts, master) {
  mxGraphLayout.call(this, graph);
  this.layouts = layouts;
  this.master = master;
}
mxCompositeLayout.prototype = new mxGraphLayout;
mxCompositeLayout.prototype.constructor = mxCompositeLayout;
mxCompositeLayout.prototype.layouts = null;
mxCompositeLayout.prototype.master = null;
mxCompositeLayout.prototype.moveCell = function(y, x, cell) {
  if (null != this.master) {
    this.master.moveCell.apply(this.master, arguments);
  } else {
    this.layouts[0].moveCell.apply(this.layouts[0], arguments);
  }
};
mxCompositeLayout.prototype.execute = function(parent) {
  var model = this.graph.getModel();
  model.beginUpdate();
  try {
    for (var i = 0;i < this.layouts.length;i++) {
      this.layouts[i].execute.apply(this.layouts[i], arguments);
    }
  } finally {
    model.endUpdate();
  }
};
function mxEdgeLabelLayout(graph, radius) {
  mxGraphLayout.call(this, graph);
}
mxEdgeLabelLayout.prototype = new mxGraphLayout;
mxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout;
mxEdgeLabelLayout.prototype.execute = function(parent) {
  var view = this.graph.view;
  var model = this.graph.getModel();
  var edges = [];
  var vertices = [];
  var childCount = model.getChildCount(parent);
  for (var i = 0;i < childCount;i++) {
    var cell = model.getChildAt(parent, i);
    var state = view.getState(cell);
    if (null != state) {
      if (this.isVertexIgnored(cell)) {
        if (!this.isEdgeIgnored(cell)) {
          edges.push(state);
        }
      } else {
        vertices.push(state);
      }
    }
  }
  this.placeLabels(vertices, edges);
};
mxEdgeLabelLayout.prototype.placeLabels = function(v, e) {
  var model = this.graph.getModel();
  model.beginUpdate();
  try {
    for (var i = 0;i < e.length;i++) {
      var edge = e[i];
      if (null != edge && (null != edge.text && null != edge.text.boundingBox)) {
        for (var j = 0;j < v.length;j++) {
          var vertex = v[j];
          if (null != vertex) {
            this.avoid(edge, vertex);
          }
        }
      }
    }
  } finally {
    model.endUpdate();
  }
};
mxEdgeLabelLayout.prototype.avoid = function(edge, x) {
  var model = this.graph.getModel();
  var state = edge.text.boundingBox;
  if (mxUtils.intersects(state, x)) {
    var dy = -state.y - state.height + x.y;
    var dist = -state.y + x.y + x.height;
    dy = Math.abs(dy) < Math.abs(dist) ? dy : dist;
    dist = -state.x - state.width + x.x;
    x = -state.x + x.x + x.width;
    x = Math.abs(dist) < Math.abs(x) ? dist : x;
    if (Math.abs(x) < Math.abs(dy)) {
      dy = 0;
    } else {
      x = 0;
    }
    state = model.getGeometry(edge.cell);
    if (null != state) {
      state = state.clone();
      if (null != state.offset) {
        state.offset.x += x;
        state.offset.y += dy;
      } else {
        state.offset = new mxPoint(x, dy);
      }
      model.setGeometry(edge.cell, state);
    }
  }
};
function mxGraphAbstractHierarchyCell() {
  this.x = [];
  this.y = [];
  this.temp = [];
}
mxGraphAbstractHierarchyCell.prototype.maxRank = -1;
mxGraphAbstractHierarchyCell.prototype.minRank = -1;
mxGraphAbstractHierarchyCell.prototype.x = null;
mxGraphAbstractHierarchyCell.prototype.y = null;
mxGraphAbstractHierarchyCell.prototype.width = 0;
mxGraphAbstractHierarchyCell.prototype.height = 0;
mxGraphAbstractHierarchyCell.prototype.nextLayerConnectedCells = null;
mxGraphAbstractHierarchyCell.prototype.previousLayerConnectedCells = null;
mxGraphAbstractHierarchyCell.prototype.temp = null;
mxGraphAbstractHierarchyCell.prototype.getNextLayerConnectedCells = function(layer) {
  return null;
};
mxGraphAbstractHierarchyCell.prototype.getPreviousLayerConnectedCells = function(layer) {
  return null;
};
mxGraphAbstractHierarchyCell.prototype.isEdge = function() {
  return false;
};
mxGraphAbstractHierarchyCell.prototype.isVertex = function() {
  return false;
};
mxGraphAbstractHierarchyCell.prototype.getGeneralPurposeVariable = function(layer) {
  return null;
};
mxGraphAbstractHierarchyCell.prototype.setGeneralPurposeVariable = function(layer, value) {
  return null;
};
mxGraphAbstractHierarchyCell.prototype.setX = function(layer, value) {
  if (this.isVertex()) {
    this.x[0] = value;
  } else {
    if (this.isEdge()) {
      this.x[layer - this.minRank - 1] = value;
    }
  }
};
mxGraphAbstractHierarchyCell.prototype.getX = function(layer) {
  return this.isVertex() ? this.x[0] : this.isEdge() ? this.x[layer - this.minRank - 1] : 0;
};
mxGraphAbstractHierarchyCell.prototype.setY = function(layer, value) {
  if (this.isVertex()) {
    this.y[0] = value;
  } else {
    if (this.isEdge()) {
      this.y[layer - this.minRank - 1] = value;
    }
  }
};
function mxGraphHierarchyNode(cell) {
  mxGraphAbstractHierarchyCell.apply(this, arguments);
  this.cell = cell;
  this.id = mxObjectIdentity.get(cell);
  this.connectsAsTarget = [];
  this.connectsAsSource = [];
}
mxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell;
mxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode;
mxGraphHierarchyNode.prototype.cell = null;
mxGraphHierarchyNode.prototype.id = null;
mxGraphHierarchyNode.prototype.connectsAsTarget = null;
mxGraphHierarchyNode.prototype.connectsAsSource = null;
mxGraphHierarchyNode.prototype.hashCode = false;
mxGraphHierarchyNode.prototype.getRankValue = function(layer) {
  return this.maxRank;
};
mxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function(layer) {
  if (null == this.nextLayerConnectedCells) {
    this.nextLayerConnectedCells = [];
    this.nextLayerConnectedCells[0] = [];
    for (var i = 0;i < this.connectsAsTarget.length;i++) {
      var edge = this.connectsAsTarget[i];
      if (-1 == edge.maxRank || edge.maxRank == layer + 1) {
        this.nextLayerConnectedCells[0].push(edge.source);
      } else {
        this.nextLayerConnectedCells[0].push(edge);
      }
    }
  }
  return this.nextLayerConnectedCells[0];
};
mxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function(layer) {
  if (null == this.previousLayerConnectedCells) {
    this.previousLayerConnectedCells = [];
    this.previousLayerConnectedCells[0] = [];
    for (var i = 0;i < this.connectsAsSource.length;i++) {
      var edge = this.connectsAsSource[i];
      if (-1 == edge.minRank || edge.minRank == layer - 1) {
        this.previousLayerConnectedCells[0].push(edge.target);
      } else {
        this.previousLayerConnectedCells[0].push(edge);
      }
    }
  }
  return this.previousLayerConnectedCells[0];
};
mxGraphHierarchyNode.prototype.isVertex = function() {
  return true;
};
mxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function(layer) {
  return this.temp[0];
};
mxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function(layer, value) {
  this.temp[0] = value;
};
mxGraphHierarchyNode.prototype.isAncestor = function(parent) {
  if (null != parent && (null != this.hashCode && (null != parent.hashCode && this.hashCode.length < parent.hashCode.length))) {
    if (this.hashCode == parent.hashCode) {
      return true;
    }
    if (null == this.hashCode || null == this.hashCode) {
      return false;
    }
    for (var i = 0;i < this.hashCode.length;i++) {
      if (this.hashCode[i] != parent.hashCode[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
};
mxGraphHierarchyNode.prototype.getCoreCell = function() {
  return this.cell;
};
function mxGraphHierarchyEdge(edges) {
  mxGraphAbstractHierarchyCell.apply(this, arguments);
  this.edges = edges;
  this.ids = [];
  for (var i = 0;i < edges.length;i++) {
    this.ids.push(mxObjectIdentity.get(edges[i]));
  }
}
mxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell;
mxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge;
mxGraphHierarchyEdge.prototype.edges = null;
mxGraphHierarchyEdge.prototype.ids = null;
mxGraphHierarchyEdge.prototype.source = null;
mxGraphHierarchyEdge.prototype.target = null;
mxGraphHierarchyEdge.prototype.isReversed = false;
mxGraphHierarchyEdge.prototype.invert = function(layer) {
  layer = this.source;
  this.source = this.target;
  this.target = layer;
  this.isReversed = !this.isReversed;
};
mxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function(layer) {
  if (null == this.nextLayerConnectedCells) {
    this.nextLayerConnectedCells = [];
    for (var i = 0;i < this.temp.length;i++) {
      this.nextLayerConnectedCells[i] = [];
      if (i == this.temp.length - 1) {
        this.nextLayerConnectedCells[i].push(this.source);
      } else {
        this.nextLayerConnectedCells[i].push(this);
      }
    }
  }
  return this.nextLayerConnectedCells[layer - this.minRank - 1];
};
mxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function(layer) {
  if (null == this.previousLayerConnectedCells) {
    this.previousLayerConnectedCells = [];
    for (var i = 0;i < this.temp.length;i++) {
      this.previousLayerConnectedCells[i] = [];
      if (0 == i) {
        this.previousLayerConnectedCells[i].push(this.target);
      } else {
        this.previousLayerConnectedCells[i].push(this);
      }
    }
  }
  return this.previousLayerConnectedCells[layer - this.minRank - 1];
};
mxGraphHierarchyEdge.prototype.isEdge = function() {
  return true;
};
mxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function(layer) {
  return this.temp[layer - this.minRank - 1];
};
mxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function(layer, value) {
  this.temp[layer - this.minRank - 1] = value;
};
mxGraphHierarchyEdge.prototype.getCoreCell = function() {
  return null != this.edges && 0 < this.edges.length ? this.edges[0] : null;
};
function mxGraphHierarchyModel(layout, vertices, internalVertices, parent, parallels) {
  layout.getGraph();
  this.tightenToSource = parallels;
  this.roots = internalVertices;
  this.parent = parent;
  this.vertexMapper = new mxDictionary;
  this.edgeMapper = new mxDictionary;
  this.maxRank = 0;
  internalVertices = [];
  if (null == vertices) {
    vertices = this.graph.getChildVertices(parent);
  }
  this.maxRank = this.SOURCESCANSTARTRANK;
  this.createInternalCells(layout, vertices, internalVertices);
  for (parent = 0;parent < vertices.length;parent++) {
    parallels = internalVertices[parent].connectsAsSource;
    for (var i = 0;i < parallels.length;i++) {
      var edge = parallels[i];
      var source = edge.edges;
      if (null != source && 0 < source.length) {
        source = source[0];
        var cell = layout.getVisibleTerminal(source, false);
        cell = this.vertexMapper.get(cell);
        if (internalVertices[parent] == cell) {
          cell = layout.getVisibleTerminal(source, true);
          cell = this.vertexMapper.get(cell);
        }
        if (null != cell) {
          if (internalVertices[parent] != cell) {
            edge.target = cell;
            if (0 == cell.connectsAsTarget.length) {
              cell.connectsAsTarget = [];
            }
            if (0 > mxUtils.indexOf(cell.connectsAsTarget, edge)) {
              cell.connectsAsTarget.push(edge);
            }
          }
        }
      }
    }
    internalVertices[parent].temp[0] = 1;
  }
}
mxGraphHierarchyModel.prototype.maxRank = null;
mxGraphHierarchyModel.prototype.vertexMapper = null;
mxGraphHierarchyModel.prototype.edgeMapper = null;
mxGraphHierarchyModel.prototype.ranks = null;
mxGraphHierarchyModel.prototype.roots = null;
mxGraphHierarchyModel.prototype.parent = null;
mxGraphHierarchyModel.prototype.dfsCount = 0;
mxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 1E8;
mxGraphHierarchyModel.prototype.tightenToSource = false;
mxGraphHierarchyModel.prototype.createInternalCells = function(layout, vertices, internalVertices) {
  var graph = layout.getGraph();
  for (var i = 0;i < vertices.length;i++) {
    internalVertices[i] = new mxGraphHierarchyNode(vertices[i]);
    this.vertexMapper.put(vertices[i], internalVertices[i]);
    var conns = layout.getEdges(vertices[i]);
    internalVertices[i].connectsAsSource = [];
    for (var j = 0;j < conns.length;j++) {
      var cell = layout.getVisibleTerminal(conns[j], false);
      if (cell != vertices[i] && (layout.graph.model.isVertex(cell) && !layout.isVertexIgnored(cell))) {
        var undirectedEdges = layout.getEdgesBetween(vertices[i], cell, false);
        cell = layout.getEdgesBetween(vertices[i], cell, true);
        if (null != undirectedEdges && (0 < undirectedEdges.length && (null == this.edgeMapper.get(undirectedEdges[0]) && 2 * cell.length >= undirectedEdges.length))) {
          cell = new mxGraphHierarchyEdge(undirectedEdges);
          for (var k = 0;k < undirectedEdges.length;k++) {
            var edge = undirectedEdges[k];
            this.edgeMapper.put(edge, cell);
            graph.resetEdge(edge);
            if (layout.disableEdgeStyle) {
              layout.setEdgeStyleEnabled(edge, false);
              layout.setOrthogonalEdge(edge, true);
            }
          }
          cell.source = internalVertices[i];
          if (0 > mxUtils.indexOf(internalVertices[i].connectsAsSource, cell)) {
            internalVertices[i].connectsAsSource.push(cell);
          }
        }
      }
    }
    internalVertices[i].temp[0] = 0;
  }
};
mxGraphHierarchyModel.prototype.initialRank = function() {
  var startNodes = [];
  if (null != this.roots) {
    for (var i = 0;i < this.roots.length;i++) {
      var internalNode = this.vertexMapper.get(this.roots[i]);
      if (null != internalNode) {
        startNodes.push(internalNode);
      }
    }
  }
  var j = this.vertexMapper.getValues();
  for (i = 0;i < j.length;i++) {
    j[i].temp[0] = -1;
  }
  for (var startNodesCopy = startNodes.slice();0 < startNodes.length;) {
    internalNode = startNodes[0];
    var layerDeterminingEdges = internalNode.connectsAsTarget;
    var incomingEdges = internalNode.connectsAsSource;
    var k = true;
    var minimumLayer = this.SOURCESCANSTARTRANK;
    for (i = 0;i < layerDeterminingEdges.length;i++) {
      var internalEdge = layerDeterminingEdges[i];
      if (5270620 == internalEdge.temp[0]) {
        internalEdge = internalEdge.source;
        minimumLayer = Math.min(minimumLayer, internalEdge.temp[0] - 1);
      } else {
        k = false;
        break;
      }
    }
    if (k) {
      internalNode.temp[0] = minimumLayer;
      this.maxRank = Math.min(this.maxRank, minimumLayer);
      if (null != incomingEdges) {
        for (i = 0;i < incomingEdges.length;i++) {
          internalEdge = incomingEdges[i];
          internalEdge.temp[0] = 5270620;
          internalEdge = internalEdge.target;
          if (-1 == internalEdge.temp[0]) {
            startNodes.push(internalEdge);
            internalEdge.temp[0] = -2;
          }
        }
      }
      startNodes.shift();
    } else {
      if (i = startNodes.shift(), startNodes.push(internalNode), i == internalNode && 1 == startNodes.length) {
        break;
      }
    }
  }
  for (i = 0;i < j.length;i++) {
    j[i].temp[0] -= this.maxRank;
  }
  for (i = 0;i < startNodesCopy.length;i++) {
    internalNode = startNodesCopy[i];
    startNodes = 0;
    layerDeterminingEdges = internalNode.connectsAsSource;
    for (j = 0;j < layerDeterminingEdges.length;j++) {
      internalEdge = layerDeterminingEdges[j];
      internalEdge = internalEdge.target;
      internalNode.temp[0] = Math.max(startNodes, internalEdge.temp[0] + 1);
      startNodes = internalNode.temp[0];
    }
  }
  this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;
};
mxGraphHierarchyModel.prototype.fixRanks = function() {
  var rankList = [];
  this.ranks = [];
  for (var i = 0;i < this.maxRank + 1;i++) {
    rankList[i] = [];
    this.ranks[i] = rankList[i];
  }
  var rootsArray = null;
  if (null != this.roots) {
    var modelRoots = this.roots;
    rootsArray = [];
    for (i = 0;i < modelRoots.length;i++) {
      var internalNode = this.vertexMapper.get(modelRoots[i]);
      rootsArray[i] = internalNode;
    }
  }
  this.visit(function(i, node, edge, flex, editor) {
    if (0 == editor) {
      if (0 > node.maxRank) {
        if (0 > node.minRank) {
          rankList[node.temp[0]].push(node);
          node.maxRank = node.temp[0];
          node.minRank = node.temp[0];
          node.temp[0] = rankList[node.maxRank].length - 1;
        }
      }
    }
    if (null != i && (null != edge && 1 < i.maxRank - node.maxRank)) {
      edge.maxRank = i.maxRank;
      edge.minRank = node.maxRank;
      edge.temp = [];
      edge.x = [];
      edge.y = [];
      for (i = edge.minRank + 1;i < edge.maxRank;i++) {
        rankList[i].push(edge);
        edge.setGeneralPurposeVariable(i, rankList[i].length - 1);
      }
    }
  }, rootsArray, false, null);
};
mxGraphHierarchyModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes) {
  if (null != dfsRoots) {
    for (var i = 0;i < dfsRoots.length;i++) {
      var internalNode = dfsRoots[i];
      if (null != internalNode) {
        if (null == seenNodes) {
          seenNodes = {};
        }
        if (trackAncestors) {
          internalNode.hashCode = [];
          internalNode.hashCode[0] = this.dfsCount;
          internalNode.hashCode[1] = i;
          this.extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i, 0);
        } else {
          this.dfs(null, internalNode, null, visitor, seenNodes, 0);
        }
      }
    }
    this.dfsCount++;
  }
};
mxGraphHierarchyModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer) {
  if (null != root) {
    var internalEdge = root.id;
    if (null == seen[internalEdge]) {
      seen[internalEdge] = root;
      visitor(parent, root, connectingEdge, layer, 0);
      parent = root.connectsAsSource.slice();
      for (connectingEdge = 0;connectingEdge < parent.length;connectingEdge++) {
        internalEdge = parent[connectingEdge];
        this.dfs(root, internalEdge.target, internalEdge, visitor, seen, layer + 1);
      }
    } else {
      visitor(parent, root, connectingEdge, layer, 1);
    }
  }
};
mxGraphHierarchyModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {
  if (null != root) {
    if (null == parent || (null != root.hashCode && root.hashCode[0] == parent.hashCode[0] || (ancestors = parent.hashCode.length + 1, root.hashCode = parent.hashCode.slice(), root.hashCode[ancestors - 1] = childHash)), childHash = root.id, null == seen[childHash]) {
      seen[childHash] = root;
      visitor(parent, root, connectingEdge, layer, 0);
      parent = root.connectsAsSource.slice();
      for (connectingEdge = 0;connectingEdge < parent.length;connectingEdge++) {
        childHash = parent[connectingEdge];
        this.extendedDfs(root, childHash.target, childHash, visitor, seen, root.hashCode, connectingEdge, layer + 1);
      }
    } else {
      visitor(parent, root, connectingEdge, layer, 1);
    }
  }
};
function mxSwimlaneModel(layout, vertices, internalVertices, parent, parallels) {
  layout.getGraph();
  this.tightenToSource = parallels;
  this.roots = internalVertices;
  this.parent = parent;
  this.vertexMapper = new mxDictionary;
  this.edgeMapper = new mxDictionary;
  this.maxRank = 0;
  internalVertices = [];
  if (null == vertices) {
    vertices = this.graph.getChildVertices(parent);
  }
  this.maxRank = this.SOURCESCANSTARTRANK;
  this.createInternalCells(layout, vertices, internalVertices);
  for (parent = 0;parent < vertices.length;parent++) {
    parallels = internalVertices[parent].connectsAsSource;
    for (var i = 0;i < parallels.length;i++) {
      var edge = parallels[i];
      var source = edge.edges;
      if (null != source && 0 < source.length) {
        source = source[0];
        var cell = layout.getVisibleTerminal(source, false);
        cell = this.vertexMapper.get(cell);
        if (internalVertices[parent] == cell) {
          cell = layout.getVisibleTerminal(source, true);
          cell = this.vertexMapper.get(cell);
        }
        if (null != cell) {
          if (internalVertices[parent] != cell) {
            edge.target = cell;
            if (0 == cell.connectsAsTarget.length) {
              cell.connectsAsTarget = [];
            }
            if (0 > mxUtils.indexOf(cell.connectsAsTarget, edge)) {
              cell.connectsAsTarget.push(edge);
            }
          }
        }
      }
    }
    internalVertices[parent].temp[0] = 1;
  }
}
mxSwimlaneModel.prototype.maxRank = null;
mxSwimlaneModel.prototype.vertexMapper = null;
mxSwimlaneModel.prototype.edgeMapper = null;
mxSwimlaneModel.prototype.ranks = null;
mxSwimlaneModel.prototype.roots = null;
mxSwimlaneModel.prototype.parent = null;
mxSwimlaneModel.prototype.dfsCount = 0;
mxSwimlaneModel.prototype.SOURCESCANSTARTRANK = 1E8;
mxSwimlaneModel.prototype.tightenToSource = false;
mxSwimlaneModel.prototype.ranksPerGroup = null;
mxSwimlaneModel.prototype.createInternalCells = function(layout, vertices, internalVertices) {
  var graph = layout.getGraph();
  var swimlanes = layout.swimlanes;
  for (var i = 0;i < vertices.length;i++) {
    internalVertices[i] = new mxGraphHierarchyNode(vertices[i]);
    this.vertexMapper.put(vertices[i], internalVertices[i]);
    internalVertices[i].swimlaneIndex = -1;
    for (var conns = 0;conns < swimlanes.length;conns++) {
      if (graph.model.getParent(vertices[i]) == swimlanes[conns]) {
        internalVertices[i].swimlaneIndex = conns;
        break;
      }
    }
    conns = layout.getEdges(vertices[i]);
    internalVertices[i].connectsAsSource = [];
    for (var j = 0;j < conns.length;j++) {
      var cell = layout.getVisibleTerminal(conns[j], false);
      if (cell != vertices[i] && (layout.graph.model.isVertex(cell) && !layout.isVertexIgnored(cell))) {
        var undirectedEdges = layout.getEdgesBetween(vertices[i], cell, false);
        cell = layout.getEdgesBetween(vertices[i], cell, true);
        if (null != undirectedEdges && (0 < undirectedEdges.length && (null == this.edgeMapper.get(undirectedEdges[0]) && 2 * cell.length >= undirectedEdges.length))) {
          cell = new mxGraphHierarchyEdge(undirectedEdges);
          for (var k = 0;k < undirectedEdges.length;k++) {
            var edge = undirectedEdges[k];
            this.edgeMapper.put(edge, cell);
            graph.resetEdge(edge);
            if (layout.disableEdgeStyle) {
              layout.setEdgeStyleEnabled(edge, false);
              layout.setOrthogonalEdge(edge, true);
            }
          }
          cell.source = internalVertices[i];
          if (0 > mxUtils.indexOf(internalVertices[i].connectsAsSource, cell)) {
            internalVertices[i].connectsAsSource.push(cell);
          }
        }
      }
    }
    internalVertices[i].temp[0] = 0;
  }
};
mxSwimlaneModel.prototype.initialRank = function() {
  this.ranksPerGroup = [];
  var startNodes = [];
  var upperRank = {};
  if (null != this.roots) {
    for (var i = 0;i < this.roots.length;i++) {
      var internalNode = this.vertexMapper.get(this.roots[i]);
      this.maxChainDfs(null, internalNode, null, upperRank, 0);
      if (null != internalNode) {
        startNodes.push(internalNode);
      }
    }
  }
  internalNode = [];
  upperRank = [];
  for (i = this.ranksPerGroup.length - 1;0 <= i;i--) {
    internalNode[i] = i == this.ranksPerGroup.length - 1 ? 0 : upperRank[i + 1] + 1;
    upperRank[i] = internalNode[i] + this.ranksPerGroup[i];
  }
  this.maxRank = upperRank[0];
  internalNode = this.vertexMapper.getValues();
  for (i = 0;i < internalNode.length;i++) {
    internalNode[i].temp[0] = -1;
  }
  for (startNodes.slice();0 < startNodes.length;) {
    internalNode = startNodes[0];
    var outgoingEdges = internalNode.connectsAsTarget;
    var incomingEdges = internalNode.connectsAsSource;
    var g = true;
    var minimumLayer = upperRank[0];
    for (i = 0;i < outgoingEdges.length;i++) {
      var internalEdge = outgoingEdges[i];
      if (5270620 == internalEdge.temp[0]) {
        internalEdge = internalEdge.source;
        minimumLayer = Math.min(minimumLayer, internalEdge.temp[0] - 1);
      } else {
        g = false;
        break;
      }
    }
    if (g) {
      if (minimumLayer > upperRank[internalNode.swimlaneIndex]) {
        minimumLayer = upperRank[internalNode.swimlaneIndex];
      }
      internalNode.temp[0] = minimumLayer;
      if (null != incomingEdges) {
        for (i = 0;i < incomingEdges.length;i++) {
          internalEdge = incomingEdges[i];
          internalEdge.temp[0] = 5270620;
          internalEdge = internalEdge.target;
          if (-1 == internalEdge.temp[0]) {
            startNodes.push(internalEdge);
            internalEdge.temp[0] = -2;
          }
        }
      }
      startNodes.shift();
    } else {
      if (i = startNodes.shift(), startNodes.push(internalNode), i == internalNode && 1 == startNodes.length) {
        break;
      }
    }
  }
};
mxSwimlaneModel.prototype.maxChainDfs = function(parent, root, connectingEdge, seen, chainCount) {
  if (null != root && (parent = mxCellPath.create(root.cell), null == seen[parent])) {
    seen[parent] = root;
    parent = root.swimlaneIndex;
    if (null == this.ranksPerGroup[parent] || this.ranksPerGroup[parent] < chainCount) {
      this.ranksPerGroup[parent] = chainCount;
    }
    parent = root.connectsAsSource.slice();
    for (connectingEdge = 0;connectingEdge < parent.length;connectingEdge++) {
      var internalEdge = parent[connectingEdge];
      var targetNode = internalEdge.target;
      if (root.swimlaneIndex < targetNode.swimlaneIndex) {
        this.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null, true), 0);
      } else {
        if (root.swimlaneIndex == targetNode.swimlaneIndex) {
          this.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null, true), chainCount + 1);
        }
      }
    }
  }
};
mxSwimlaneModel.prototype.fixRanks = function() {
  var rankList = [];
  this.ranks = [];
  for (var i = 0;i < this.maxRank + 1;i++) {
    rankList[i] = [];
    this.ranks[i] = rankList[i];
  }
  var rootsArray = null;
  if (null != this.roots) {
    var modelRoots = this.roots;
    rootsArray = [];
    for (i = 0;i < modelRoots.length;i++) {
      var internalNode = this.vertexMapper.get(modelRoots[i]);
      rootsArray[i] = internalNode;
    }
  }
  this.visit(function(i, node, edge, flex, editor) {
    if (0 == editor) {
      if (0 > node.maxRank) {
        if (0 > node.minRank) {
          rankList[node.temp[0]].push(node);
          node.maxRank = node.temp[0];
          node.minRank = node.temp[0];
          node.temp[0] = rankList[node.maxRank].length - 1;
        }
      }
    }
    if (null != i && (null != edge && 1 < i.maxRank - node.maxRank)) {
      edge.maxRank = i.maxRank;
      edge.minRank = node.maxRank;
      edge.temp = [];
      edge.x = [];
      edge.y = [];
      for (i = edge.minRank + 1;i < edge.maxRank;i++) {
        rankList[i].push(edge);
        edge.setGeneralPurposeVariable(i, rankList[i].length - 1);
      }
    }
  }, rootsArray, false, null);
};
mxSwimlaneModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes) {
  if (null != dfsRoots) {
    for (var i = 0;i < dfsRoots.length;i++) {
      var internalNode = dfsRoots[i];
      if (null != internalNode) {
        if (null == seenNodes) {
          seenNodes = {};
        }
        if (trackAncestors) {
          internalNode.hashCode = [];
          internalNode.hashCode[0] = this.dfsCount;
          internalNode.hashCode[1] = i;
          this.extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i, 0);
        } else {
          this.dfs(null, internalNode, null, visitor, seenNodes, 0);
        }
      }
    }
    this.dfsCount++;
  }
};
mxSwimlaneModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer) {
  if (null != root) {
    var internalEdge = root.id;
    if (null == seen[internalEdge]) {
      seen[internalEdge] = root;
      visitor(parent, root, connectingEdge, layer, 0);
      parent = root.connectsAsSource.slice();
      for (connectingEdge = 0;connectingEdge < parent.length;connectingEdge++) {
        internalEdge = parent[connectingEdge];
        this.dfs(root, internalEdge.target, internalEdge, visitor, seen, layer + 1);
      }
    } else {
      visitor(parent, root, connectingEdge, layer, 1);
    }
  }
};
mxSwimlaneModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, internalEdge, i, layer) {
  if (null != root) {
    if (null == parent || (null != root.hashCode && root.hashCode[0] == parent.hashCode[0] || (internalEdge = parent.hashCode.length + 1, root.hashCode = parent.hashCode.slice(), root.hashCode[internalEdge - 1] = i)), i = root.id, null == seen[i]) {
      seen[i] = root;
      visitor(parent, root, connectingEdge, layer, 0);
      parent = root.connectsAsSource.slice();
      connectingEdge = root.connectsAsTarget.slice();
      for (i = 0;i < parent.length;i++) {
        internalEdge = parent[i];
        var targetNode = internalEdge.target;
        if (root.swimlaneIndex <= targetNode.swimlaneIndex) {
          this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1);
        }
      }
      for (i = 0;i < connectingEdge.length;i++) {
        internalEdge = connectingEdge[i];
        targetNode = internalEdge.source;
        if (root.swimlaneIndex < targetNode.swimlaneIndex) {
          this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1);
        }
      }
    } else {
      visitor(parent, root, connectingEdge, layer, 1);
    }
  }
};
function mxHierarchicalLayoutStage() {
}
mxHierarchicalLayoutStage.prototype.execute = function(parent) {
};
function mxMedianHybridCrossingReduction(layout) {
  this.layout = layout;
}
mxMedianHybridCrossingReduction.prototype = new mxHierarchicalLayoutStage;
mxMedianHybridCrossingReduction.prototype.constructor = mxMedianHybridCrossingReduction;
mxMedianHybridCrossingReduction.prototype.layout = null;
mxMedianHybridCrossingReduction.prototype.maxIterations = 24;
mxMedianHybridCrossingReduction.prototype.nestedBestRanks = null;
mxMedianHybridCrossingReduction.prototype.currentBestCrossings = 0;
mxMedianHybridCrossingReduction.prototype.iterationsWithoutImprovement = 0;
mxMedianHybridCrossingReduction.prototype.maxNoImprovementIterations = 2;
mxMedianHybridCrossingReduction.prototype.execute = function(parent) {
  parent = this.layout.getModel();
  this.nestedBestRanks = [];
  for (var i = 0;i < parent.ranks.length;i++) {
    this.nestedBestRanks[i] = parent.ranks[i].slice();
  }
  var ranks = 0;
  var rankList = this.calculateCrossings(parent);
  for (i = 0;i < this.maxIterations && ranks < this.maxNoImprovementIterations;i++) {
    this.weightedMedian(i, parent);
    this.transpose(i, parent);
    var j = this.calculateCrossings(parent);
    if (j < rankList) {
      rankList = j;
      for (j = ranks = 0;j < this.nestedBestRanks.length;j++) {
        var rank = parent.ranks[j];
        for (var k = 0;k < rank.length;k++) {
          var cell = rank[k];
          this.nestedBestRanks[j][cell.getGeneralPurposeVariable(j)] = cell;
        }
      }
    } else {
      ranks++;
      for (j = 0;j < this.nestedBestRanks.length;j++) {
        rank = parent.ranks[j];
        for (k = 0;k < rank.length;k++) {
          cell = rank[k];
          cell.setGeneralPurposeVariable(j, k);
        }
      }
    }
    if (0 == rankList) {
      break;
    }
  }
  ranks = [];
  rankList = [];
  for (i = 0;i < parent.maxRank + 1;i++) {
    rankList[i] = [];
    ranks[i] = rankList[i];
  }
  for (i = 0;i < this.nestedBestRanks.length;i++) {
    for (j = 0;j < this.nestedBestRanks[i].length;j++) {
      rankList[i].push(this.nestedBestRanks[i][j]);
    }
  }
  parent.ranks = ranks;
};
mxMedianHybridCrossingReduction.prototype.calculateCrossings = function(model) {
  var numRanks = model.ranks.length;
  var totalCrossings = 0;
  for (var i = 1;i < numRanks;i++) {
    totalCrossings += this.calculateRankCrossing(i, model);
  }
  return totalCrossings;
};
mxMedianHybridCrossingReduction.prototype.calculateRankCrossing = function(i, j) {
  var totalCrossings = 0;
  var rank = j.ranks[i];
  var tree = j.ranks[i - 1];
  var tmpIndices = [];
  for (j = 0;j < rank.length;j++) {
    var node = rank[j];
    var rankPosition = node.getGeneralPurposeVariable(i);
    node = node.getPreviousLayerConnectedCells(i);
    var nodeIndices = [];
    for (var k = 0;k < node.length;k++) {
      var otherCellRankPosition = node[k].getGeneralPurposeVariable(i - 1);
      nodeIndices.push(otherCellRankPosition);
    }
    nodeIndices.sort(function(a, b) {
      return a - b;
    });
    tmpIndices[rankPosition] = nodeIndices;
  }
  i = [];
  for (j = 0;j < tmpIndices.length;j++) {
    i = i.concat(tmpIndices[j]);
  }
  for (rank = 1;rank < tree.length;) {
    rank <<= 1;
  }
  tmpIndices = 2 * rank - 1;
  --rank;
  tree = [];
  for (j = 0;j < tmpIndices;++j) {
    tree[j] = 0;
  }
  for (j = 0;j < i.length;j++) {
    tmpIndices = i[j] + rank;
    for (++tree[tmpIndices];0 < tmpIndices;) {
      if (tmpIndices % 2) {
        totalCrossings += tree[tmpIndices + 1];
      }
      tmpIndices = tmpIndices - 1 >> 1;
      ++tree[tmpIndices];
    }
  }
  return totalCrossings;
};
mxMedianHybridCrossingReduction.prototype.transpose = function(mainLoopIteration, model) {
  var c = true;
  for (var d = 0;c && 10 > d++;) {
    var nudge = 1 == mainLoopIteration % 2 && 1 == d % 2;
    c = false;
    for (var i = 0;i < model.ranks.length;i++) {
      var rank = model.ranks[i];
      var orderedCells = [];
      for (var j = 0;j < rank.length;j++) {
        var cell = rank[j];
        var leftCellAboveConnections = cell.getGeneralPurposeVariable(i);
        if (0 > leftCellAboveConnections) {
          leftCellAboveConnections = j;
        }
        orderedCells[leftCellAboveConnections] = cell;
      }
      var temp = null;
      var rightCellAboveConnections = null;
      var rightAbovePositions = null;
      var rightBelowPositions = null;
      var rightCell = null;
      for (j = 0;j < rank.length - 1;j++) {
        if (0 == j) {
          var leftCell = orderedCells[j];
          cell = leftCell.getNextLayerConnectedCells(i);
          leftCellAboveConnections = leftCell.getPreviousLayerConnectedCells(i);
          var leftAbovePositions = [];
          var leftBelowPositions = [];
          for (var k = 0;k < cell.length;k++) {
            leftAbovePositions[k] = cell[k].getGeneralPurposeVariable(i + 1);
          }
          for (k = 0;k < leftCellAboveConnections.length;k++) {
            leftBelowPositions[k] = leftCellAboveConnections[k].getGeneralPurposeVariable(i - 1);
          }
        } else {
          cell = temp;
          leftCellAboveConnections = rightCellAboveConnections;
          leftAbovePositions = rightAbovePositions;
          leftBelowPositions = rightBelowPositions;
          leftCell = rightCell;
        }
        rightCell = orderedCells[j + 1];
        temp = rightCell.getNextLayerConnectedCells(i);
        rightCellAboveConnections = rightCell.getPreviousLayerConnectedCells(i);
        rightAbovePositions = [];
        rightBelowPositions = [];
        for (k = 0;k < temp.length;k++) {
          rightAbovePositions[k] = temp[k].getGeneralPurposeVariable(i + 1);
        }
        for (k = 0;k < rightCellAboveConnections.length;k++) {
          rightBelowPositions[k] = rightCellAboveConnections[k].getGeneralPurposeVariable(i - 1);
        }
        var totalCurrentCrossings = 0;
        var totalSwitchedCrossings = 0;
        for (k = 0;k < leftAbovePositions.length;k++) {
          for (var ik = 0;ik < rightAbovePositions.length;ik++) {
            if (leftAbovePositions[k] > rightAbovePositions[ik]) {
              totalCurrentCrossings++;
            }
            if (leftAbovePositions[k] < rightAbovePositions[ik]) {
              totalSwitchedCrossings++;
            }
          }
        }
        for (k = 0;k < leftBelowPositions.length;k++) {
          for (ik = 0;ik < rightBelowPositions.length;ik++) {
            if (leftBelowPositions[k] > rightBelowPositions[ik]) {
              totalCurrentCrossings++;
            }
            if (leftBelowPositions[k] < rightBelowPositions[ik]) {
              totalSwitchedCrossings++;
            }
          }
        }
        if (totalSwitchedCrossings < totalCurrentCrossings || totalSwitchedCrossings == totalCurrentCrossings && nudge) {
          temp = leftCell.getGeneralPurposeVariable(i);
          leftCell.setGeneralPurposeVariable(i, rightCell.getGeneralPurposeVariable(i));
          rightCell.setGeneralPurposeVariable(i, temp);
          temp = cell;
          rightCellAboveConnections = leftCellAboveConnections;
          rightAbovePositions = leftAbovePositions;
          rightBelowPositions = leftBelowPositions;
          rightCell = leftCell;
          if (!nudge) {
            c = true;
          }
        }
      }
    }
  }
};
mxMedianHybridCrossingReduction.prototype.weightedMedian = function(downwardSweep, model) {
  if (downwardSweep = 0 == downwardSweep % 2) {
    for (var j = model.maxRank - 1;0 <= j;j--) {
      this.medianRank(j, downwardSweep);
    }
  } else {
    for (j = 1;j < model.maxRank;j++) {
      this.medianRank(j, downwardSweep);
    }
  }
};
mxMedianHybridCrossingReduction.prototype.medianRank = function(rankValue, downwardSweep) {
  var numRanks = this.nestedBestRanks[rankValue].length;
  var medianValues = [];
  var reservedPositions = [];
  for (var i = 0;i < numRanks;i++) {
    var cell = this.nestedBestRanks[rankValue][i];
    var sorterEntry = new MedianCellSorter;
    sorterEntry.cell = cell;
    var nextLevelConnectedCells = downwardSweep ? cell.getNextLayerConnectedCells(rankValue) : cell.getPreviousLayerConnectedCells(rankValue);
    var nextRankValue = downwardSweep ? rankValue + 1 : rankValue - 1;
    if (null != nextLevelConnectedCells && 0 != nextLevelConnectedCells.length) {
      sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);
      medianValues.push(sorterEntry);
    } else {
      reservedPositions[cell.getGeneralPurposeVariable(rankValue)] = true;
    }
  }
  medianValues.sort(MedianCellSorter.prototype.compare);
  for (i = 0;i < numRanks;i++) {
    if (null == reservedPositions[i]) {
      cell = medianValues.shift().cell;
      cell.setGeneralPurposeVariable(rankValue, i);
    }
  }
};
mxMedianHybridCrossingReduction.prototype.medianValue = function(connectedCells, rankValue) {
  var medianValues = [];
  var arrayCount = 0;
  for (var i = 0;i < connectedCells.length;i++) {
    var cell = connectedCells[i];
    medianValues[arrayCount++] = cell.getGeneralPurposeVariable(rankValue);
  }
  medianValues.sort(function(a, b) {
    return a - b;
  });
  if (1 == arrayCount % 2) {
    return medianValues[Math.floor(arrayCount / 2)];
  }
  if (2 == arrayCount) {
    return(medianValues[0] + medianValues[1]) / 2;
  }
  connectedCells = arrayCount / 2;
  rankValue = medianValues[connectedCells - 1] - medianValues[0];
  arrayCount = medianValues[arrayCount - 1] - medianValues[connectedCells];
  return(medianValues[connectedCells - 1] * arrayCount + medianValues[connectedCells] * rankValue) / (rankValue + arrayCount);
};
function MedianCellSorter() {
}
MedianCellSorter.prototype.medianValue = 0;
MedianCellSorter.prototype.cell = false;
MedianCellSorter.prototype.compare = function(a, b) {
  return null != a && null != b ? b.medianValue > a.medianValue ? -1 : b.medianValue < a.medianValue ? 1 : 0 : 0;
};
function mxMinimumCycleRemover(layout) {
  this.layout = layout;
}
mxMinimumCycleRemover.prototype = new mxHierarchicalLayoutStage;
mxMinimumCycleRemover.prototype.constructor = mxMinimumCycleRemover;
mxMinimumCycleRemover.prototype.layout = null;
mxMinimumCycleRemover.prototype.execute = function(parent) {
  parent = this.layout.getModel();
  var seenNodes = {};
  var rootsArray = parent.vertexMapper.getValues();
  var unseenNodes = {};
  for (var i = 0;i < rootsArray.length;i++) {
    unseenNodes[rootsArray[i].id] = rootsArray[i];
  }
  rootsArray = null;
  if (null != parent.roots) {
    var modelRoots = parent.roots;
    rootsArray = [];
    for (i = 0;i < modelRoots.length;i++) {
      rootsArray[i] = parent.vertexMapper.get(modelRoots[i]);
    }
  }
  parent.visit(function(parent, node, cell, flex, editor) {
    if (node.isAncestor(parent)) {
      cell.invert();
      mxUtils.remove(cell, parent.connectsAsSource);
      parent.connectsAsTarget.push(cell);
      mxUtils.remove(cell, node.connectsAsTarget);
      node.connectsAsSource.push(cell);
    }
    seenNodes[node.id] = node;
    delete unseenNodes[node.id];
  }, rootsArray, true, null);
  i = mxUtils.clone(seenNodes, null, true);
  parent.visit(function(parent, node, cell, flex, editor) {
    if (node.isAncestor(parent)) {
      cell.invert();
      mxUtils.remove(cell, parent.connectsAsSource);
      node.connectsAsSource.push(cell);
      parent.connectsAsTarget.push(cell);
      mxUtils.remove(cell, node.connectsAsTarget);
    }
    seenNodes[node.id] = node;
    delete unseenNodes[node.id];
  }, unseenNodes, true, i);
};
function mxCoordinateAssignment(layout, intraCellSpacing, interRankCellSpacing, orientation, initialX, parallelEdgeSpacing) {
  this.layout = layout;
  this.intraCellSpacing = intraCellSpacing;
  this.interRankCellSpacing = interRankCellSpacing;
  this.orientation = orientation;
  this.initialX = initialX;
  this.parallelEdgeSpacing = parallelEdgeSpacing;
}
mxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage;
mxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment;
mxCoordinateAssignment.prototype.layout = null;
mxCoordinateAssignment.prototype.intraCellSpacing = 30;
mxCoordinateAssignment.prototype.interRankCellSpacing = 100;
mxCoordinateAssignment.prototype.parallelEdgeSpacing = 10;
mxCoordinateAssignment.prototype.maxIterations = 8;
mxCoordinateAssignment.prototype.prefHozEdgeSep = 5;
mxCoordinateAssignment.prototype.prefVertEdgeOff = 2;
mxCoordinateAssignment.prototype.minEdgeJetty = 12;
mxCoordinateAssignment.prototype.channelBuffer = 4;
mxCoordinateAssignment.prototype.jettyPositions = null;
mxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH;
mxCoordinateAssignment.prototype.initialX = null;
mxCoordinateAssignment.prototype.limitX = null;
mxCoordinateAssignment.prototype.currentXDelta = null;
mxCoordinateAssignment.prototype.widestRank = null;
mxCoordinateAssignment.prototype.rankTopY = null;
mxCoordinateAssignment.prototype.rankBottomY = null;
mxCoordinateAssignment.prototype.widestRankValue = null;
mxCoordinateAssignment.prototype.rankWidths = null;
mxCoordinateAssignment.prototype.rankY = null;
mxCoordinateAssignment.prototype.fineTuning = true;
mxCoordinateAssignment.prototype.nextLayerConnectedCache = null;
mxCoordinateAssignment.prototype.previousLayerConnectedCache = null;
mxCoordinateAssignment.prototype.groupPadding = 10;
mxCoordinateAssignment.prototype.printStatus = function() {
  var model = this.layout.getModel();
  mxLog.show();
  mxLog.writeln("======Coord assignment debug=======");
  for (var j = 0;j < model.ranks.length;j++) {
    mxLog.write("Rank ", j, " : ");
    var rank = model.ranks[j];
    for (var k = 0;k < rank.length;k++) {
      mxLog.write(rank[k].getGeneralPurposeVariable(j), "  ");
    }
    mxLog.writeln();
  }
  mxLog.writeln("====================================");
};
mxCoordinateAssignment.prototype.execute = function(parent) {
  this.jettyPositions = {};
  parent = this.layout.getModel();
  this.currentXDelta = 0;
  this.initialCoords(this.layout.getGraph(), parent);
  if (this.fineTuning) {
    this.minNode(parent);
  }
  var bestXDelta = 1E8;
  if (this.fineTuning) {
    for (var i = 0;i < this.maxIterations;i++) {
      if (0 != i) {
        this.medianPos(i, parent);
        this.minNode(parent);
      }
      if (this.currentXDelta < bestXDelta) {
        for (var j = 0;j < parent.ranks.length;j++) {
          var rank = parent.ranks[j];
          for (var k = 0;k < rank.length;k++) {
            var cell = rank[k];
            cell.setX(j, cell.getGeneralPurposeVariable(j));
          }
        }
        bestXDelta = this.currentXDelta;
      } else {
        for (j = 0;j < parent.ranks.length;j++) {
          rank = parent.ranks[j];
          for (k = 0;k < rank.length;k++) {
            cell = rank[k];
            cell.setGeneralPurposeVariable(j, cell.getX(j));
          }
        }
      }
      this.minPath(this.layout.getGraph(), parent);
      this.currentXDelta = 0;
    }
  }
  this.setCellLocations(this.layout.getGraph(), parent);
};
mxCoordinateAssignment.prototype.minNode = function(model) {
  var nodeList = [];
  var map = new mxDictionary;
  var rank = [];
  for (var i = 0;i <= model.maxRank;i++) {
    rank[i] = model.ranks[i];
    for (var j = 0;j < rank[i].length;j++) {
      var node = rank[i][j];
      var nodeWrapper = new WeightedCellSorter(node, i);
      nodeWrapper.rankIndex = j;
      nodeWrapper.visited = true;
      nodeList.push(nodeWrapper);
      map.put(node, nodeWrapper);
    }
  }
  model = 10 * nodeList.length;
  for (j = 0;0 < nodeList.length && j <= model;) {
    node = nodeList.shift();
    i = node.cell;
    var rankValue = node.weightedValue;
    var rankIndex = parseInt(node.rankIndex);
    nodeWrapper = i.getNextLayerConnectedCells(rankValue);
    var previousLayerConnectedCells = i.getPreviousLayerConnectedCells(rankValue);
    var numNextLayerConnected = nodeWrapper.length;
    var numPreviousLayerConnected = previousLayerConnectedCells.length;
    var medianNextLevel = this.medianXValue(nodeWrapper, rankValue + 1);
    var medianPreviousLevel = this.medianXValue(previousLayerConnectedCells, rankValue - 1);
    var numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;
    var rightLimit = i.getGeneralPurposeVariable(rankValue);
    var cellMedian = rightLimit;
    if (0 < numConnectedNeighbours) {
      cellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel * numPreviousLayerConnected) / numConnectedNeighbours;
    }
    numNextLayerConnected = false;
    if (cellMedian < rightLimit - 1) {
      if (0 == rankIndex) {
        i.setGeneralPurposeVariable(rankValue, cellMedian);
        numNextLayerConnected = true;
      } else {
        rankIndex = rank[rankValue][rankIndex - 1];
        rightLimit = rankIndex.getGeneralPurposeVariable(rankValue);
        rightLimit = rightLimit + rankIndex.width / 2 + this.intraCellSpacing + i.width / 2;
        if (rightLimit < cellMedian) {
          i.setGeneralPurposeVariable(rankValue, cellMedian);
          numNextLayerConnected = true;
        } else {
          if (rightLimit < i.getGeneralPurposeVariable(rankValue) - 1) {
            i.setGeneralPurposeVariable(rankValue, rightLimit);
            numNextLayerConnected = true;
          }
        }
      }
    } else {
      if (cellMedian > rightLimit + 1) {
        if (rankIndex == rank[rankValue].length - 1) {
          i.setGeneralPurposeVariable(rankValue, cellMedian);
          numNextLayerConnected = true;
        } else {
          rankIndex = rank[rankValue][rankIndex + 1];
          rightLimit = rankIndex.getGeneralPurposeVariable(rankValue);
          rightLimit = rightLimit - rankIndex.width / 2 - this.intraCellSpacing - i.width / 2;
          if (rightLimit > cellMedian) {
            i.setGeneralPurposeVariable(rankValue, cellMedian);
            numNextLayerConnected = true;
          } else {
            if (rightLimit > i.getGeneralPurposeVariable(rankValue) + 1) {
              i.setGeneralPurposeVariable(rankValue, rightLimit);
              numNextLayerConnected = true;
            }
          }
        }
      }
    }
    if (numNextLayerConnected) {
      for (i = 0;i < nodeWrapper.length;i++) {
        rankValue = nodeWrapper[i];
        rankValue = map.get(rankValue);
        if (null != rankValue) {
          if (0 == rankValue.visited) {
            rankValue.visited = true;
            nodeList.push(rankValue);
          }
        }
      }
      for (i = 0;i < previousLayerConnectedCells.length;i++) {
        rankValue = previousLayerConnectedCells[i];
        rankValue = map.get(rankValue);
        if (null != rankValue) {
          if (0 == rankValue.visited) {
            rankValue.visited = true;
            nodeList.push(rankValue);
          }
        }
      }
    }
    node.visited = false;
    j++;
  }
};
mxCoordinateAssignment.prototype.medianPos = function(j, model) {
  if (0 == j % 2) {
    for (j = model.maxRank;0 < j;j--) {
      this.rankMedianPosition(j - 1, model, j);
    }
  } else {
    for (j = 0;j < model.maxRank - 1;j++) {
      this.rankMedianPosition(j + 1, model, j);
    }
  }
};
mxCoordinateAssignment.prototype.rankMedianPosition = function(rankValue, model, nextRankValue) {
  model = model.ranks[rankValue];
  var weightedValues = [];
  var cellMap = {};
  for (var i = 0;i < model.length;i++) {
    var currentCell = model[i];
    weightedValues[i] = new WeightedCellSorter;
    weightedValues[i].cell = currentCell;
    weightedValues[i].rankIndex = i;
    cellMap[currentCell.id] = weightedValues[i];
    var leftLimit = nextRankValue < rankValue ? currentCell.getPreviousLayerConnectedCells(rankValue) : currentCell.getNextLayerConnectedCells(rankValue);
    weightedValues[i].weightedValue = this.calculatedWeightedValue(currentCell, leftLimit);
  }
  weightedValues.sort(WeightedCellSorter.prototype.compare);
  for (i = 0;i < weightedValues.length;i++) {
    currentCell = weightedValues[i].cell;
    var medianNextLevel = 0;
    leftLimit = nextRankValue < rankValue ? currentCell.getPreviousLayerConnectedCells(rankValue).slice() : currentCell.getNextLayerConnectedCells(rankValue).slice();
    if (null != leftLimit) {
      medianNextLevel = leftLimit.length;
      medianNextLevel = 0 < medianNextLevel ? this.medianXValue(leftLimit, nextRankValue) : currentCell.getGeneralPurposeVariable(rankValue);
    }
    var leftBuffer = 0;
    leftLimit = -1E8;
    for (var j = weightedValues[i].rankIndex - 1;0 <= j;) {
      var weightedValue = cellMap[model[j].id];
      if (null != weightedValue) {
        var rightLimit = weightedValue.cell;
        if (weightedValue.visited) {
          leftLimit = rightLimit.getGeneralPurposeVariable(rankValue) + rightLimit.width / 2 + this.intraCellSpacing + leftBuffer + currentCell.width / 2;
          j = -1;
        } else {
          leftBuffer += rightLimit.width + this.intraCellSpacing;
          j--;
        }
      }
    }
    leftBuffer = 0;
    rightLimit = 1E8;
    for (j = weightedValues[i].rankIndex + 1;j < weightedValues.length;) {
      if (weightedValue = cellMap[model[j].id], null != weightedValue) {
        var leftCell = weightedValue.cell;
        if (weightedValue.visited) {
          rightLimit = leftCell.getGeneralPurposeVariable(rankValue) - leftCell.width / 2 - this.intraCellSpacing - leftBuffer - currentCell.width / 2;
          j = weightedValues.length;
        } else {
          leftBuffer += leftCell.width + this.intraCellSpacing;
          j++;
        }
      }
    }
    if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {
      currentCell.setGeneralPurposeVariable(rankValue, medianNextLevel);
    } else {
      if (medianNextLevel < leftLimit) {
        currentCell.setGeneralPurposeVariable(rankValue, leftLimit);
        this.currentXDelta += leftLimit - medianNextLevel;
      } else {
        if (medianNextLevel > rightLimit) {
          currentCell.setGeneralPurposeVariable(rankValue, rightLimit);
          this.currentXDelta += medianNextLevel - rightLimit;
        }
      }
    }
    weightedValues[i].visited = true;
  }
};
mxCoordinateAssignment.prototype.calculatedWeightedValue = function(currentCell, collection) {
  var totalWeight = 0;
  for (var i = 0;i < collection.length;i++) {
    var cell = collection[i];
    if (currentCell.isVertex() && cell.isVertex()) {
      totalWeight++;
    } else {
      totalWeight = currentCell.isEdge() && cell.isEdge() ? totalWeight + 8 : totalWeight + 2;
    }
  }
  return totalWeight;
};
mxCoordinateAssignment.prototype.medianXValue = function(connectedCells, rankValue) {
  if (0 == connectedCells.length) {
    return 0;
  }
  var medianValues = [];
  for (var i = 0;i < connectedCells.length;i++) {
    medianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);
  }
  medianValues.sort(function(a, b) {
    return a - b;
  });
  if (1 == connectedCells.length % 2) {
    return medianValues[Math.floor(connectedCells.length / 2)];
  }
  connectedCells = connectedCells.length / 2;
  return(medianValues[connectedCells - 1] + medianValues[connectedCells]) / 2;
};
mxCoordinateAssignment.prototype.initialCoords = function(facade, model) {
  this.calculateWidestRank(facade, model);
  for (var i = this.widestRank;0 <= i;i--) {
    if (i < model.maxRank) {
      this.rankCoordinates(i, facade, model);
    }
  }
  for (i = this.widestRank + 1;i <= model.maxRank;i++) {
    if (0 < i) {
      this.rankCoordinates(i, facade, model);
    }
  }
};
mxCoordinateAssignment.prototype.rankCoordinates = function(rankValue, row, value) {
  row = value.ranks[rankValue];
  value = this.initialX + (this.widestRankValue - this.rankWidths[rankValue]) / 2;
  var d = false;
  for (var i = 0;i < row.length;i++) {
    var node = row[i];
    if (node.isVertex()) {
      var bounds = this.layout.getVertexBounds(node.cell);
      if (null != bounds) {
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          node.width = bounds.width;
          node.height = bounds.height;
        } else {
          node.width = bounds.height;
          node.height = bounds.width;
        }
      } else {
        d = true;
      }
    } else {
      if (node.isEdge()) {
        bounds = 1;
        if (null != node.edges) {
          bounds = node.edges.length;
        } else {
          mxLog.warn("edge.edges is null");
        }
        node.width = (bounds - 1) * this.parallelEdgeSpacing;
      }
    }
    value += node.width / 2;
    node.setX(rankValue, value);
    node.setGeneralPurposeVariable(rankValue, value);
    value += node.width / 2;
    value += this.intraCellSpacing;
  }
  if (1 == d) {
    mxLog.warn("At least one cell has no bounds");
  }
};
mxCoordinateAssignment.prototype.calculateWidestRank = function(y, model) {
  y = -this.interRankCellSpacing;
  var lastRankMaxCellHeight = 0;
  this.rankWidths = [];
  this.rankY = [];
  for (var rankValue = model.maxRank;0 <= rankValue;rankValue--) {
    var maxCellHeight = 0;
    var rank = model.ranks[rankValue];
    var value = this.initialX;
    var k = false;
    for (var i = 0;i < rank.length;i++) {
      var node = rank[i];
      if (node.isVertex()) {
        var bounds = this.layout.getVertexBounds(node.cell);
        if (null != bounds) {
          if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
            node.width = bounds.width;
            node.height = bounds.height;
          } else {
            node.width = bounds.height;
            node.height = bounds.width;
          }
        } else {
          k = true;
        }
        maxCellHeight = Math.max(maxCellHeight, node.height);
      } else {
        if (node.isEdge()) {
          bounds = 1;
          if (null != node.edges) {
            bounds = node.edges.length;
          } else {
            mxLog.warn("edge.edges is null");
          }
          node.width = (bounds - 1) * this.parallelEdgeSpacing;
        }
      }
      value += node.width / 2;
      node.setX(rankValue, value);
      node.setGeneralPurposeVariable(rankValue, value);
      value += node.width / 2;
      value += this.intraCellSpacing;
      if (value > this.widestRankValue) {
        this.widestRankValue = value;
        this.widestRank = rankValue;
      }
      this.rankWidths[rankValue] = value;
    }
    if (1 == k) {
      mxLog.warn("At least one cell has no bounds");
    }
    this.rankY[rankValue] = y;
    value = maxCellHeight / 2 + lastRankMaxCellHeight / 2 + this.interRankCellSpacing;
    lastRankMaxCellHeight = maxCellHeight;
    y = this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_WEST ? y + value : y - value;
    for (i = 0;i < rank.length;i++) {
      rank[i].setY(rankValue, y);
    }
  }
};
mxCoordinateAssignment.prototype.minPath = function(edges, model) {
  edges = model.edgeMapper.getValues();
  for (var j = 0;j < edges.length;j++) {
    var cell = edges[j];
    if (!(1 > cell.maxRank - cell.minRank - 1)) {
      var upSegCount = cell.getGeneralPurposeVariable(cell.minRank + 1);
      var downSegCount = true;
      var refSegCount = 0;
      for (var i = cell.minRank + 2;i < cell.maxRank;i++) {
        var upXPositions = cell.getGeneralPurposeVariable(i);
        if (upSegCount != upXPositions) {
          downSegCount = false;
          upSegCount = upXPositions;
        } else {
          refSegCount++;
        }
      }
      if (!downSegCount) {
        downSegCount = upSegCount = 0;
        upXPositions = [];
        var downXPositions = [];
        var currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);
        for (i = cell.minRank + 1;i < cell.maxRank - 1;i++) {
          var nextX = cell.getX(i + 1);
          if (currentX == nextX) {
            upXPositions[i - cell.minRank - 1] = currentX;
            upSegCount++;
          } else {
            if (this.repositionValid(model, cell, i + 1, currentX)) {
              upXPositions[i - cell.minRank - 1] = currentX;
              upSegCount++;
            } else {
              currentX = upXPositions[i - cell.minRank - 1] = nextX;
            }
          }
        }
        currentX = cell.getX(i);
        for (i = cell.maxRank - 1;i > cell.minRank + 1;i--) {
          nextX = cell.getX(i - 1);
          if (currentX == nextX) {
            downXPositions[i - cell.minRank - 2] = currentX;
            downSegCount++;
          } else {
            if (this.repositionValid(model, cell, i - 1, currentX)) {
              downXPositions[i - cell.minRank - 2] = currentX;
              downSegCount++;
            } else {
              downXPositions[i - cell.minRank - 2] = cell.getX(i - 1);
              currentX = nextX;
            }
          }
        }
        if (downSegCount > refSegCount || upSegCount > refSegCount) {
          if (downSegCount >= upSegCount) {
            for (i = cell.maxRank - 2;i > cell.minRank;i--) {
              cell.setX(i, downXPositions[i - cell.minRank - 1]);
            }
          } else {
            if (upSegCount > downSegCount) {
              for (i = cell.minRank + 2;i < cell.maxRank;i++) {
                cell.setX(i, upXPositions[i - cell.minRank - 2]);
              }
            }
          }
        }
      }
    }
  }
};
mxCoordinateAssignment.prototype.repositionValid = function(rankArray, cell, rankValue, position) {
  rankArray = rankArray.ranks[rankValue];
  var rankIndex = -1;
  for (var i = 0;i < rankArray.length;i++) {
    if (cell == rankArray[i]) {
      rankIndex = i;
      break;
    }
  }
  if (0 > rankIndex) {
    return false;
  }
  i = cell.getGeneralPurposeVariable(rankValue);
  if (position < i) {
    if (0 == rankIndex) {
      return true;
    }
    rankArray = rankArray[rankIndex - 1];
    rankValue = rankArray.getGeneralPurposeVariable(rankValue);
    rankValue = rankValue + rankArray.width / 2 + this.intraCellSpacing + cell.width / 2;
    if (!(rankValue <= position)) {
      return false;
    }
  } else {
    if (position > i) {
      if (rankIndex == rankArray.length - 1) {
        return true;
      }
      rankArray = rankArray[rankIndex + 1];
      rankValue = rankArray.getGeneralPurposeVariable(rankValue);
      rankValue = rankValue - rankArray.width / 2 - this.intraCellSpacing - cell.width / 2;
      if (!(rankValue >= position)) {
        return false;
      }
    }
  }
  return true;
};
mxCoordinateAssignment.prototype.setCellLocations = function(i, model) {
  this.rankTopY = [];
  this.rankBottomY = [];
  for (i = 0;i < model.ranks.length;i++) {
    this.rankTopY[i] = Number.MAX_VALUE;
    this.rankBottomY[i] = -Number.MAX_VALUE;
  }
  var vertices = model.vertexMapper.getValues();
  for (i = 0;i < vertices.length;i++) {
    this.setVertexLocation(vertices[i]);
  }
  if (!(this.layout.edgeStyle != mxHierarchicalEdgeStyle.ORTHOGONAL && (this.layout.edgeStyle != mxHierarchicalEdgeStyle.POLYLINE && this.layout.edgeStyle != mxHierarchicalEdgeStyle.CURVE))) {
    this.localEdgeProcessing(model);
  }
  model = model.edgeMapper.getValues();
  for (i = 0;i < model.length;i++) {
    this.setEdgePosition(model[i]);
  }
};
mxCoordinateAssignment.prototype.localEdgeProcessing = function(model) {
  for (var rankValue = 0;rankValue < model.ranks.length;rankValue++) {
    var rank = model.ranks[rankValue];
    for (var i = 0;i < rank.length;i++) {
      var node = rank[i];
      if (node.isVertex()) {
        var currentCells = node.getPreviousLayerConnectedCells(rankValue);
        var connectedEdges = rankValue - 1;
        for (var k = 0;2 > k;k++) {
          if (-1 < connectedEdges && (connectedEdges < model.ranks.length && (null != currentCells && 0 < currentCells.length))) {
            var sortedCells = [];
            for (var j = 0;j < currentCells.length;j++) {
              var sorter = new WeightedCellSorter(currentCells[j], currentCells[j].getX(connectedEdges));
              sortedCells.push(sorter);
            }
            sortedCells.sort(WeightedCellSorter.prototype.compare);
            sorter = node.x[0] - node.width / 2;
            var currentYOffset = sorter + node.width;
            var numConnectionsNextLevel = currentCells = 0;
            connectedEdges = [];
            for (j = 0;j < sortedCells.length;j++) {
              var innerCell = sortedCells[j].cell;
              if (innerCell.isVertex()) {
                var connections = 0 == k ? node.connectsAsSource : node.connectsAsTarget;
                for (var connIndex = 0;connIndex < connections.length;connIndex++) {
                  if (connections[connIndex].source == innerCell || connections[connIndex].target == innerCell) {
                    currentCells += connections[connIndex].edges.length;
                    numConnectionsNextLevel++;
                    connectedEdges.push(connections[connIndex]);
                  }
                }
              } else {
                currentCells += innerCell.edges.length;
                numConnectionsNextLevel++;
                connectedEdges.push(innerCell);
              }
            }
            if (node.width > (currentCells + 1) * this.prefHozEdgeSep + 2 * this.prefHozEdgeSep) {
              sorter += this.prefHozEdgeSep;
              currentYOffset -= this.prefHozEdgeSep;
            }
            sortedCells = (currentYOffset - sorter) / currentCells;
            sorter += sortedCells / 2;
            currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
            for (j = 0;j < connectedEdges.length;j++) {
              numConnectionsNextLevel = connectedEdges[j].edges.length;
              innerCell = this.jettyPositions[connectedEdges[j].ids[0]];
              if (null == innerCell) {
                innerCell = [];
                this.jettyPositions[connectedEdges[j].ids[0]] = innerCell;
              }
              if (j < currentCells / 2) {
                currentYOffset += this.prefVertEdgeOff;
              } else {
                if (j > currentCells / 2) {
                  currentYOffset -= this.prefVertEdgeOff;
                }
              }
              for (connections = 0;connections < numConnectionsNextLevel;connections++) {
                innerCell[4 * connections + 2 * k] = sorter;
                sorter += sortedCells;
                innerCell[4 * connections + 2 * k + 1] = currentYOffset;
              }
            }
          }
          currentCells = node.getNextLayerConnectedCells(rankValue);
          connectedEdges = rankValue + 1;
        }
      }
    }
  }
};
mxCoordinateAssignment.prototype.setEdgePosition = function(cell) {
  var offsetX = 0;
  if (101207 != cell.temp[0]) {
    var maxRank = cell.maxRank;
    var minRank = cell.minRank;
    if (maxRank == minRank) {
      maxRank = cell.source.maxRank;
      minRank = cell.target.minRank;
    }
    var e = 0;
    var jettys = this.jettyPositions[cell.ids[0]];
    var g = cell.isReversed ? cell.target.cell : cell.source.cell;
    var graph = this.layout.graph;
    var layoutReversed = this.orientation == mxConstants.DIRECTION_EAST || this.orientation == mxConstants.DIRECTION_SOUTH;
    for (var i = 0;i < cell.edges.length;i++) {
      var source = cell.edges[i];
      var currentRank = this.layout.getVisibleTerminal(source, true);
      var newPoints = [];
      var modelSource = cell.isReversed;
      if (currentRank != g) {
        modelSource = !modelSource;
      }
      if (null != jettys) {
        var bottomChannelY = modelSource ? 2 : 0;
        var y = modelSource ? layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank] : layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank];
        var jetty = jettys[4 * e + 1 + bottomChannelY];
        if (modelSource != layoutReversed) {
          jetty = -jetty;
        }
        y += jetty;
        bottomChannelY = jettys[4 * e + bottomChannelY];
        var modelTarget = graph.model.getTerminal(source, true);
        if (this.layout.isPort(modelTarget)) {
          if (graph.model.getParent(modelTarget) == currentRank) {
            bottomChannelY = graph.view.getState(modelTarget);
            bottomChannelY = null != bottomChannelY ? bottomChannelY.x : currentRank.geometry.x + cell.source.width * modelTarget.geometry.x;
          }
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          newPoints.push(new mxPoint(bottomChannelY, y));
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            newPoints.push(new mxPoint(bottomChannelY, y + jetty));
          }
        } else {
          newPoints.push(new mxPoint(y, bottomChannelY));
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            newPoints.push(new mxPoint(y + jetty, bottomChannelY));
          }
        }
      }
      bottomChannelY = cell.x.length - 1;
      y = jetty = -1;
      currentRank = cell.maxRank - 1;
      if (modelSource) {
        bottomChannelY = 0;
        jetty = cell.x.length;
        y = 1;
        currentRank = cell.minRank + 1;
      }
      for (;cell.maxRank != cell.minRank && bottomChannelY != jetty;bottomChannelY += y) {
        modelTarget = cell.x[bottomChannelY] + offsetX;
        var topChannelY = (this.rankTopY[currentRank] + this.rankBottomY[currentRank + 1]) / 2;
        var x = (this.rankTopY[currentRank - 1] + this.rankBottomY[currentRank]) / 2;
        if (modelSource) {
          var tmp = topChannelY;
          topChannelY = x;
          x = tmp;
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          newPoints.push(new mxPoint(modelTarget, topChannelY));
          newPoints.push(new mxPoint(modelTarget, x));
        } else {
          newPoints.push(new mxPoint(topChannelY, modelTarget));
          newPoints.push(new mxPoint(x, modelTarget));
        }
        this.limitX = Math.max(this.limitX, modelTarget);
        currentRank += y;
      }
      if (null != jettys) {
        bottomChannelY = modelSource ? 2 : 0;
        y = modelSource ? layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank] : layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank];
        jetty = jettys[4 * e + 3 - bottomChannelY];
        if (modelSource != layoutReversed) {
          jetty = -jetty;
        }
        y -= jetty;
        bottomChannelY = jettys[4 * e + 2 - bottomChannelY];
        modelSource = graph.model.getTerminal(source, false);
        currentRank = this.layout.getVisibleTerminal(source, false);
        if (this.layout.isPort(modelSource)) {
          if (graph.model.getParent(modelSource) == currentRank) {
            bottomChannelY = graph.view.getState(modelSource);
            bottomChannelY = null != bottomChannelY ? bottomChannelY.x : currentRank.geometry.x + cell.target.width * modelSource.geometry.x;
          }
        }
        if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            newPoints.push(new mxPoint(bottomChannelY, y - jetty));
          }
          newPoints.push(new mxPoint(bottomChannelY, y));
        } else {
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            newPoints.push(new mxPoint(y - jetty, bottomChannelY));
          }
          newPoints.push(new mxPoint(y, bottomChannelY));
        }
      }
      if (cell.isReversed) {
        this.processReversedEdge(cell, source);
      }
      this.layout.setEdgePoints(source, newPoints);
      offsetX = 0 == offsetX ? this.parallelEdgeSpacing : 0 < offsetX ? -offsetX : -offsetX + this.parallelEdgeSpacing;
      e++;
    }
    cell.temp[0] = 101207;
  }
};
mxCoordinateAssignment.prototype.setVertexLocation = function(cell) {
  var realCell = cell.cell;
  var positionX = cell.x[0] - cell.width / 2;
  var positionY = cell.y[0] - cell.height / 2;
  this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY);
  this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY + cell.height);
  if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
    this.layout.setVertexLocation(realCell, positionX, positionY);
  } else {
    this.layout.setVertexLocation(realCell, positionY, positionX);
  }
  this.limitX = Math.max(this.limitX, positionX + cell.width);
};
mxCoordinateAssignment.prototype.processReversedEdge = function(graph, source) {
};
function mxSwimlaneOrdering(layout) {
  this.layout = layout;
}
mxSwimlaneOrdering.prototype = new mxHierarchicalLayoutStage;
mxSwimlaneOrdering.prototype.constructor = mxSwimlaneOrdering;
mxSwimlaneOrdering.prototype.layout = null;
mxSwimlaneOrdering.prototype.execute = function(parent) {
  parent = this.layout.getModel();
  var b = mxUtils.clone(parent.vertexMapper, null, true);
  var rootsArray = null;
  if (null != parent.roots) {
    var modelRoots = parent.roots;
    rootsArray = [];
    for (var i = 0;i < modelRoots.length;i++) {
      rootsArray[i] = parent.vertexMapper.get(modelRoots[i]);
    }
  }
  parent.visit(function(parent, node, connectingEdge, flex, editor) {
    flex = null != parent && (parent.swimlaneIndex == node.swimlaneIndex && node.isAncestor(parent));
    editor = null != parent && (null != connectingEdge && (parent.swimlaneIndex < node.swimlaneIndex && connectingEdge.source == node));
    if (flex) {
      connectingEdge.invert();
      mxUtils.remove(connectingEdge, parent.connectsAsSource);
      node.connectsAsSource.push(connectingEdge);
      parent.connectsAsTarget.push(connectingEdge);
      mxUtils.remove(connectingEdge, node.connectsAsTarget);
    } else {
      if (editor) {
        connectingEdge.invert();
        mxUtils.remove(connectingEdge, parent.connectsAsTarget);
        node.connectsAsTarget.push(connectingEdge);
        parent.connectsAsSource.push(connectingEdge);
        mxUtils.remove(connectingEdge, node.connectsAsSource);
      }
    }
    parent = mxCellPath.create(node.cell);
    delete b[parent];
  }, rootsArray, true, null);
};
function mxHierarchicalLayout(graph, orientation, deterministic) {
  mxGraphLayout.call(this, graph);
  this.orientation = null != orientation ? orientation : mxConstants.DIRECTION_NORTH;
  this.deterministic = null != deterministic ? deterministic : true;
}
var mxHierarchicalEdgeStyle = {
  ORTHOGONAL : 1,
  POLYLINE : 2,
  STRAIGHT : 3,
  CURVE : 4
};
mxHierarchicalLayout.prototype = new mxGraphLayout;
mxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout;
mxHierarchicalLayout.prototype.roots = null;
mxHierarchicalLayout.prototype.resizeParent = false;
mxHierarchicalLayout.prototype.maintainParentLocation = false;
mxHierarchicalLayout.prototype.moveParent = false;
mxHierarchicalLayout.prototype.parentBorder = 0;
mxHierarchicalLayout.prototype.intraCellSpacing = 30;
mxHierarchicalLayout.prototype.interRankCellSpacing = 100;
mxHierarchicalLayout.prototype.interHierarchySpacing = 60;
mxHierarchicalLayout.prototype.parallelEdgeSpacing = 10;
mxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
mxHierarchicalLayout.prototype.fineTuning = true;
mxHierarchicalLayout.prototype.tightenToSource = true;
mxHierarchicalLayout.prototype.disableEdgeStyle = true;
mxHierarchicalLayout.prototype.traverseAncestors = true;
mxHierarchicalLayout.prototype.model = null;
mxHierarchicalLayout.prototype.edgesCache = null;
mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
mxHierarchicalLayout.prototype.getModel = function() {
  return this.model;
};
mxHierarchicalLayout.prototype.execute = function(parent, roots) {
  this.parent = parent;
  var model = this.graph.model;
  this.edgesCache = new mxDictionary;
  this.edgeSourceTermCache = new mxDictionary;
  this.edgesTargetTermCache = new mxDictionary;
  if (!(null == roots)) {
    if (!(roots instanceof Array)) {
      roots = [roots];
    }
  }
  if (null != roots || null != parent) {
    this.parentY = this.parentX = null;
    if (parent != this.root && (null != model.isVertex(parent) && this.maintainParentLocation)) {
      var geo = this.graph.getCellGeometry(parent);
      if (null != geo) {
        this.parentX = geo.x;
        this.parentY = geo.y;
      }
    }
    if (null != roots) {
      var rootsCopy = [];
      for (var i = 0;i < roots.length;i++) {
        if (null != parent ? model.isAncestor(parent, roots[i]) : 1) {
          if (model.isVertex(roots[i])) {
            rootsCopy.push(roots[i]);
          }
        }
      }
      this.roots = rootsCopy;
    }
    model.beginUpdate();
    try {
      this.run(parent);
      if (this.resizeParent) {
        if (!this.graph.isCellCollapsed(parent)) {
          this.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);
        }
      }
      if (null != this.parentX) {
        if (null != this.parentY) {
          geo = this.graph.getCellGeometry(parent);
          if (null != geo) {
            geo = geo.clone();
            geo.x = this.parentX;
            geo.y = this.parentY;
            model.setGeometry(parent, geo);
          }
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
mxHierarchicalLayout.prototype.findRoots = function(parent, vertices) {
  var roots = [];
  if (null != parent && null != vertices) {
    parent = this.graph.model;
    var best = null;
    var e = -1E5;
    for (var i in vertices) {
      var cell = vertices[i];
      if (parent.isVertex(cell) && this.graph.isCellVisible(cell)) {
        var conns = this.getEdges(cell);
        var tcy = 0;
        var scy = 0;
        for (var k = 0;k < conns.length;k++) {
          if (this.getVisibleTerminal(conns[k], true) == cell) {
            tcy++;
          } else {
            scy++;
          }
        }
        if (0 == scy) {
          if (0 < tcy) {
            roots.push(cell);
          }
        }
        conns = tcy - scy;
        if (conns > e) {
          e = conns;
          best = cell;
        }
      }
    }
    if (0 == roots.length) {
      if (null != best) {
        roots.push(best);
      }
    }
  }
  return roots;
};
mxHierarchicalLayout.prototype.getEdges = function(cell) {
  var edges = this.edgesCache.get(cell);
  if (null != edges) {
    return edges;
  }
  var model = this.graph.model;
  edges = [];
  var source = this.graph.isCellCollapsed(cell);
  var target = model.getChildCount(cell);
  for (var i = 0;i < target;i++) {
    var child = model.getChildAt(cell, i);
    if (this.isPort(child)) {
      edges = edges.concat(model.getEdges(child, true, true));
    } else {
      if (source || !this.graph.isCellVisible(child)) {
        edges = edges.concat(model.getEdges(child, true, true));
      }
    }
  }
  edges = edges.concat(model.getEdges(cell, true, true));
  model = [];
  for (i = 0;i < edges.length;i++) {
    source = this.getVisibleTerminal(edges[i], true);
    target = this.getVisibleTerminal(edges[i], false);
    if (source == target || source != target && (target == cell && (null == this.parent || this.isAncestor(this.parent, source, this.traverseAncestors)) || source == cell && (null == this.parent || this.isAncestor(this.parent, target, this.traverseAncestors)))) {
      model.push(edges[i]);
    }
  }
  this.edgesCache.put(cell, model);
  return model;
};
mxHierarchicalLayout.prototype.getVisibleTerminal = function(cell, source) {
  var terminalCache = this.edgesTargetTermCache;
  if (source) {
    terminalCache = this.edgeSourceTermCache;
  }
  var state = terminalCache.get(cell);
  if (null != state) {
    return state;
  }
  state = this.graph.view.getState(cell);
  var terminal = null != state ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(cell, source);
  if (null == terminal) {
    terminal = null != state ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(cell, source);
  }
  if (null != terminal) {
    if (this.isPort(terminal)) {
      terminal = this.graph.model.getParent(terminal);
    }
    terminalCache.put(cell, terminal);
  }
  return terminal;
};
mxHierarchicalLayout.prototype.run = function(parent) {
  var hierarchyVertices = [];
  var initialX = [];
  if (null == this.roots && null != parent) {
    var filledVertexSet = {};
    this.filterDescendants(parent, filledVertexSet);
    this.roots = [];
    var i = true;
    for (var key in filledVertexSet) {
      if (null != filledVertexSet[key]) {
        i = false;
        break;
      }
    }
    for (;!i;) {
      var candidateRoots = this.findRoots(parent, filledVertexSet);
      for (i = 0;i < candidateRoots.length;i++) {
        var vertexSet = {};
        hierarchyVertices.push(vertexSet);
        this.traverse(candidateRoots[i], true, null, initialX, vertexSet, hierarchyVertices, filledVertexSet);
      }
      for (i = 0;i < candidateRoots.length;i++) {
        this.roots.push(candidateRoots[i]);
      }
      i = true;
      for (key in filledVertexSet) {
        if (null != filledVertexSet[key]) {
          i = false;
          break;
        }
      }
    }
  } else {
    for (i = 0;i < this.roots.length;i++) {
      vertexSet = {};
      hierarchyVertices.push(vertexSet);
      this.traverse(this.roots[i], true, null, initialX, vertexSet, hierarchyVertices, null);
    }
  }
  for (i = initialX = 0;i < hierarchyVertices.length;i++) {
    vertexSet = hierarchyVertices[i];
    filledVertexSet = [];
    for (key in vertexSet) {
      filledVertexSet.push(vertexSet[key]);
    }
    this.model = new mxGraphHierarchyModel(this, filledVertexSet, this.roots, parent, this.tightenToSource);
    this.cycleStage(parent);
    this.layeringStage();
    this.crossingStage(parent);
    initialX = this.placementStage(initialX, parent);
  }
};
mxHierarchicalLayout.prototype.filterDescendants = function(cell, result) {
  var model = this.graph.model;
  if (model.isVertex(cell)) {
    if (cell != this.parent) {
      if (this.graph.isCellVisible(cell)) {
        result[mxObjectIdentity.get(cell)] = cell;
      }
    }
  }
  if (this.traverseAncestors || cell == this.parent && this.graph.isCellVisible(cell)) {
    var childCount = model.getChildCount(cell);
    for (var i = 0;i < childCount;i++) {
      var child = model.getChildAt(cell, i);
      if (!this.isPort(child)) {
        this.filterDescendants(child, result);
      }
    }
  }
};
mxHierarchicalLayout.prototype.isPort = function(cell) {
  return null != cell && null != cell.geometry ? cell.geometry.relative : false;
};
mxHierarchicalLayout.prototype.getEdgesBetween = function(source, target, isConnect) {
  isConnect = null != isConnect ? isConnect : false;
  var edges = this.getEdges(source);
  var result = [];
  for (var i = 0;i < edges.length;i++) {
    var src = this.getVisibleTerminal(edges[i], true);
    var trg = this.getVisibleTerminal(edges[i], false);
    if (src == source && trg == target || !isConnect && (src == target && trg == source)) {
      result.push(edges[i]);
    }
  }
  return result;
};
mxHierarchicalLayout.prototype.traverse = function(vertex, directed, i, source, currentComp, hierarchyVertices, filledVertexSet) {
  if (null != vertex && null != source) {
    var vertexID = mxObjectIdentity.get(vertex);
    if (null == source[vertexID] && (null == filledVertexSet || null != filledVertexSet[vertexID])) {
      if (null == currentComp[vertexID]) {
        currentComp[vertexID] = vertex;
      }
      if (null == source[vertexID]) {
        source[vertexID] = vertex;
      }
      if (null !== filledVertexSet) {
        delete filledVertexSet[vertexID];
      }
      var edges = this.getEdges(vertex);
      vertexID = [];
      for (i = 0;i < edges.length;i++) {
        vertexID[i] = this.getVisibleTerminal(edges[i], true) == vertex;
      }
      for (i = 0;i < edges.length;i++) {
        if (!directed || vertexID[i]) {
          vertex = this.getVisibleTerminal(edges[i], !vertexID[i]);
          var m = 1;
          for (var j = 0;j < edges.length;j++) {
            if (j != i) {
              var isSource2 = vertexID[j];
              if (this.getVisibleTerminal(edges[j], !isSource2) == vertex) {
                if (isSource2) {
                  m++;
                } else {
                  m--;
                }
              }
            }
          }
          if (0 <= m) {
            currentComp = this.traverse(vertex, directed, edges[i], source, currentComp, hierarchyVertices, filledVertexSet);
          }
        }
      }
    } else {
      if (null == currentComp[vertexID]) {
        for (i = 0;i < hierarchyVertices.length;i++) {
          if (directed = hierarchyVertices[i], null != directed[vertexID]) {
            for (edges in directed) {
              currentComp[edges] = directed[edges];
            }
            hierarchyVertices.splice(i, 1);
            break;
          }
        }
      }
    }
  }
  return currentComp;
};
mxHierarchicalLayout.prototype.cycleStage = function(parent) {
  (new mxMinimumCycleRemover(this)).execute(parent);
};
mxHierarchicalLayout.prototype.layeringStage = function() {
  this.model.initialRank();
  this.model.fixRanks();
};
mxHierarchicalLayout.prototype.crossingStage = function(parent) {
  (new mxMedianHybridCrossingReduction(this)).execute(parent);
};
mxHierarchicalLayout.prototype.placementStage = function(initialX, parent) {
  initialX = new mxCoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, initialX, this.parallelEdgeSpacing);
  initialX.fineTuning = this.fineTuning;
  initialX.execute(parent);
  return initialX.limitX + this.interHierarchySpacing;
};
function mxSwimlaneLayout(graph, orientation, deterministic) {
  mxGraphLayout.call(this, graph);
  this.orientation = null != orientation ? orientation : mxConstants.DIRECTION_NORTH;
  this.deterministic = null != deterministic ? deterministic : true;
}
mxSwimlaneLayout.prototype = new mxGraphLayout;
mxSwimlaneLayout.prototype.constructor = mxSwimlaneLayout;
mxSwimlaneLayout.prototype.roots = null;
mxSwimlaneLayout.prototype.swimlanes = null;
mxSwimlaneLayout.prototype.dummyVertexWidth = 50;
mxSwimlaneLayout.prototype.resizeParent = false;
mxSwimlaneLayout.prototype.maintainParentLocation = false;
mxSwimlaneLayout.prototype.moveParent = false;
mxSwimlaneLayout.prototype.parentBorder = 30;
mxSwimlaneLayout.prototype.intraCellSpacing = 30;
mxSwimlaneLayout.prototype.interRankCellSpacing = 100;
mxSwimlaneLayout.prototype.interHierarchySpacing = 60;
mxSwimlaneLayout.prototype.parallelEdgeSpacing = 10;
mxSwimlaneLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
mxSwimlaneLayout.prototype.fineTuning = true;
mxSwimlaneLayout.prototype.tightenToSource = true;
mxSwimlaneLayout.prototype.disableEdgeStyle = true;
mxSwimlaneLayout.prototype.traverseAncestors = true;
mxSwimlaneLayout.prototype.model = null;
mxSwimlaneLayout.prototype.edgesCache = null;
mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
mxSwimlaneLayout.prototype.getModel = function() {
  return this.model;
};
mxSwimlaneLayout.prototype.execute = function(parent, swimlanes) {
  this.parent = parent;
  var model = this.graph.model;
  this.edgesCache = new mxDictionary;
  this.edgeSourceTermCache = new mxDictionary;
  this.edgesTargetTermCache = new mxDictionary;
  if (!(null == swimlanes || 1 > swimlanes.length)) {
    if (null == parent) {
      parent = model.getParent(swimlanes[0]);
    }
    this.parentY = this.parentX = null;
    if (parent != this.root && (null != model.isVertex(parent) && this.maintainParentLocation)) {
      var geo = this.graph.getCellGeometry(parent);
      if (null != geo) {
        this.parentX = geo.x;
        this.parentY = geo.y;
      }
    }
    this.swimlanes = swimlanes;
    var cells = [];
    for (var i = 0;i < swimlanes.length;i++) {
      var tmp = this.graph.getChildCells(swimlanes[i]);
      if (null == tmp || 0 == tmp.length) {
        tmp = this.graph.insertVertex(swimlanes[i], null, null, 0, 0, this.dummyVertexWidth, 0);
        cells.push(tmp);
      }
    }
    model.beginUpdate();
    try {
      this.run(parent);
      if (this.resizeParent) {
        if (!this.graph.isCellCollapsed(parent)) {
          this.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);
        }
      }
      if (null != this.parentX) {
        if (null != this.parentY) {
          geo = this.graph.getCellGeometry(parent);
          if (null != geo) {
            geo = geo.clone();
            geo.x = this.parentX;
            geo.y = this.parentY;
            model.setGeometry(parent, geo);
          }
        }
      }
      this.graph.removeCells(cells);
    } finally {
      model.endUpdate();
    }
  }
};
mxSwimlaneLayout.prototype.updateGroupBounds = function() {
  var layoutBounds = [];
  var childBounds = this.model;
  for (geo in childBounds.edgeMapper) {
    var childrenY = childBounds.edgeMapper[geo];
    for (var i = 0;i < childrenY.edges.length;i++) {
      layoutBounds.push(childrenY.edges[i]);
    }
  }
  layoutBounds = this.graph.getBoundingBoxFromGeometry(layoutBounds, true);
  childBounds = [];
  for (i = 0;i < this.swimlanes.length;i++) {
    var cell = this.swimlanes[i];
    var geo = this.graph.getCellGeometry(cell);
    if (null != geo) {
      var cells = this.graph.getChildCells(cell);
      childrenY = this.graph.isSwimlane(cell) ? this.graph.getStartSize(cell) : new mxRectangle;
      cell = this.graph.getBoundingBoxFromGeometry(cells);
      childBounds[i] = cell;
      childrenY = cell.y + geo.y - childrenY.height - this.parentBorder;
      geo = cell.y + geo.y + cell.height;
      if (null == layoutBounds) {
        layoutBounds = new mxRectangle(0, childrenY, 0, geo - childrenY);
      } else {
        layoutBounds.y = Math.min(layoutBounds.y, childrenY);
        layoutBounds.height = Math.max(layoutBounds.y + layoutBounds.height, geo) - layoutBounds.y;
      }
    }
  }
  for (i = 0;i < this.swimlanes.length;i++) {
    if (cell = this.swimlanes[i], geo = this.graph.getCellGeometry(cell), null != geo) {
      cells = this.graph.getChildCells(cell);
      childrenY = this.graph.isSwimlane(cell) ? this.graph.getStartSize(cell) : new mxRectangle;
      var newGeo = geo.clone();
      var w = childrenY.width + (0 == i ? this.parentBorder : this.interRankCellSpacing / 2);
      var x = childBounds[i].x - w;
      var y = layoutBounds.y - this.parentBorder;
      newGeo.x += x;
      newGeo.y = y;
      newGeo.width = childBounds[i].width + w + this.interRankCellSpacing / 2;
      newGeo.height = layoutBounds.height + childrenY.height + 2 * this.parentBorder;
      this.graph.model.setGeometry(cell, newGeo);
      this.graph.moveCells(cells, -x, geo.y - y);
    }
  }
};
mxSwimlaneLayout.prototype.findRoots = function(parent, vertices) {
  var roots = [];
  if (null != parent && null != vertices) {
    var model = this.graph.model;
    var best = null;
    var f = -1E5;
    for (var i in vertices) {
      var cell = vertices[i];
      if (null != cell && (model.isVertex(cell) && (this.graph.isCellVisible(cell) && model.isAncestor(parent, cell)))) {
        var conns = this.getEdges(cell);
        var tcy = 0;
        var scy = 0;
        for (var k = 0;k < conns.length;k++) {
          var source = this.getVisibleTerminal(conns[k], true);
          if (source == cell) {
            source = this.getVisibleTerminal(conns[k], false);
            if (model.isAncestor(parent, source)) {
              tcy++;
            }
          } else {
            if (model.isAncestor(parent, source)) {
              scy++;
            }
          }
        }
        if (0 == scy) {
          if (0 < tcy) {
            roots.push(cell);
          }
        }
        conns = tcy - scy;
        if (conns > f) {
          f = conns;
          best = cell;
        }
      }
    }
    if (0 == roots.length) {
      if (null != best) {
        roots.push(best);
      }
    }
  }
  return roots;
};
mxSwimlaneLayout.prototype.getEdges = function(cell) {
  var edges = this.edgesCache.get(cell);
  if (null != edges) {
    return edges;
  }
  var model = this.graph.model;
  edges = [];
  var source = this.graph.isCellCollapsed(cell);
  var target = model.getChildCount(cell);
  for (var i = 0;i < target;i++) {
    var child = model.getChildAt(cell, i);
    if (this.isPort(child)) {
      edges = edges.concat(model.getEdges(child, true, true));
    } else {
      if (source || !this.graph.isCellVisible(child)) {
        edges = edges.concat(model.getEdges(child, true, true));
      }
    }
  }
  edges = edges.concat(model.getEdges(cell, true, true));
  model = [];
  for (i = 0;i < edges.length;i++) {
    source = this.getVisibleTerminal(edges[i], true);
    target = this.getVisibleTerminal(edges[i], false);
    if (source == target || source != target && (target == cell && (null == this.parent || this.graph.isValidAncestor(source, this.parent, this.traverseAncestors)) || source == cell && (null == this.parent || this.graph.isValidAncestor(target, this.parent, this.traverseAncestors)))) {
      model.push(edges[i]);
    }
  }
  this.edgesCache.put(cell, model);
  return model;
};
mxSwimlaneLayout.prototype.getVisibleTerminal = function(cell, source) {
  var terminalCache = this.edgesTargetTermCache;
  if (source) {
    terminalCache = this.edgeSourceTermCache;
  }
  var state = terminalCache.get(cell);
  if (null != state) {
    return state;
  }
  state = this.graph.view.getState(cell);
  var terminal = null != state ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(cell, source);
  if (null == terminal) {
    terminal = null != state ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(cell, source);
  }
  if (null != terminal) {
    if (this.isPort(terminal)) {
      terminal = this.graph.model.getParent(terminal);
    }
    terminalCache.put(cell, terminal);
  }
  return terminal;
};
mxSwimlaneLayout.prototype.run = function(parent) {
  var hierarchyVertices = [];
  var source = {};
  if (null != this.swimlanes && (0 < this.swimlanes.length && null != parent)) {
    var filledVertexSet = {};
    for (var i = 0;i < this.swimlanes.length;i++) {
      this.filterDescendants(this.swimlanes[i], filledVertexSet);
    }
    this.roots = [];
    i = true;
    for (var key in filledVertexSet) {
      if (null != filledVertexSet[key]) {
        i = false;
        break;
      }
    }
    for (var laneCounter = 0;!i && laneCounter < this.swimlanes.length;) {
      var candidateRoots = this.findRoots(this.swimlanes[laneCounter], filledVertexSet);
      if (0 == candidateRoots.length) {
        laneCounter++;
      } else {
        for (i = 0;i < candidateRoots.length;i++) {
          var vertexSet = {};
          hierarchyVertices.push(vertexSet);
          this.traverse(candidateRoots[i], true, null, source, vertexSet, hierarchyVertices, filledVertexSet, laneCounter);
        }
        for (i = 0;i < candidateRoots.length;i++) {
          this.roots.push(candidateRoots[i]);
        }
        i = true;
        for (key in filledVertexSet) {
          if (null != filledVertexSet[key]) {
            i = false;
            break;
          }
        }
      }
    }
  } else {
    for (i = 0;i < this.roots.length;i++) {
      vertexSet = {};
      hierarchyVertices.push(vertexSet);
      this.traverse(this.roots[i], true, null, source, vertexSet, hierarchyVertices, null);
    }
  }
  hierarchyVertices = [];
  for (key in source) {
    hierarchyVertices.push(source[key]);
  }
  this.model = new mxSwimlaneModel(this, hierarchyVertices, this.roots, parent, this.tightenToSource);
  this.cycleStage(parent);
  this.layeringStage();
  this.crossingStage(parent);
  this.placementStage(0, parent);
};
mxSwimlaneLayout.prototype.filterDescendants = function(cell, result) {
  var model = this.graph.model;
  if (model.isVertex(cell)) {
    if (cell != this.parent) {
      if (model.getParent(cell) != this.parent) {
        if (this.graph.isCellVisible(cell)) {
          result[mxObjectIdentity.get(cell)] = cell;
        }
      }
    }
  }
  if (this.traverseAncestors || cell == this.parent && this.graph.isCellVisible(cell)) {
    var childCount = model.getChildCount(cell);
    for (var i = 0;i < childCount;i++) {
      var child = model.getChildAt(cell, i);
      if (!this.isPort(child)) {
        this.filterDescendants(child, result);
      }
    }
  }
};
mxSwimlaneLayout.prototype.isPort = function(cell) {
  return cell.geometry.relative ? true : false;
};
mxSwimlaneLayout.prototype.getEdgesBetween = function(source, target, isConnect) {
  isConnect = null != isConnect ? isConnect : false;
  var edges = this.getEdges(source);
  var result = [];
  for (var i = 0;i < edges.length;i++) {
    var src = this.getVisibleTerminal(edges[i], true);
    var trg = this.getVisibleTerminal(edges[i], false);
    if (src == source && trg == target || !isConnect && (src == target && trg == source)) {
      result.push(edges[i]);
    }
  }
  return result;
};
mxSwimlaneLayout.prototype.traverse = function(vertex, directed, i, source, currentComp, hierarchyVertices, filledVertexSet, swimlaneIndex) {
  if (null != vertex && null != source) {
    var vertexID = mxObjectIdentity.get(vertex);
    if (null == source[vertexID] && (null == filledVertexSet || null != filledVertexSet[vertexID])) {
      if (null == currentComp[vertexID]) {
        currentComp[vertexID] = vertex;
      }
      if (null == source[vertexID]) {
        source[vertexID] = vertex;
      }
      if (null !== filledVertexSet) {
        delete filledVertexSet[vertexID];
      }
      var edges = this.getEdges(vertex);
      vertexID = this.graph.model;
      for (i = 0;i < edges.length;i++) {
        var otherVertex = this.getVisibleTerminal(edges[i], true);
        var isSource = otherVertex == vertex;
        if (isSource) {
          otherVertex = this.getVisibleTerminal(edges[i], false);
        }
        for (var otherIndex = 0;otherIndex < this.swimlanes.length && !vertexID.isAncestor(this.swimlanes[otherIndex], otherVertex);) {
          otherIndex++;
        }
        if (!(otherIndex >= this.swimlanes.length)) {
          if (!!(otherIndex > swimlaneIndex || (!directed || isSource) && otherIndex == swimlaneIndex)) {
            currentComp = this.traverse(otherVertex, directed, edges[i], source, currentComp, hierarchyVertices, filledVertexSet, otherIndex);
          }
        }
      }
    } else {
      if (null == currentComp[vertexID]) {
        for (i = 0;i < hierarchyVertices.length;i++) {
          if (vertex = hierarchyVertices[i], null != vertex[vertexID]) {
            for (edges in vertex) {
              currentComp[edges] = vertex[edges];
            }
            hierarchyVertices.splice(i, 1);
            break;
          }
        }
      }
    }
  }
  return currentComp;
};
mxSwimlaneLayout.prototype.cycleStage = function(parent) {
  (new mxSwimlaneOrdering(this)).execute(parent);
};
mxSwimlaneLayout.prototype.layeringStage = function() {
  this.model.initialRank();
  this.model.fixRanks();
};
mxSwimlaneLayout.prototype.crossingStage = function(parent) {
  (new mxMedianHybridCrossingReduction(this)).execute(parent);
};
mxSwimlaneLayout.prototype.placementStage = function(initialX, parent) {
  initialX = new mxCoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, initialX, this.parallelEdgeSpacing);
  initialX.fineTuning = this.fineTuning;
  initialX.execute(parent);
  return initialX.limitX + this.interHierarchySpacing;
};
function mxGraphModel(root) {
  this.currentEdit = this.createUndoableEdit();
  if (null != root) {
    this.setRoot(root);
  } else {
    this.clear();
  }
}
mxGraphModel.prototype = new mxEventSource;
mxGraphModel.prototype.constructor = mxGraphModel;
mxGraphModel.prototype.root = null;
mxGraphModel.prototype.cells = null;
mxGraphModel.prototype.maintainEdgeParent = true;
mxGraphModel.prototype.ignoreRelativeEdgeParent = true;
mxGraphModel.prototype.createIds = true;
mxGraphModel.prototype.prefix = "";
mxGraphModel.prototype.postfix = "";
mxGraphModel.prototype.nextId = 0;
mxGraphModel.prototype.currentEdit = null;
mxGraphModel.prototype.updateLevel = 0;
mxGraphModel.prototype.endingUpdate = false;
mxGraphModel.prototype.clear = function() {
  this.setRoot(this.createRoot());
};
mxGraphModel.prototype.isCreateIds = function() {
  return this.createIds;
};
mxGraphModel.prototype.setCreateIds = function(value) {
  this.createIds = value;
};
mxGraphModel.prototype.createRoot = function() {
  var cell = new mxCell;
  cell.insert(new mxCell);
  return cell;
};
mxGraphModel.prototype.getCell = function(me) {
  return null != this.cells ? this.cells[me] : null;
};
mxGraphModel.prototype.filterCells = function(cells, filter) {
  var result = null;
  if (null != cells) {
    result = [];
    for (var i = 0;i < cells.length;i++) {
      if (filter(cells[i])) {
        result.push(cells[i]);
      }
    }
  }
  return result;
};
mxGraphModel.prototype.getDescendants = function(parent) {
  return this.filterDescendants(null, parent);
};
mxGraphModel.prototype.filterDescendants = function(filter, parent) {
  var result = [];
  parent = parent || this.getRoot();
  if (null == filter || filter(parent)) {
    result.push(parent);
  }
  var childCount = this.getChildCount(parent);
  for (var i = 0;i < childCount;i++) {
    var child = this.getChildAt(parent, i);
    result = result.concat(this.filterDescendants(filter, child));
  }
  return result;
};
mxGraphModel.prototype.getRoot = function(cell) {
  var root = cell || this.root;
  if (null != cell) {
    for (;null != cell;) {
      root = cell;
      cell = this.getParent(cell);
    }
  }
  return root;
};
mxGraphModel.prototype.setRoot = function(root) {
  this.execute(new mxRootChange(this, root));
  return root;
};
mxGraphModel.prototype.rootChanged = function(root) {
  var oldRoot = this.root;
  this.root = root;
  this.nextId = 0;
  this.cells = null;
  this.cellAdded(root);
  return oldRoot;
};
mxGraphModel.prototype.isRoot = function(cell) {
  return null != cell && this.root == cell;
};
mxGraphModel.prototype.isLayer = function(cell) {
  return this.isRoot(this.getParent(cell));
};
mxGraphModel.prototype.isAncestor = function(parent, cell) {
  for (;null != cell && cell != parent;) {
    cell = this.getParent(cell);
  }
  return cell == parent;
};
mxGraphModel.prototype.contains = function(cell) {
  return this.isAncestor(this.root, cell);
};
mxGraphModel.prototype.getParent = function(cell) {
  return null != cell ? cell.getParent() : null;
};
mxGraphModel.prototype.add = function(parent, child, callback) {
  if (child != parent && (null != parent && null != child)) {
    if (null == callback) {
      callback = this.getChildCount(parent);
    }
    var parentChanged = parent != this.getParent(child);
    this.execute(new mxChildChange(this, parent, child, callback));
    if (this.maintainEdgeParent) {
      if (parentChanged) {
        this.updateEdgeParents(child);
      }
    }
  }
  return child;
};
mxGraphModel.prototype.cellAdded = function(cell) {
  if (null != cell) {
    if (null == cell.getId()) {
      if (this.createIds) {
        cell.setId(this.createId(cell));
      }
    }
    if (null != cell.getId()) {
      var collision = this.getCell(cell.getId());
      if (collision != cell) {
        for (;null != collision;) {
          cell.setId(this.createId(cell));
          collision = this.getCell(cell.getId());
        }
        if (null == this.cells) {
          this.cells = {};
        }
        this.cells[cell.getId()] = cell;
      }
    }
    if (mxUtils.isNumeric(cell.getId())) {
      this.nextId = Math.max(this.nextId, cell.getId());
    }
    collision = this.getChildCount(cell);
    for (var i = 0;i < collision;i++) {
      this.cellAdded(this.getChildAt(cell, i));
    }
  }
};
mxGraphModel.prototype.createId = function(cell) {
  cell = this.nextId;
  this.nextId++;
  return this.prefix + cell + this.postfix;
};
mxGraphModel.prototype.updateEdgeParents = function(cell, root) {
  root = root || this.getRoot(cell);
  var edges = this.getChildCount(cell);
  for (var i = 0;i < edges;i++) {
    var child = this.getChildAt(cell, i);
    this.updateEdgeParents(child, root);
  }
  child = this.getEdgeCount(cell);
  edges = [];
  for (i = 0;i < child;i++) {
    edges.push(this.getEdgeAt(cell, i));
  }
  for (i = 0;i < edges.length;i++) {
    cell = edges[i];
    if (this.isAncestor(root, cell)) {
      this.updateEdgeParent(cell, root);
    }
  }
};
mxGraphModel.prototype.updateEdgeParent = function(edge, cell) {
  var source = this.getTerminal(edge, true);
  for (var target = this.getTerminal(edge, false);null != source && (!this.isEdge(source) && (null != source.geometry && source.geometry.relative));) {
    source = this.getParent(source);
  }
  for (;null != target && (this.ignoreRelativeEdgeParent && (!this.isEdge(target) && (null != target.geometry && target.geometry.relative)));) {
    target = this.getParent(target);
  }
  if (this.isAncestor(cell, source) && (this.isAncestor(cell, target) && (cell = source == target ? this.getParent(source) : this.getNearestCommonAncestor(source, target), null != cell && ((this.getParent(cell) != this.root || this.isAncestor(cell, edge)) && this.getParent(edge) != cell)))) {
    source = this.getGeometry(edge);
    if (null != source) {
      var origin1 = this.getOrigin(this.getParent(edge));
      var origin2 = this.getOrigin(cell);
      target = origin2.x - origin1.x;
      origin1 = origin2.y - origin1.y;
      source = source.clone();
      source.translate(-target, -origin1);
      this.setGeometry(edge, source);
    }
    this.add(cell, edge, this.getChildCount(cell));
  }
};
mxGraphModel.prototype.getOrigin = function(cell) {
  if (null != cell) {
    var result = this.getOrigin(this.getParent(cell));
    if (!this.isEdge(cell)) {
      cell = this.getGeometry(cell);
      if (null != cell) {
        result.x += cell.x;
        result.y += cell.y;
      }
    }
  } else {
    result = new mxPoint;
  }
  return result;
};
mxGraphModel.prototype.getNearestCommonAncestor = function(cell, cell2) {
  if (null != cell && null != cell2) {
    var path = mxCellPath.create(cell2);
    if (null != path && 0 < path.length) {
      var current = mxCellPath.create(cell);
      if (path.length < current.length) {
        cell = cell2;
        cell2 = current;
        current = path;
        path = cell2;
      }
      for (;null != cell;) {
        cell2 = this.getParent(cell);
        if (0 == path.indexOf(current + mxCellPath.PATH_SEPARATOR) && null != cell2) {
          return cell;
        }
        current = mxCellPath.getParentPath(current);
        cell = cell2;
      }
    }
  }
  return null;
};
mxGraphModel.prototype.remove = function(cell) {
  if (cell == this.root) {
    this.setRoot(null);
  } else {
    if (null != this.getParent(cell)) {
      this.execute(new mxChildChange(this, null, cell));
    }
  }
  return cell;
};
mxGraphModel.prototype.cellRemoved = function(cell) {
  if (null != cell && null != this.cells) {
    for (var i = this.getChildCount(cell) - 1;0 <= i;i--) {
      this.cellRemoved(this.getChildAt(cell, i));
    }
    if (null != this.cells) {
      if (null != cell.getId()) {
        delete this.cells[cell.getId()];
      }
    }
  }
};
mxGraphModel.prototype.parentForCellChanged = function(cell, parent, index) {
  var previous = this.getParent(cell);
  if (null != parent) {
    if (!(parent == previous && previous.getIndex(cell) == index)) {
      parent.insert(cell, index);
    }
  } else {
    if (null != previous) {
      index = previous.getIndex(cell);
      previous.remove(index);
    }
  }
  parent = this.contains(parent);
  index = this.contains(previous);
  if (parent && !index) {
    this.cellAdded(cell);
  } else {
    if (index) {
      if (!parent) {
        this.cellRemoved(cell);
      }
    }
  }
  return previous;
};
mxGraphModel.prototype.getChildCount = function(cell) {
  return null != cell ? cell.getChildCount() : 0;
};
mxGraphModel.prototype.getChildAt = function(cell, index) {
  return null != cell ? cell.getChildAt(index) : null;
};
mxGraphModel.prototype.getChildren = function(cell) {
  return null != cell ? cell.children : null;
};
mxGraphModel.prototype.getChildVertices = function(parent) {
  return this.getChildCells(parent, true, false);
};
mxGraphModel.prototype.getChildEdges = function(parent) {
  return this.getChildCells(parent, false, true);
};
mxGraphModel.prototype.getChildCells = function(parent, vertices, edges) {
  vertices = null != vertices ? vertices : false;
  edges = null != edges ? edges : false;
  var childCount = this.getChildCount(parent);
  var result = [];
  for (var i = 0;i < childCount;i++) {
    var child = this.getChildAt(parent, i);
    if (!edges && !vertices || (edges && this.isEdge(child) || vertices && this.isVertex(child))) {
      result.push(child);
    }
  }
  return result;
};
mxGraphModel.prototype.getTerminal = function(edge, isOutgoing) {
  return null != edge ? edge.getTerminal(isOutgoing) : null;
};
mxGraphModel.prototype.setTerminal = function(edge, terminal, isSource) {
  var terminalChanged = terminal != this.getTerminal(edge, isSource);
  this.execute(new mxTerminalChange(this, edge, terminal, isSource));
  if (this.maintainEdgeParent) {
    if (terminalChanged) {
      this.updateEdgeParent(edge, this.getRoot());
    }
  }
  return terminal;
};
mxGraphModel.prototype.setTerminals = function(edge, target, source) {
  this.beginUpdate();
  try {
    this.setTerminal(edge, target, true);
    this.setTerminal(edge, source, false);
  } finally {
    this.endUpdate();
  }
};
mxGraphModel.prototype.terminalForCellChanged = function(edge, terminal, isSource) {
  var previous = this.getTerminal(edge, isSource);
  if (null != terminal) {
    terminal.insertEdge(edge, isSource);
  } else {
    if (null != previous) {
      previous.removeEdge(edge, isSource);
    }
  }
  return previous;
};
mxGraphModel.prototype.getEdgeCount = function(cell) {
  return null != cell ? cell.getEdgeCount() : 0;
};
mxGraphModel.prototype.getEdgeAt = function(cell, index) {
  return null != cell ? cell.getEdgeAt(index) : null;
};
mxGraphModel.prototype.getDirectedEdgeCount = function(cell, outgoing, ignoredEdge) {
  var count = 0;
  var edgeCount = this.getEdgeCount(cell);
  for (var i = 0;i < edgeCount;i++) {
    var edge = this.getEdgeAt(cell, i);
    if (edge != ignoredEdge) {
      if (this.getTerminal(edge, outgoing) == cell) {
        count++;
      }
    }
  }
  return count;
};
mxGraphModel.prototype.getConnections = function(cell) {
  return this.getEdges(cell, true, true, false);
};
mxGraphModel.prototype.getIncomingEdges = function(cell) {
  return this.getEdges(cell, true, false, false);
};
mxGraphModel.prototype.getOutgoingEdges = function(cell) {
  return this.getEdges(cell, false, true, false);
};
mxGraphModel.prototype.getEdges = function(cell, outgoing, incoming, includeLoops) {
  outgoing = null != outgoing ? outgoing : true;
  incoming = null != incoming ? incoming : true;
  includeLoops = null != includeLoops ? includeLoops : true;
  var edgeCount = this.getEdgeCount(cell);
  var result = [];
  for (var i = 0;i < edgeCount;i++) {
    var edge = this.getEdgeAt(cell, i);
    var source = this.getTerminal(edge, true);
    var target = this.getTerminal(edge, false);
    if (includeLoops && source == target || source != target && (outgoing && target == cell || incoming && source == cell)) {
      result.push(edge);
    }
  }
  return result;
};
mxGraphModel.prototype.getEdgesBetween = function(source, target, isConnect) {
  isConnect = null != isConnect ? isConnect : false;
  var result = this.getEdgeCount(source);
  var i = this.getEdgeCount(target);
  var terminal = source;
  var childCount = result;
  if (i < result) {
    childCount = i;
    terminal = target;
  }
  result = [];
  for (i = 0;i < childCount;i++) {
    var edge = this.getEdgeAt(terminal, i);
    var src = this.getTerminal(edge, true);
    var trg = this.getTerminal(edge, false);
    var n = trg == source && src == target;
    if (src == source && trg == target || !isConnect && n) {
      result.push(edge);
    }
  }
  return result;
};
mxGraphModel.prototype.getOpposites = function(edges, terminal, targets, sources) {
  targets = null != targets ? targets : true;
  sources = null != sources ? sources : true;
  var terminals = [];
  if (null != edges) {
    for (var i = 0;i < edges.length;i++) {
      var target = this.getTerminal(edges[i], true);
      var source = this.getTerminal(edges[i], false);
      if (target == terminal && (null != source && (source != terminal && sources))) {
        terminals.push(source);
      } else {
        if (source == terminal) {
          if (null != target) {
            if (target != terminal) {
              if (targets) {
                terminals.push(target);
              }
            }
          }
        }
      }
    }
  }
  return terminals;
};
mxGraphModel.prototype.getTopmostCells = function(cells) {
  var dict = new mxDictionary;
  var tmp = [];
  for (var i = 0;i < cells.length;i++) {
    dict.put(cells[i], true);
  }
  for (i = 0;i < cells.length;i++) {
    var child = cells[i];
    var f = true;
    for (var cell = this.getParent(child);null != cell;) {
      if (dict.get(cell)) {
        f = false;
        break;
      }
      cell = this.getParent(cell);
    }
    if (f) {
      tmp.push(child);
    }
  }
  return tmp;
};
mxGraphModel.prototype.isVertex = function(cell) {
  return null != cell ? cell.isVertex() : false;
};
mxGraphModel.prototype.isEdge = function(cell) {
  return null != cell ? cell.isEdge() : false;
};
mxGraphModel.prototype.isConnectable = function(cell) {
  return null != cell ? cell.isConnectable() : false;
};
mxGraphModel.prototype.getValue = function(cell) {
  return null != cell ? cell.getValue() : null;
};
mxGraphModel.prototype.setValue = function(cell, value) {
  this.execute(new mxValueChange(this, cell, value));
  return value;
};
mxGraphModel.prototype.valueForCellChanged = function(cell, value) {
  return cell.valueChanged(value);
};
mxGraphModel.prototype.getGeometry = function(cell) {
  return null != cell ? cell.getGeometry() : null;
};
mxGraphModel.prototype.setGeometry = function(cell, geo) {
  if (geo != this.getGeometry(cell)) {
    this.execute(new mxGeometryChange(this, cell, geo));
  }
  return geo;
};
mxGraphModel.prototype.geometryForCellChanged = function(cell, geometry) {
  var previous = this.getGeometry(cell);
  cell.setGeometry(geometry);
  return previous;
};
mxGraphModel.prototype.getStyle = function(cell) {
  return null != cell ? cell.getStyle() : null;
};
mxGraphModel.prototype.setStyle = function(cell, style) {
  if (style != this.getStyle(cell)) {
    this.execute(new mxStyleChange(this, cell, style));
  }
  return style;
};
mxGraphModel.prototype.styleForCellChanged = function(cell, style) {
  var previous = this.getStyle(cell);
  cell.setStyle(style);
  return previous;
};
mxGraphModel.prototype.isCollapsed = function(cell) {
  return null != cell ? cell.isCollapsed() : false;
};
mxGraphModel.prototype.setCollapsed = function(cell, collapsed) {
  if (collapsed != this.isCollapsed(cell)) {
    this.execute(new mxCollapseChange(this, cell, collapsed));
  }
  return collapsed;
};
mxGraphModel.prototype.collapsedStateForCellChanged = function(cell, collapsed) {
  var previous = this.isCollapsed(cell);
  cell.setCollapsed(collapsed);
  return previous;
};
mxGraphModel.prototype.isVisible = function(cell) {
  return null != cell ? cell.isVisible() : false;
};
mxGraphModel.prototype.setVisible = function(visible, child) {
  if (child != this.isVisible(visible)) {
    this.execute(new mxVisibleChange(this, visible, child));
  }
  return child;
};
mxGraphModel.prototype.visibleStateForCellChanged = function(cell, visible) {
  var previous = this.isVisible(cell);
  cell.setVisible(visible);
  return previous;
};
mxGraphModel.prototype.execute = function(parent) {
  parent.execute();
  this.beginUpdate();
  this.currentEdit.add(parent);
  this.fireEvent(new mxEventObject(mxEvent.EXECUTE, "change", parent));
  this.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", parent));
  this.endUpdate();
};
mxGraphModel.prototype.beginUpdate = function() {
  this.updateLevel++;
  this.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE));
  if (1 == this.updateLevel) {
    this.fireEvent(new mxEventObject(mxEvent.START_EDIT));
  }
};
mxGraphModel.prototype.endUpdate = function() {
  this.updateLevel--;
  if (0 == this.updateLevel) {
    this.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  if (!this.endingUpdate) {
    this.endingUpdate = 0 == this.updateLevel;
    this.fireEvent(new mxEventObject(mxEvent.END_UPDATE, "edit", this.currentEdit));
    try {
      if (this.endingUpdate && !this.currentEdit.isEmpty()) {
        this.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, "edit", this.currentEdit));
        var tmp = this.currentEdit;
        this.currentEdit = this.createUndoableEdit();
        tmp.notify();
        this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", tmp));
      }
    } finally {
      this.endingUpdate = false;
    }
  }
};
mxGraphModel.prototype.createUndoableEdit = function(significant) {
  var edit = new mxUndoableEdit(this, null != significant ? significant : true);
  edit.notify = function() {
    edit.source.fireEvent(new mxEventObject(mxEvent.CHANGE, "edit", edit, "changes", edit.changes));
    edit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY, "edit", edit, "changes", edit.changes));
  };
  return edit;
};
mxGraphModel.prototype.mergeChildren = function(from, to, cloneAllEdges) {
  cloneAllEdges = null != cloneAllEdges ? cloneAllEdges : true;
  this.beginUpdate();
  try {
    var mapping = {};
    this.mergeChildrenImpl(from, to, cloneAllEdges, mapping);
    for (var key in mapping) {
      var cell = mapping[key];
      var terminal = this.getTerminal(cell, true);
      if (null != terminal) {
        terminal = mapping[mxCellPath.create(terminal)];
        this.setTerminal(cell, terminal, true);
      }
      terminal = this.getTerminal(cell, false);
      if (null != terminal) {
        terminal = mapping[mxCellPath.create(terminal)];
        this.setTerminal(cell, terminal, false);
      }
    }
  } finally {
    this.endUpdate();
  }
};
mxGraphModel.prototype.mergeChildrenImpl = function(from, to, cloneAllEdges, mapping) {
  this.beginUpdate();
  try {
    var childCount = from.getChildCount();
    for (var i = 0;i < childCount;i++) {
      var cell = from.getChildAt(i);
      if ("function" == typeof cell.getId) {
        var me = cell.getId();
        var target = null == me || this.isEdge(cell) && cloneAllEdges ? null : this.getCell(me);
        if (null == target) {
          var clone = cell.clone();
          clone.setId(me);
          clone.setTerminal(cell.getTerminal(true), true);
          clone.setTerminal(cell.getTerminal(false), false);
          target = to.insert(clone);
          this.cellAdded(target);
        }
        mapping[mxCellPath.create(cell)] = target;
        this.mergeChildrenImpl(cell, target, cloneAllEdges, mapping);
      }
    }
  } finally {
    this.endUpdate();
  }
};
mxGraphModel.prototype.getParents = function(cells) {
  var parents = [];
  if (null != cells) {
    var dict = new mxDictionary;
    for (var i = 0;i < cells.length;i++) {
      var cell = this.getParent(cells[i]);
      if (!(null == cell)) {
        if (!dict.get(cell)) {
          dict.put(cell, true);
          parents.push(cell);
        }
      }
    }
  }
  return parents;
};
mxGraphModel.prototype.cloneCell = function(cell, includeChildren, keepPosition) {
  return null != cell ? this.cloneCells([cell], includeChildren, null, keepPosition)[0] : null;
};
mxGraphModel.prototype.cloneCells = function(cells, includeChildren, mapping, keepPosition) {
  includeChildren = null != includeChildren ? includeChildren : true;
  mapping = null != mapping ? mapping : {};
  keepPosition = null != keepPosition ? keepPosition : false;
  var clones = [];
  for (var i = 0;i < cells.length;i++) {
    if (null != cells[i]) {
      clones.push(this.cloneCellImpl(cells[i], mapping, includeChildren, keepPosition));
    } else {
      clones.push(null);
    }
  }
  for (i = 0;i < clones.length;i++) {
    if (null != clones[i]) {
      this.restoreClone(clones[i], cells[i], mapping);
    }
  }
  return clones;
};
mxGraphModel.prototype.cloneCellImpl = function(cell, mapping, includeChildren, keepPosition) {
  var i = mxObjectIdentity.get(cell);
  var clone = mapping[i];
  if (null == clone && (clone = this.cellCloned(cell), mapping[i] = clone, keepPosition && (clone.id = cell.id), includeChildren)) {
    includeChildren = this.getChildCount(cell);
    for (i = 0;i < includeChildren;i++) {
      var cloneChild = this.cloneCellImpl(this.getChildAt(cell, i), mapping, true, keepPosition);
      clone.insert(cloneChild);
    }
  }
  return clone;
};
mxGraphModel.prototype.cellCloned = function(cell) {
  return cell.clone();
};
mxGraphModel.prototype.restoreClone = function(clone, cell, mapping) {
  var terminal = this.getTerminal(cell, true);
  if (null != terminal) {
    terminal = mapping[mxObjectIdentity.get(terminal)];
    if (null != terminal) {
      terminal.insertEdge(clone, true);
    }
  }
  terminal = this.getTerminal(cell, false);
  if (null != terminal) {
    terminal = mapping[mxObjectIdentity.get(terminal)];
    if (null != terminal) {
      terminal.insertEdge(clone, false);
    }
  }
  terminal = this.getChildCount(clone);
  for (var i = 0;i < terminal;i++) {
    this.restoreClone(this.getChildAt(clone, i), this.getChildAt(cell, i), mapping);
  }
};
function mxRootChange(model, root) {
  this.model = model;
  this.previous = this.root = root;
}
mxRootChange.prototype.execute = function() {
  this.root = this.previous;
  this.previous = this.model.rootChanged(this.previous);
};
function mxChildChange(model, parent, child, index) {
  this.model = model;
  this.previous = this.parent = parent;
  this.child = child;
  this.previousIndex = this.index = index;
}
mxChildChange.prototype.execute = function() {
  if (null != this.child) {
    var tmp = this.model.getParent(this.child);
    var tmp2 = null != tmp ? tmp.getIndex(this.child) : 0;
    if (null == this.previous) {
      this.connect(this.child, false);
    }
    tmp = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);
    if (null != this.previous) {
      this.connect(this.child, true);
    }
    this.parent = this.previous;
    this.previous = tmp;
    this.index = this.previousIndex;
    this.previousIndex = tmp2;
  }
};
mxChildChange.prototype.connect = function(cell, isConnect) {
  isConnect = null != isConnect ? isConnect : true;
  var source = cell.getTerminal(true);
  var i = cell.getTerminal(false);
  if (null != source) {
    if (isConnect) {
      this.model.terminalForCellChanged(cell, source, true);
    } else {
      this.model.terminalForCellChanged(cell, null, true);
    }
  }
  if (null != i) {
    if (isConnect) {
      this.model.terminalForCellChanged(cell, i, false);
    } else {
      this.model.terminalForCellChanged(cell, null, false);
    }
  }
  cell.setTerminal(source, true);
  cell.setTerminal(i, false);
  source = this.model.getChildCount(cell);
  for (i = 0;i < source;i++) {
    this.connect(this.model.getChildAt(cell, i), isConnect);
  }
};
function mxTerminalChange(model, cell, terminal, source) {
  this.model = model;
  this.cell = cell;
  this.previous = this.terminal = terminal;
  this.source = source;
}
mxTerminalChange.prototype.execute = function() {
  if (null != this.cell) {
    this.terminal = this.previous;
    this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);
  }
};
function mxValueChange(model, cell, value) {
  this.model = model;
  this.cell = cell;
  this.previous = this.value = value;
}
mxValueChange.prototype.execute = function() {
  if (null != this.cell) {
    this.value = this.previous;
    this.previous = this.model.valueForCellChanged(this.cell, this.previous);
  }
};
function mxStyleChange(model, cell, style) {
  this.model = model;
  this.cell = cell;
  this.previous = this.style = style;
}
mxStyleChange.prototype.execute = function() {
  if (null != this.cell) {
    this.style = this.previous;
    this.previous = this.model.styleForCellChanged(this.cell, this.previous);
  }
};
function mxGeometryChange(model, cell, geometry) {
  this.model = model;
  this.cell = cell;
  this.previous = this.geometry = geometry;
}
mxGeometryChange.prototype.execute = function() {
  if (null != this.cell) {
    this.geometry = this.previous;
    this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
  }
};
function mxCollapseChange(model, cell, collapsed) {
  this.model = model;
  this.cell = cell;
  this.previous = this.collapsed = collapsed;
}
mxCollapseChange.prototype.execute = function() {
  if (null != this.cell) {
    this.collapsed = this.previous;
    this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);
  }
};
function mxVisibleChange(model, cell, visible) {
  this.model = model;
  this.cell = cell;
  this.previous = this.visible = visible;
}
mxVisibleChange.prototype.execute = function() {
  if (null != this.cell) {
    this.visible = this.previous;
    this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);
  }
};
function mxCellAttributeChange(cell, attribute, value) {
  this.cell = cell;
  this.attribute = attribute;
  this.previous = this.value = value;
}
mxCellAttributeChange.prototype.execute = function() {
  if (null != this.cell) {
    var tmp = this.cell.getAttribute(this.attribute);
    if (null == this.previous) {
      this.cell.value.removeAttribute(this.attribute);
    } else {
      this.cell.setAttribute(this.attribute, this.previous);
    }
    this.previous = tmp;
  }
};
function mxCell(value, geometry, style) {
  this.value = value;
  this.setGeometry(geometry);
  this.setStyle(style);
  if (null != this.onInit) {
    this.onInit();
  }
}
mxCell.prototype.id = null;
mxCell.prototype.value = null;
mxCell.prototype.geometry = null;
mxCell.prototype.style = null;
mxCell.prototype.vertex = false;
mxCell.prototype.edge = false;
mxCell.prototype.connectable = true;
mxCell.prototype.visible = true;
mxCell.prototype.collapsed = false;
mxCell.prototype.parent = null;
mxCell.prototype.source = null;
mxCell.prototype.target = null;
mxCell.prototype.children = null;
mxCell.prototype.edges = null;
mxCell.prototype.mxTransient = "id value parent source target children edges".split(" ");
mxCell.prototype.getId = function() {
  return this.id;
};
mxCell.prototype.setId = function(id) {
  this.id = id;
};
mxCell.prototype.getValue = function() {
  return this.value;
};
mxCell.prototype.setValue = function(cell) {
  this.value = cell;
};
mxCell.prototype.valueChanged = function(newValue) {
  var previous = this.getValue();
  this.setValue(newValue);
  return previous;
};
mxCell.prototype.getGeometry = function() {
  return this.geometry;
};
mxCell.prototype.setGeometry = function(cell) {
  this.geometry = cell;
};
mxCell.prototype.getStyle = function() {
  return this.style;
};
mxCell.prototype.setStyle = function(style) {
  this.style = style;
};
mxCell.prototype.isVertex = function() {
  return 0 != this.vertex;
};
mxCell.prototype.setVertex = function(update) {
  this.vertex = update;
};
mxCell.prototype.isEdge = function() {
  return 0 != this.edge;
};
mxCell.prototype.setEdge = function(update) {
  this.edge = update;
};
mxCell.prototype.isConnectable = function() {
  return 0 != this.connectable;
};
mxCell.prototype.setConnectable = function(bubble) {
  this.connectable = bubble;
};
mxCell.prototype.isVisible = function() {
  return 0 != this.visible;
};
mxCell.prototype.setVisible = function(visible) {
  this.visible = visible;
};
mxCell.prototype.isCollapsed = function() {
  return 0 != this.collapsed;
};
mxCell.prototype.setCollapsed = function(collapsed) {
  this.collapsed = collapsed;
};
mxCell.prototype.getParent = function() {
  return this.parent;
};
mxCell.prototype.setParent = function(parent) {
  this.parent = parent;
};
mxCell.prototype.getTerminal = function(source) {
  return source ? this.source : this.target;
};
mxCell.prototype.setTerminal = function(edge, isSource) {
  if (isSource) {
    this.source = edge;
  } else {
    this.target = edge;
  }
  return edge;
};
mxCell.prototype.getChildCount = function() {
  return null == this.children ? 0 : this.children.length;
};
mxCell.prototype.getIndex = function(cell) {
  return mxUtils.indexOf(this.children, cell);
};
mxCell.prototype.getChildAt = function(cell) {
  return null == this.children ? null : this.children[cell];
};
mxCell.prototype.insert = function(child, index) {
  if (null != child) {
    if (null == index) {
      index = this.getChildCount();
      if (child.getParent() == this) {
        index--;
      }
    }
    child.removeFromParent();
    child.setParent(this);
    if (null == this.children) {
      this.children = [];
      this.children.push(child);
    } else {
      this.children.splice(index, 0, child);
    }
  }
  return child;
};
mxCell.prototype.remove = function(cell) {
  var child = null;
  if (null != this.children) {
    if (0 <= cell) {
      child = this.getChildAt(cell);
      if (null != child) {
        this.children.splice(cell, 1);
        child.setParent(null);
      }
    }
  }
  return child;
};
mxCell.prototype.removeFromParent = function() {
  if (null != this.parent) {
    var cell = this.parent.getIndex(this);
    this.parent.remove(cell);
  }
};
mxCell.prototype.getEdgeCount = function() {
  return null == this.edges ? 0 : this.edges.length;
};
mxCell.prototype.getEdgeIndex = function(edge) {
  return mxUtils.indexOf(this.edges, edge);
};
mxCell.prototype.getEdgeAt = function(cell) {
  return null == this.edges ? null : this.edges[cell];
};
mxCell.prototype.insertEdge = function(edge, isOutgoing) {
  if (null != edge) {
    if (edge.removeFromTerminal(isOutgoing), edge.setTerminal(this, isOutgoing), null == this.edges || (edge.getTerminal(!isOutgoing) != this || 0 > mxUtils.indexOf(this.edges, edge))) {
      if (null == this.edges) {
        this.edges = [];
      }
      this.edges.push(edge);
    }
  }
  return edge;
};
mxCell.prototype.removeEdge = function(edge, isOutgoing) {
  if (null != edge) {
    if (edge.getTerminal(!isOutgoing) != this && null != this.edges) {
      var index = this.getEdgeIndex(edge);
      if (0 <= index) {
        this.edges.splice(index, 1);
      }
    }
    edge.setTerminal(null, isOutgoing);
  }
  return edge;
};
mxCell.prototype.removeFromTerminal = function(isSource) {
  var terminal = this.getTerminal(isSource);
  if (null != terminal) {
    terminal.removeEdge(this, isSource);
  }
};
mxCell.prototype.hasAttribute = function(name) {
  var userObject = this.getValue();
  return null != userObject && (userObject.nodeType == mxConstants.NODETYPE_ELEMENT && userObject.hasAttribute) ? userObject.hasAttribute(name) : null != userObject.getAttribute(name);
};
mxCell.prototype.getAttribute = function(value, defaultValue) {
  var entry = this.getValue();
  value = null != entry && entry.nodeType == mxConstants.NODETYPE_ELEMENT ? entry.getAttribute(value) : null;
  return null != value ? value : defaultValue;
};
mxCell.prototype.setAttribute = function(node, value) {
  var userObject = this.getValue();
  if (null != userObject) {
    if (userObject.nodeType == mxConstants.NODETYPE_ELEMENT) {
      userObject.setAttribute(node, value);
    }
  }
};
mxCell.prototype.clone = function() {
  var clone = mxUtils.clone(this, this.mxTransient);
  clone.setValue(this.cloneValue());
  return clone;
};
mxCell.prototype.cloneValue = function(value) {
  value = null != value ? value : this.getValue();
  if (null != value) {
    if ("function" == typeof value.clone) {
      value = value.clone();
    } else {
      if (!isNaN(value.nodeType)) {
        value = value.cloneNode(true);
      }
    }
  }
  return value;
};
function mxGeometry(x, y, width, height) {
  mxRectangle.call(this, x, y, width, height);
}
mxGeometry.prototype = new mxRectangle;
mxGeometry.prototype.constructor = mxGeometry;
mxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;
mxGeometry.prototype.alternateBounds = null;
mxGeometry.prototype.sourcePoint = null;
mxGeometry.prototype.targetPoint = null;
mxGeometry.prototype.points = null;
mxGeometry.prototype.offset = null;
mxGeometry.prototype.relative = false;
mxGeometry.prototype.swap = function() {
  if (null != this.alternateBounds) {
    var old = new mxRectangle(this.x, this.y, this.width, this.height);
    this.x = this.alternateBounds.x;
    this.y = this.alternateBounds.y;
    this.width = this.alternateBounds.width;
    this.height = this.alternateBounds.height;
    this.alternateBounds = old;
  }
};
mxGeometry.prototype.getTerminalPoint = function(isSource) {
  return isSource ? this.sourcePoint : this.targetPoint;
};
mxGeometry.prototype.setTerminalPoint = function(point, isSource) {
  if (isSource) {
    this.sourcePoint = point;
  } else {
    this.targetPoint = point;
  }
  return point;
};
mxGeometry.prototype.rotate = function(angle, cx) {
  var rad = mxUtils.toRadians(angle);
  angle = Math.cos(rad);
  rad = Math.sin(rad);
  if (!this.relative) {
    var pt = new mxPoint(this.getCenterX(), this.getCenterY());
    pt = mxUtils.getRotatedPoint(pt, angle, rad, cx);
    this.x = Math.round(pt.x - this.width / 2);
    this.y = Math.round(pt.y - this.height / 2);
  }
  if (null != this.sourcePoint) {
    pt = mxUtils.getRotatedPoint(this.sourcePoint, angle, rad, cx);
    this.sourcePoint.x = Math.round(pt.x);
    this.sourcePoint.y = Math.round(pt.y);
  }
  if (null != this.targetPoint) {
    pt = mxUtils.getRotatedPoint(this.targetPoint, angle, rad, cx);
    this.targetPoint.x = Math.round(pt.x);
    this.targetPoint.y = Math.round(pt.y);
  }
  if (null != this.points) {
    for (var i = 0;i < this.points.length;i++) {
      if (null != this.points[i]) {
        pt = mxUtils.getRotatedPoint(this.points[i], angle, rad, cx);
        this.points[i].x = Math.round(pt.x);
        this.points[i].y = Math.round(pt.y);
      }
    }
  }
};
mxGeometry.prototype.translate = function(x, y) {
  x = parseFloat(x);
  y = parseFloat(y);
  if (!this.relative) {
    this.x = parseFloat(this.x) + x;
    this.y = parseFloat(this.y) + y;
  }
  if (null != this.sourcePoint) {
    this.sourcePoint.x = parseFloat(this.sourcePoint.x) + x;
    this.sourcePoint.y = parseFloat(this.sourcePoint.y) + y;
  }
  if (null != this.targetPoint) {
    this.targetPoint.x = parseFloat(this.targetPoint.x) + x;
    this.targetPoint.y = parseFloat(this.targetPoint.y) + y;
  }
  if (this.TRANSLATE_CONTROL_POINTS && null != this.points) {
    for (var i = 0;i < this.points.length;i++) {
      if (null != this.points[i]) {
        this.points[i].x = parseFloat(this.points[i].x) + x;
        this.points[i].y = parseFloat(this.points[i].y) + y;
      }
    }
  }
};
mxGeometry.prototype.scale = function(x, y, value) {
  x = parseFloat(x);
  y = parseFloat(y);
  if (null != this.sourcePoint) {
    this.sourcePoint.x = parseFloat(this.sourcePoint.x) * x;
    this.sourcePoint.y = parseFloat(this.sourcePoint.y) * y;
  }
  if (null != this.targetPoint) {
    this.targetPoint.x = parseFloat(this.targetPoint.x) * x;
    this.targetPoint.y = parseFloat(this.targetPoint.y) * y;
  }
  if (null != this.points) {
    for (var i = 0;i < this.points.length;i++) {
      if (null != this.points[i]) {
        this.points[i].x = parseFloat(this.points[i].x) * x;
        this.points[i].y = parseFloat(this.points[i].y) * y;
      }
    }
  }
  if (!this.relative) {
    this.x = parseFloat(this.x) * x;
    this.y = parseFloat(this.y) * y;
    if (value) {
      y = x = Math.min(x, y);
    }
    this.width = parseFloat(this.width) * x;
    this.height = parseFloat(this.height) * y;
  }
};
mxGeometry.prototype.equals = function(obj) {
  return mxRectangle.prototype.equals.apply(this, arguments) && (this.relative == obj.relative && ((null == this.sourcePoint && null == obj.sourcePoint || null != this.sourcePoint && this.sourcePoint.equals(obj.sourcePoint)) && ((null == this.targetPoint && null == obj.targetPoint || null != this.targetPoint && this.targetPoint.equals(obj.targetPoint)) && ((null == this.points && null == obj.points || null != this.points && mxUtils.equalPoints(this.points, obj.points)) && ((null == this.alternateBounds &&
  null == obj.alternateBounds || null != this.alternateBounds && this.alternateBounds.equals(obj.alternateBounds)) && (null == this.offset && null == obj.offset || null != this.offset && this.offset.equals(obj.offset)))))));
};
var mxCellPath = {
  PATH_SEPARATOR : ".",
  create : function(cell) {
    var url = "";
    if (null != cell) {
      for (var parent = cell.getParent();null != parent;) {
        url = parent.getIndex(cell) + mxCellPath.PATH_SEPARATOR + url;
        cell = parent;
        parent = cell.getParent();
      }
    }
    cell = url.length;
    if (1 < cell) {
      url = url.substring(0, cell - 1);
    }
    return url;
  },
  getParentPath : function(path) {
    if (null != path) {
      var index = path.lastIndexOf(mxCellPath.PATH_SEPARATOR);
      if (0 <= index) {
        return path.substring(0, index);
      }
      if (0 < path.length) {
        return "";
      }
    }
    return null;
  },
  resolve : function(parent, path) {
    if (null != path) {
      path = path.split(mxCellPath.PATH_SEPARATOR);
      for (var i = 0;i < path.length;i++) {
        parent = parent.getChildAt(parseInt(path[i]));
      }
    }
    return parent;
  },
  compare : function(p1, p2) {
    var j = Math.min(p1.length, p2.length);
    var comp = 0;
    for (var i = 0;i < j;i++) {
      if (p1[i] != p2[i]) {
        if (0 == p1[i].length || 0 == p2[i].length) {
          comp = p1[i] == p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;
        } else {
          j = parseInt(p1[i]);
          i = parseInt(p2[i]);
          comp = j == i ? 0 : j > i ? 1 : -1;
        }
        break;
      }
    }
    if (0 == comp) {
      j = p1.length;
      i = p2.length;
      if (j != i) {
        comp = j > i ? 1 : -1;
      }
    }
    return comp;
  }
};
var mxPerimeter = {
  RectanglePerimeter : function(bounds, cx, next, vertex) {
    cx = bounds.getCenterX();
    var cy = bounds.getCenterY();
    var alpha = Math.atan2(next.y - cy, next.x - cx);
    var p = new mxPoint(0, 0);
    var pi = Math.PI;
    var beta = Math.PI / 2 - alpha;
    var t = Math.atan2(bounds.height, bounds.width);
    if (alpha < -pi + t || alpha > pi - t) {
      p.x = bounds.x;
      p.y = cy - bounds.width * Math.tan(alpha) / 2;
    } else {
      if (alpha < -t) {
        p.y = bounds.y;
        p.x = cx - bounds.height * Math.tan(beta) / 2;
      } else {
        if (alpha < t) {
          p.x = bounds.x + bounds.width;
          p.y = cy + bounds.width * Math.tan(alpha) / 2;
        } else {
          p.y = bounds.y + bounds.height;
          p.x = cx + bounds.height * Math.tan(beta) / 2;
        }
      }
    }
    if (vertex) {
      if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {
        p.x = next.x;
      } else {
        if (next.y >= bounds.y) {
          if (next.y <= bounds.y + bounds.height) {
            p.y = next.y;
          }
        }
      }
      if (next.x < bounds.x) {
        p.x = bounds.x;
      } else {
        if (next.x > bounds.x + bounds.width) {
          p.x = bounds.x + bounds.width;
        }
      }
      if (next.y < bounds.y) {
        p.y = bounds.y;
      } else {
        if (next.y > bounds.y + bounds.height) {
          p.y = bounds.y + bounds.height;
        }
      }
    }
    return p;
  },
  EllipsePerimeter : function(bounds, px, py, orthogonal) {
    var x = bounds.x;
    var y = bounds.y;
    var a = bounds.width / 2;
    var b = bounds.height / 2;
    var cx = x + a;
    var cy = y + b;
    px = py.x;
    py = py.y;
    var dx = parseInt(px - cx);
    var dy = parseInt(py - cy);
    if (0 == dx && 0 != dy) {
      return new mxPoint(cx, cy + b * dy / Math.abs(dy));
    }
    if (0 == dx && 0 == dy) {
      return new mxPoint(px, py);
    }
    if (orthogonal) {
      if (py >= y && py <= y + bounds.height) {
        return bounds = py - cy, bounds = Math.sqrt(a * a * (1 - bounds * bounds / (b * b))) || 0, px <= x && (bounds = -bounds), new mxPoint(cx + bounds, py);
      }
      if (px >= x && px <= x + bounds.width) {
        return bounds = px - cx, bounds = Math.sqrt(b * b * (1 - bounds * bounds / (a * a))) || 0, py <= y && (bounds = -bounds), new mxPoint(px, cy + bounds);
      }
    }
    x = dy / dx;
    cy -= x * cx;
    y = a * a * x * x + b * b;
    bounds = -2 * cx * y;
    b = Math.sqrt(bounds * bounds - 4 * y * (a * a * x * x * cx * cx + b * b * cx * cx - a * a * b * b));
    a = (-bounds + b) / (2 * y);
    cx = (-bounds - b) / (2 * y);
    b = x * a + cy;
    cy = x * cx + cy;
    if (Math.sqrt(Math.pow(a - px, 2) + Math.pow(b - py, 2)) < Math.sqrt(Math.pow(cx - px, 2) + Math.pow(cy - py, 2))) {
      px = a;
      py = b;
    } else {
      px = cx;
      py = cy;
    }
    return new mxPoint(px, py);
  },
  RhombusPerimeter : function(bounds, x, py, orthogonal) {
    x = bounds.x;
    var y = bounds.y;
    var w = bounds.width;
    bounds = bounds.height;
    var cx = x + w / 2;
    var cy = y + bounds / 2;
    var px = py.x;
    py = py.y;
    if (cx == px) {
      return cy > py ? new mxPoint(cx, y) : new mxPoint(cx, y + bounds);
    }
    if (cy == py) {
      return cx > px ? new mxPoint(x, cy) : new mxPoint(x + w, cy);
    }
    var tx = cx;
    var ty = cy;
    if (orthogonal) {
      if (px >= x && px <= x + w) {
        tx = px;
      } else {
        if (py >= y) {
          if (py <= y + bounds) {
            ty = py;
          }
        }
      }
    }
    return px < cx ? py < cy ? mxUtils.intersection(px, py, tx, ty, cx, y, x, cy) : mxUtils.intersection(px, py, tx, ty, cx, y + bounds, x, cy) : py < cy ? mxUtils.intersection(px, py, tx, ty, cx, y, x + w, cy) : mxUtils.intersection(px, py, tx, ty, cx, y + bounds, x + w, cy);
  },
  TrianglePerimeter : function(cx, direction, next, pt) {
    direction = null != direction ? direction.style[mxConstants.STYLE_DIRECTION] : null;
    var vertical = direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH;
    var x = cx.x;
    var y = cx.y;
    var w = cx.width;
    var h = cx.height;
    cx = x + w / 2;
    var cy = y + h / 2;
    var start = new mxPoint(x, y);
    var corner = new mxPoint(x + w, cy);
    var end = new mxPoint(x, y + h);
    if (direction == mxConstants.DIRECTION_NORTH) {
      start = end;
      corner = new mxPoint(cx, y);
      end = new mxPoint(x + w, y + h);
    } else {
      if (direction == mxConstants.DIRECTION_SOUTH) {
        corner = new mxPoint(cx, y + h);
        end = new mxPoint(x + w, y);
      } else {
        if (direction == mxConstants.DIRECTION_WEST) {
          start = new mxPoint(x + w, y);
          corner = new mxPoint(x, cy);
          end = new mxPoint(x + w, y + h);
        }
      }
    }
    var dx = next.x - cx;
    var dy = next.y - cy;
    dx = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);
    dy = vertical ? Math.atan2(w, h) : Math.atan2(h, w);
    if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_WEST ? dx > -dy && dx < dy : dx < -Math.PI + dy || dx > Math.PI - dy) {
      next = pt && (vertical && (next.x >= start.x && next.x <= end.x) || !vertical && (next.y >= start.y && next.y <= end.y)) ? vertical ? new mxPoint(next.x, start.y) : new mxPoint(start.x, next.y) : direction == mxConstants.DIRECTION_NORTH ? new mxPoint(x + w / 2 + h * Math.tan(dx) / 2, y + h) : direction == mxConstants.DIRECTION_SOUTH ? new mxPoint(x + w / 2 - h * Math.tan(dx) / 2, y) : direction == mxConstants.DIRECTION_WEST ? new mxPoint(x + w, y + h / 2 + w * Math.tan(dx) / 2) : new mxPoint(x,
      y + h / 2 - w * Math.tan(dx) / 2);
    } else {
      if (pt) {
        pt = new mxPoint(cx, cy);
        if (next.y >= y && next.y <= y + h) {
          pt.x = vertical ? cx : direction == mxConstants.DIRECTION_WEST ? x + w : x;
          pt.y = next.y;
        } else {
          if (next.x >= x) {
            if (next.x <= x + w) {
              pt.x = next.x;
              pt.y = vertical ? direction == mxConstants.DIRECTION_NORTH ? y + h : y : cy;
            }
          }
        }
        cx = pt.x;
        cy = pt.y;
      }
      next = vertical && next.x <= x + w / 2 || !vertical && next.y <= y + h / 2 ? mxUtils.intersection(next.x, next.y, cx, cy, start.x, start.y, corner.x, corner.y) : mxUtils.intersection(next.x, next.y, cx, cy, corner.x, corner.y, end.x, end.y);
    }
    if (null == next) {
      next = new mxPoint(cx, cy);
    }
    return next;
  },
  HexagonPerimeter : function(bounds, a, next, cx) {
    var x = bounds.x;
    var y = bounds.y;
    var w = bounds.width;
    var h = bounds.height;
    var x2 = bounds.getCenterX();
    bounds = bounds.getCenterY();
    var px = next.x;
    var py = next.y;
    var alpha = -Math.atan2(py - bounds, px - x2);
    var pi = Math.PI;
    var beta = Math.PI / 2;
    new mxPoint(x2, bounds);
    a = null != a ? mxUtils.getValue(a.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST) : mxConstants.DIRECTION_EAST;
    var t = a == mxConstants.DIRECTION_NORTH || a == mxConstants.DIRECTION_SOUTH;
    a = new mxPoint;
    var b = new mxPoint;
    if (px < x && py < y || (px < x && py > y + h || (px > x + w && py < y || px > x + w && py > y + h))) {
      cx = false;
    }
    if (cx) {
      if (t) {
        if (px == x2) {
          if (py <= y) {
            return new mxPoint(x2, y);
          }
          if (py >= y + h) {
            return new mxPoint(x2, y + h);
          }
        } else {
          if (px < x) {
            if (py == y + h / 4) {
              return new mxPoint(x, y + h / 4);
            }
            if (py == y + 3 * h / 4) {
              return new mxPoint(x, y + 3 * h / 4);
            }
          } else {
            if (px > x + w) {
              if (py == y + h / 4) {
                return new mxPoint(x + w, y + h / 4);
              }
              if (py == y + 3 * h / 4) {
                return new mxPoint(x + w, y + 3 * h / 4);
              }
            } else {
              if (px == x) {
                if (py < bounds) {
                  return new mxPoint(x, y + h / 4);
                }
                if (py > bounds) {
                  return new mxPoint(x, y + 3 * h / 4);
                }
              } else {
                if (px == x + w) {
                  if (py < bounds) {
                    return new mxPoint(x + w, y + h / 4);
                  }
                  if (py > bounds) {
                    return new mxPoint(x + w, y + 3 * h / 4);
                  }
                }
              }
            }
          }
        }
        if (py == y) {
          return new mxPoint(x2, y);
        }
        if (py == y + h) {
          return new mxPoint(x2, y + h);
        }
        if (px < x2) {
          if (py > y + h / 4 && py < y + 3 * h / 4) {
            a = new mxPoint(x, y);
            b = new mxPoint(x, y + h);
          } else {
            if (py < y + h / 4) {
              a = new mxPoint(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
              b = new mxPoint(x + w, y - Math.floor(0.25 * h));
            } else {
              if (py > y + 3 * h / 4) {
                a = new mxPoint(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
                b = new mxPoint(x + w, y + Math.floor(1.25 * h));
              }
            }
          }
        } else {
          if (px > x2) {
            if (py > y + h / 4 && py < y + 3 * h / 4) {
              a = new mxPoint(x + w, y);
              b = new mxPoint(x + w, y + h);
            } else {
              if (py < y + h / 4) {
                a = new mxPoint(x, y - Math.floor(0.25 * h));
                b = new mxPoint(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
              } else {
                if (py > y + 3 * h / 4) {
                  a = new mxPoint(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
                  b = new mxPoint(x, y + Math.floor(1.25 * h));
                }
              }
            }
          }
        }
      } else {
        if (py == bounds) {
          if (px <= x) {
            return new mxPoint(x, y + h / 2);
          }
          if (px >= x + w) {
            return new mxPoint(x + w, y + h / 2);
          }
        } else {
          if (py < y) {
            if (px == x + w / 4) {
              return new mxPoint(x + w / 4, y);
            }
            if (px == x + 3 * w / 4) {
              return new mxPoint(x + 3 * w / 4, y);
            }
          } else {
            if (py > y + h) {
              if (px == x + w / 4) {
                return new mxPoint(x + w / 4, y + h);
              }
              if (px == x + 3 * w / 4) {
                return new mxPoint(x + 3 * w / 4, y + h);
              }
            } else {
              if (py == y) {
                if (px < x2) {
                  return new mxPoint(x + w / 4, y);
                }
                if (px > x2) {
                  return new mxPoint(x + 3 * w / 4, y);
                }
              } else {
                if (py == y + h) {
                  if (px < x2) {
                    return new mxPoint(x + w / 4, y + h);
                  }
                  if (py > bounds) {
                    return new mxPoint(x + 3 * w / 4, y + h);
                  }
                }
              }
            }
          }
        }
        if (px == x) {
          return new mxPoint(x, bounds);
        }
        if (px == x + w) {
          return new mxPoint(x + w, bounds);
        }
        if (py < bounds) {
          if (px > x + w / 4 && px < x + 3 * w / 4) {
            a = new mxPoint(x, y);
            b = new mxPoint(x + w, y);
          } else {
            if (px < x + w / 4) {
              a = new mxPoint(x - Math.floor(0.25 * w), y + h);
              b = new mxPoint(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
            } else {
              if (px > x + 3 * w / 4) {
                a = new mxPoint(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
                b = new mxPoint(x + Math.floor(1.25 * w), y + h);
              }
            }
          }
        } else {
          if (py > bounds) {
            if (px > x + w / 4 && px < x + 3 * w / 4) {
              a = new mxPoint(x, y + h);
              b = new mxPoint(x + w, y + h);
            } else {
              if (px < x + w / 4) {
                a = new mxPoint(x - Math.floor(0.25 * w), y);
                b = new mxPoint(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
              } else {
                if (px > x + 3 * w / 4) {
                  a = new mxPoint(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
                  b = new mxPoint(x + Math.floor(1.25 * w), y);
                }
              }
            }
          }
        }
      }
      cx = x2;
      alpha = bounds;
      if (px >= x && px <= x + w) {
        cx = px;
        alpha = py < bounds ? y + h : y;
      } else {
        if (py >= y) {
          if (py <= y + h) {
            alpha = py;
            cx = px < x2 ? x + w : x;
          }
        }
      }
      next = mxUtils.intersection(cx, alpha, next.x, next.y, a.x, a.y, b.x, b.y);
    } else {
      if (t) {
        px = Math.atan2(h / 4, w / 2);
        if (alpha == px) {
          return new mxPoint(x + w, y + Math.floor(0.25 * h));
        }
        if (alpha == beta) {
          return new mxPoint(x + Math.floor(0.5 * w), y);
        }
        if (alpha == pi - px) {
          return new mxPoint(x, y + Math.floor(0.25 * h));
        }
        if (alpha == -px) {
          return new mxPoint(x + w, y + Math.floor(0.75 * h));
        }
        if (alpha == -beta) {
          return new mxPoint(x + Math.floor(0.5 * w), y + h);
        }
        if (alpha == -pi + px) {
          return new mxPoint(x, y + Math.floor(0.75 * h));
        }
        if (alpha < px && alpha > -px) {
          a = new mxPoint(x + w, y);
          b = new mxPoint(x + w, y + h);
        } else {
          if (alpha > px && alpha < beta) {
            a = new mxPoint(x, y - Math.floor(0.25 * h));
            b = new mxPoint(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
          } else {
            if (alpha > beta && alpha < pi - px) {
              a = new mxPoint(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
              b = new mxPoint(x + w, y - Math.floor(0.25 * h));
            } else {
              if (alpha > pi - px && alpha <= pi || alpha < -pi + px && alpha >= -pi) {
                a = new mxPoint(x, y);
                b = new mxPoint(x, y + h);
              } else {
                if (alpha < -px && alpha > -beta) {
                  a = new mxPoint(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
                  b = new mxPoint(x, y + Math.floor(1.25 * h));
                } else {
                  if (alpha < -beta) {
                    if (alpha > -pi + px) {
                      a = new mxPoint(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
                      b = new mxPoint(x + w, y + Math.floor(1.25 * h));
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        px = Math.atan2(h / 2, w / 4);
        if (alpha == px) {
          return new mxPoint(x + Math.floor(0.75 * w), y);
        }
        if (alpha == pi - px) {
          return new mxPoint(x + Math.floor(0.25 * w), y);
        }
        if (alpha == pi || alpha == -pi) {
          return new mxPoint(x, y + Math.floor(0.5 * h));
        }
        if (0 == alpha) {
          return new mxPoint(x + w, y + Math.floor(0.5 * h));
        }
        if (alpha == -px) {
          return new mxPoint(x + Math.floor(0.75 * w), y + h);
        }
        if (alpha == -pi + px) {
          return new mxPoint(x + Math.floor(0.25 * w), y + h);
        }
        if (0 < alpha && alpha < px) {
          a = new mxPoint(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
          b = new mxPoint(x + Math.floor(1.25 * w), y + h);
        } else {
          if (alpha > px && alpha < pi - px) {
            a = new mxPoint(x, y);
            b = new mxPoint(x + w, y);
          } else {
            if (alpha > pi - px && alpha < pi) {
              a = new mxPoint(x - Math.floor(0.25 * w), y + h);
              b = new mxPoint(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
            } else {
              if (0 > alpha && alpha > -px) {
                a = new mxPoint(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
                b = new mxPoint(x + Math.floor(1.25 * w), y);
              } else {
                if (alpha < -px && alpha > -pi + px) {
                  a = new mxPoint(x, y + h);
                  b = new mxPoint(x + w, y + h);
                } else {
                  if (alpha < -pi + px) {
                    if (alpha > -pi) {
                      a = new mxPoint(x - Math.floor(0.25 * w), y);
                      b = new mxPoint(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
                    }
                  }
                }
              }
            }
          }
        }
      }
      next = mxUtils.intersection(x2, bounds, next.x, next.y, a.x, a.y, b.x, b.y);
    }
    return null == next ? new mxPoint(x2, bounds) : next;
  }
};
function mxPrintPreview(graph, scale, pageFormat, border, x0, y0, borderColor, title, pageSelector) {
  this.graph = graph;
  this.scale = null != scale ? scale : 1 / graph.pageScale;
  this.border = null != border ? border : 0;
  this.pageFormat = mxRectangle.fromRectangle(null != pageFormat ? pageFormat : graph.pageFormat);
  this.title = null != title ? title : "Printer-friendly version";
  this.x0 = null != x0 ? x0 : 0;
  this.y0 = null != y0 ? y0 : 0;
  this.borderColor = borderColor;
  this.pageSelector = null != pageSelector ? pageSelector : true;
}
mxPrintPreview.prototype.graph = null;
mxPrintPreview.prototype.pageFormat = null;
mxPrintPreview.prototype.scale = null;
mxPrintPreview.prototype.border = 0;
mxPrintPreview.prototype.marginTop = 0;
mxPrintPreview.prototype.marginBottom = 0;
mxPrintPreview.prototype.x0 = 0;
mxPrintPreview.prototype.y0 = 0;
mxPrintPreview.prototype.autoOrigin = true;
mxPrintPreview.prototype.printOverlays = false;
mxPrintPreview.prototype.printControls = false;
mxPrintPreview.prototype.printBackgroundImage = false;
mxPrintPreview.prototype.backgroundColor = "#ffffff";
mxPrintPreview.prototype.borderColor = null;
mxPrintPreview.prototype.title = null;
mxPrintPreview.prototype.pageSelector = null;
mxPrintPreview.prototype.wnd = null;
mxPrintPreview.prototype.targetWindow = null;
mxPrintPreview.prototype.pageCount = 0;
mxPrintPreview.prototype.clipping = true;
mxPrintPreview.prototype.getWindow = function() {
  return this.wnd;
};
mxPrintPreview.prototype.getDoctype = function() {
  var dt = "";
  if (8 == document.documentMode) {
    dt = '<meta http-equiv="X-UA-Compatible" content="IE=8">';
  } else {
    if (8 < document.documentMode) {
      dt = '\x3c!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--\x3e';
    }
  }
  return dt;
};
mxPrintPreview.prototype.appendGraph = function(graph, scale, x0, y0, forcePageBreaks, keepOpen) {
  this.graph = graph;
  this.scale = null != scale ? scale : 1 / graph.pageScale;
  this.x0 = x0;
  this.y0 = y0;
  this.open(null, null, forcePageBreaks, keepOpen);
};
mxPrintPreview.prototype.open = function(css, targetWindow, forcePageBreaks, keepOpen) {
  var previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;
  var div = null;
  try {
    if (this.printOverlays) {
      this.graph.cellRenderer.initializeOverlay = function(state, overlay) {
        overlay.init(state.view.getDrawPane());
      };
    }
    if (this.printControls) {
      this.graph.cellRenderer.initControl = function(state, control, handleEvents, clickHandler) {
        control.dialect = state.view.graph.dialect;
        control.init(state.view.getDrawPane());
      };
    }
    this.wnd = null != targetWindow ? targetWindow : this.wnd;
    var g = false;
    if (null == this.wnd) {
      g = true;
      this.wnd = window.open();
    }
    var doc = this.wnd.document;
    if (g) {
      var html = this.getDoctype();
      if (null != html) {
        if (0 < html.length) {
          doc.writeln(html);
        }
      }
      if ("CSS1Compat" === document.compatMode) {
        doc.writeln("<!DOCTYPE html>");
      }
      doc.writeln("<html>");
      doc.writeln("<head>");
      this.writeHead(doc, css);
      doc.writeln("</head>");
      doc.writeln('<body class="mxPage">');
    }
    var bounds = this.graph.getGraphBounds().clone();
    var currentScale = this.graph.getView().getScale();
    var sc = currentScale / this.scale;
    var tr = this.graph.getView().getTranslate();
    if (!this.autoOrigin) {
      this.x0 -= tr.x * this.scale;
      this.y0 -= tr.y * this.scale;
      bounds.width += bounds.x;
      bounds.height += bounds.y;
      bounds.x = 0;
      this.border = bounds.y = 0;
    }
    var availableWidth = this.pageFormat.width - 2 * this.border;
    var availableHeight = this.pageFormat.height - 2 * this.border;
    this.pageFormat.height += this.marginTop + this.marginBottom;
    bounds.width /= sc;
    bounds.height /= sc;
    var hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));
    var vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));
    this.pageCount = hpages * vpages;
    var writePageSelector = mxUtils.bind(this, function() {
      if (this.pageSelector && (1 < vpages || 1 < hpages)) {
        var table = this.createPageSelector(vpages, hpages);
        doc.body.appendChild(table);
        if (mxClient.IS_IE && null == doc.documentMode || (5 == doc.documentMode || (8 == doc.documentMode || 7 == doc.documentMode))) {
          table.style.position = "absolute";
          var update = function() {
            table.style.top = (doc.body.scrollTop || doc.documentElement.scrollTop) + 10 + "px";
          };
          mxEvent.addListener(this.wnd, "scroll", function(flex) {
            update();
          });
          mxEvent.addListener(this.wnd, "resize", function(flex) {
            update();
          });
        }
      }
    });
    var addPage = mxUtils.bind(this, function(div, addBreak) {
      if (null != this.borderColor) {
        div.style.borderColor = this.borderColor;
        div.style.borderStyle = "solid";
        div.style.borderWidth = "1px";
      }
      div.style.background = this.backgroundColor;
      if (forcePageBreaks || addBreak) {
        div.style.pageBreakAfter = "always";
      }
      if (g && (mxClient.IS_IE || (11 <= document.documentMode || mxClient.IS_EDGE))) {
        doc.writeln(div.outerHTML);
        div.parentNode.removeChild(div);
      } else {
        if (mxClient.IS_IE || (11 <= document.documentMode || mxClient.IS_EDGE)) {
          var clone = doc.createElement("div");
          clone.innerHTML = div.outerHTML;
          clone = clone.getElementsByTagName("div")[0];
          doc.body.appendChild(clone);
          div.parentNode.removeChild(div);
        } else {
          div.parentNode.removeChild(div);
          doc.body.appendChild(div);
        }
      }
      if (forcePageBreaks || addBreak) {
        this.addPageBreak(doc);
      }
    });
    var cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);
    if (null != cov) {
      for (var i = 0;i < cov.length;i++) {
        addPage(cov[i], true);
      }
    }
    var apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);
    for (i = 0;i < vpages;i++) {
      var dy = i * availableHeight / this.scale - this.y0 / this.scale + (bounds.y - tr.y * currentScale) / currentScale;
      for (css = 0;css < hpages;css++) {
        if (null == this.wnd) {
          return null;
        }
        var dx = css * availableWidth / this.scale - this.x0 / this.scale + (bounds.x - tr.x * currentScale) / currentScale;
        var pageNum = i * hpages + css + 1;
        var clip = new mxRectangle(dx, dy, availableWidth, availableHeight);
        div = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, mxUtils.bind(this, function(div) {
          this.addGraphFragment(-dx, -dy, this.scale, pageNum, div, clip);
          if (this.printBackgroundImage) {
            this.insertBackgroundImage(div, -dx, -dy);
          }
        }), pageNum);
        div.setAttribute("id", "mxPage-" + pageNum);
        addPage(div, null != apx || (i < vpages - 1 || css < hpages - 1));
      }
    }
    if (null != apx) {
      for (i = 0;i < apx.length;i++) {
        addPage(apx[i], i < apx.length - 1);
      }
    }
    if (g) {
      if (!keepOpen) {
        this.closeDocument();
        writePageSelector();
      }
    }
    this.wnd.focus();
  } catch (E) {
    if (null != div) {
      if (null != div.parentNode) {
        div.parentNode.removeChild(div);
      }
    }
  } finally {
    this.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;
  }
  return this.wnd;
};
mxPrintPreview.prototype.addPageBreak = function(doc) {
  var hr = doc.createElement("hr");
  hr.className = "mxPageBreak";
  doc.body.appendChild(hr);
};
mxPrintPreview.prototype.closeDocument = function() {
  try {
    if (null != this.wnd && null != this.wnd.document) {
      var doc = this.wnd.document;
      this.writePostfix(doc);
      doc.writeln("</body>");
      doc.writeln("</html>");
      doc.close();
      mxEvent.release(doc.body);
    }
  } catch (b) {
  }
};
mxPrintPreview.prototype.writeHead = function(doc, css) {
  if (null != this.title) {
    doc.writeln("<title>" + this.title + "</title>");
  }
  mxClient.link("stylesheet", mxClient.basePath + "/css/common.css", doc);
  doc.writeln('<style type="text/css">');
  doc.writeln("@media print {");
  doc.writeln("  * { -webkit-print-color-adjust: exact; }");
  doc.writeln("  table.mxPageSelector { display: none; }");
  doc.writeln("  hr.mxPageBreak { display: none; }");
  doc.writeln("}");
  doc.writeln("@media screen {");
  doc.writeln("  table.mxPageSelector { position: fixed; right: 10px; top: 10px;font-family: Arial; font-size:10pt; border: solid 1px darkgray;background: white; border-collapse:collapse; }");
  doc.writeln("  table.mxPageSelector td { border: solid 1px gray; padding:4px; }");
  doc.writeln("  body.mxPage { background: gray; }");
  doc.writeln("}");
  if (null != css) {
    doc.writeln(css);
  }
  doc.writeln("</style>");
};
mxPrintPreview.prototype.writePostfix = function(doc) {
};
mxPrintPreview.prototype.createPageSelector = function(vpages, hpages) {
  var doc = this.wnd.document;
  var table = doc.createElement("table");
  table.className = "mxPageSelector";
  table.setAttribute("border", "0");
  var tbody = doc.createElement("tbody");
  for (var i = 0;i < vpages;i++) {
    var row = doc.createElement("tr");
    for (var j = 0;j < hpages;j++) {
      var pageNum = i * hpages + j + 1;
      var cell = doc.createElement("td");
      var a = doc.createElement("a");
      a.setAttribute("href", "#mxPage-" + pageNum);
      if (!!mxClient.IS_NS) {
        if (!mxClient.IS_SF) {
          if (!mxClient.IS_GC) {
            a.setAttribute("onclick", "var page = document.getElementById('mxPage-" + pageNum + "');page.scrollIntoView(true);event.preventDefault();");
          }
        }
      }
      mxUtils.write(a, pageNum, doc);
      cell.appendChild(a);
      row.appendChild(cell);
    }
    tbody.appendChild(row);
  }
  table.appendChild(tbody);
  return table;
};
mxPrintPreview.prototype.renderPage = function(w, h, dx, dy, content, pageNumber) {
  pageNumber = this.wnd.document;
  var div = document.createElement("div");
  var arg = null;
  try {
    if (0 != dx || 0 != dy) {
      div.style.position = "relative";
      div.style.width = w + "px";
      div.style.height = h + "px";
      div.style.pageBreakInside = "avoid";
      var innerDiv = document.createElement("div");
      innerDiv.style.position = "relative";
      innerDiv.style.top = this.border + "px";
      innerDiv.style.left = this.border + "px";
      innerDiv.style.width = w - 2 * this.border + "px";
      innerDiv.style.height = h - 2 * this.border + "px";
      innerDiv.style.overflow = "hidden";
      var viewport = document.createElement("div");
      viewport.style.position = "relative";
      viewport.style.marginLeft = dx + "px";
      viewport.style.marginTop = dy + "px";
      if (8 == pageNumber.documentMode) {
        innerDiv.style.position = "absolute";
        viewport.style.position = "absolute";
      }
      if (10 == pageNumber.documentMode) {
        viewport.style.width = "100%";
        viewport.style.height = "100%";
      }
      innerDiv.appendChild(viewport);
      div.appendChild(innerDiv);
      document.body.appendChild(div);
      arg = viewport;
    } else {
      div.style.width = w + "px";
      div.style.height = h + "px";
      div.style.overflow = "hidden";
      div.style.pageBreakInside = "avoid";
      if (8 == pageNumber.documentMode) {
        div.style.position = "relative";
      }
      innerDiv = document.createElement("div");
      innerDiv.style.width = w - 2 * this.border + "px";
      innerDiv.style.height = h - 2 * this.border + "px";
      innerDiv.style.overflow = "hidden";
      if (!mxClient.IS_IE || null != pageNumber.documentMode && (5 != pageNumber.documentMode && (8 != pageNumber.documentMode && 7 != pageNumber.documentMode))) {
        innerDiv.style.top = this.border + "px";
        innerDiv.style.left = this.border + "px";
      } else {
        innerDiv.style.marginTop = this.border + "px";
        innerDiv.style.marginLeft = this.border + "px";
      }
      div.appendChild(innerDiv);
      document.body.appendChild(div);
      arg = innerDiv;
    }
  } catch (n) {
    throw div.parentNode.removeChild(div), n;
  }
  content(arg);
  return div;
};
mxPrintPreview.prototype.getRoot = function() {
  var root = this.graph.view.currentRoot;
  if (null == root) {
    root = this.graph.getModel().getRoot();
  }
  return root;
};
mxPrintPreview.prototype.useCssTransforms = function() {
  return!mxClient.NO_FO && !mxClient.IS_SF;
};
mxPrintPreview.prototype.isCellVisible = function(cell) {
  return true;
};
mxPrintPreview.prototype.addGraphFragment = function(s, dy, tmp, pageNumber, div, clip) {
  var view = this.graph.getView();
  pageNumber = this.graph.container;
  this.graph.container = div;
  var canvas = view.getCanvas();
  var backgroundPane = view.getBackgroundPane();
  var drawPane = view.getDrawPane();
  var overlayPane = view.getOverlayPane();
  var realScale = tmp;
  if (this.graph.dialect == mxConstants.DIALECT_SVG) {
    if (view.createSvg(), this.useCssTransforms()) {
      var g = view.getDrawPane().parentNode;
      g.getAttribute("transform");
      g.setAttribute("transformOrigin", "0 0");
      g.setAttribute("transform", "scale(" + tmp + "," + tmp + ")translate(" + s + "," + dy + ")");
      tmp = 1;
      dy = s = 0;
    }
  } else {
    view.createHtml();
  }
  g = view.isEventsEnabled();
  view.setEventsEnabled(false);
  var value = this.graph.isEnabled();
  this.graph.setEnabled(false);
  var translate = view.getTranslate();
  view.translate = new mxPoint(s, dy);
  var redraw = this.graph.cellRenderer.redraw;
  var states = view.states;
  s = view.scale;
  if (this.clipping) {
    var childState = new mxRectangle((clip.x + translate.x) * s, (clip.y + translate.y) * s, clip.width * s / realScale, clip.height * s / realScale);
    var graph = this;
    this.graph.cellRenderer.redraw = function(state, bubble, rendering) {
      if (null != state) {
        var x = states.get(state.cell);
        if (null != x && (x = view.getBoundingBox(x, false), null != x && (0 < x.width && (0 < x.height && !mxUtils.intersects(childState, x)))) || !graph.isCellVisible(state.cell)) {
          return;
        }
      }
      redraw.apply(this, arguments);
    };
  }
  s = null;
  try {
    var tmp2 = [this.getRoot()];
    s = new mxTemporaryCellStates(view, tmp, tmp2, null, mxUtils.bind(this, function(state) {
      return this.getLinkForCellState(state);
    }));
  } finally {
    if (mxClient.IS_IE) {
      view.overlayPane.innerText = "";
      view.canvas.style.overflow = "hidden";
      view.canvas.style.position = "relative";
      view.canvas.style.top = this.marginTop + "px";
      view.canvas.style.width = clip.width + "px";
      view.canvas.style.height = clip.height + "px";
    } else {
      for (tmp = div.firstChild;null != tmp;) {
        tmp2 = tmp.nextSibling;
        dy = tmp.nodeName.toLowerCase();
        if ("svg" == dy) {
          tmp.style.overflow = "hidden";
          tmp.style.position = "relative";
          tmp.style.top = this.marginTop + "px";
          tmp.setAttribute("width", clip.width);
          tmp.setAttribute("height", clip.height);
          tmp.style.width = "";
          tmp.style.height = "";
        } else {
          if ("default" != tmp.style.cursor) {
            if ("div" != dy) {
              tmp.parentNode.removeChild(tmp);
            }
          }
        }
        tmp = tmp2;
      }
    }
    if (this.printBackgroundImage) {
      div = div.getElementsByTagName("svg");
      if (0 < div.length) {
        div[0].style.position = "absolute";
      }
    }
    view.overlayPane.parentNode.removeChild(view.overlayPane);
    this.graph.setEnabled(value);
    this.graph.container = pageNumber;
    this.graph.cellRenderer.redraw = redraw;
    view.canvas = canvas;
    view.backgroundPane = backgroundPane;
    view.drawPane = drawPane;
    view.overlayPane = overlayPane;
    view.translate = translate;
    s.destroy();
    view.setEventsEnabled(g);
  }
};
mxPrintPreview.prototype.getLinkForCellState = function(state) {
  return this.graph.getLinkForCell(state.cell);
};
mxPrintPreview.prototype.insertBackgroundImage = function(div, dx, dy) {
  var bg = this.graph.backgroundImage;
  if (null != bg) {
    var img = document.createElement("img");
    img.style.position = "absolute";
    img.style.marginLeft = Math.round((dx + bg.x) * this.scale) + "px";
    img.style.marginTop = Math.round((dy + bg.y) * this.scale) + "px";
    img.setAttribute("width", Math.round(bg.width * this.scale));
    img.setAttribute("height", Math.round(bg.height * this.scale));
    img.src = bg.src;
    div.insertBefore(img, div.firstChild);
  }
};
mxPrintPreview.prototype.getCoverPages = function() {
  return null;
};
mxPrintPreview.prototype.getAppendices = function() {
  return null;
};
mxPrintPreview.prototype.print = function(css) {
  css = this.open(css);
  if (null != css) {
    css.print();
  }
};
mxPrintPreview.prototype.close = function() {
  if (null != this.wnd) {
    this.wnd.close();
    this.wnd = null;
  }
};
function mxStylesheet() {
  this.styles = {};
  this.putDefaultVertexStyle(this.createDefaultVertexStyle());
  this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
}
mxStylesheet.prototype.createDefaultVertexStyle = function() {
  var style = {};
  style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
  style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
  style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
  style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
  style[mxConstants.STYLE_FILLCOLOR] = "#C3D9FF";
  style[mxConstants.STYLE_STROKECOLOR] = "#6482B9";
  style[mxConstants.STYLE_FONTCOLOR] = "#774400";
  return style;
};
mxStylesheet.prototype.createDefaultEdgeStyle = function() {
  var style = {};
  style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR;
  style[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;
  style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
  style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
  style[mxConstants.STYLE_STROKECOLOR] = "#6482B9";
  style[mxConstants.STYLE_FONTCOLOR] = "#446299";
  return style;
};
mxStylesheet.prototype.putDefaultVertexStyle = function(style) {
  this.putCellStyle("defaultVertex", style);
};
mxStylesheet.prototype.putDefaultEdgeStyle = function(style) {
  this.putCellStyle("defaultEdge", style);
};
mxStylesheet.prototype.getDefaultVertexStyle = function() {
  return this.styles.defaultVertex;
};
mxStylesheet.prototype.getDefaultEdgeStyle = function() {
  return this.styles.defaultEdge;
};
mxStylesheet.prototype.putCellStyle = function(name, style) {
  this.styles[name] = style;
};
mxStylesheet.prototype.getCellStyle = function(cell, style, directed) {
  directed = null != directed ? directed : true;
  if (null != cell && 0 < cell.length) {
    var tok = cell.split(";");
    style = null != style && ";" != cell.charAt(0) ? mxUtils.clone(style) : {};
    for (cell = 0;cell < tok.length;cell++) {
      var value = tok[cell];
      var index = value.indexOf("=");
      if (0 <= index) {
        var key = value.substring(0, index);
        value = value.substring(index + 1);
        if (value == mxConstants.NONE && directed) {
          delete style[key];
        } else {
          if (mxUtils.isNumeric(value)) {
            style[key] = parseFloat(value);
          } else {
            style[key] = value;
          }
        }
      } else {
        if (value = this.styles[value], null != value) {
          for (key in value) {
            style[key] = value[key];
          }
        }
      }
    }
  }
  return style;
};
function mxCellState(view, cell, style) {
  this.view = view;
  this.cell = cell;
  this.style = null != style ? style : {};
  this.origin = new mxPoint;
  this.absoluteOffset = new mxPoint;
}
mxCellState.prototype = new mxRectangle;
mxCellState.prototype.constructor = mxCellState;
mxCellState.prototype.view = null;
mxCellState.prototype.cell = null;
mxCellState.prototype.style = null;
mxCellState.prototype.invalidStyle = false;
mxCellState.prototype.invalid = true;
mxCellState.prototype.origin = null;
mxCellState.prototype.absolutePoints = null;
mxCellState.prototype.absoluteOffset = null;
mxCellState.prototype.visibleSourceState = null;
mxCellState.prototype.visibleTargetState = null;
mxCellState.prototype.terminalDistance = 0;
mxCellState.prototype.length = 0;
mxCellState.prototype.segments = null;
mxCellState.prototype.shape = null;
mxCellState.prototype.text = null;
mxCellState.prototype.unscaledWidth = null;
mxCellState.prototype.unscaledHeight = null;
mxCellState.prototype.getPerimeterBounds = function(border, bounds) {
  border = border || 0;
  bounds = null != bounds ? bounds : new mxRectangle(this.x, this.y, this.width, this.height);
  if (null != this.shape && (null != this.shape.stencil && "fixed" == this.shape.stencil.aspect)) {
    var aspect = this.shape.stencil.computeAspect(this.style, bounds.x, bounds.y, bounds.width, bounds.height);
    bounds.x = aspect.x;
    bounds.y = aspect.y;
    bounds.width = this.shape.stencil.w0 * aspect.width;
    bounds.height = this.shape.stencil.h0 * aspect.height;
  }
  if (0 != border) {
    bounds.grow(border);
  }
  return bounds;
};
mxCellState.prototype.setAbsoluteTerminalPoint = function(point, source) {
  if (source) {
    if (null == this.absolutePoints) {
      this.absolutePoints = [];
    }
    if (0 == this.absolutePoints.length) {
      this.absolutePoints.push(point);
    } else {
      this.absolutePoints[0] = point;
    }
  } else {
    if (null == this.absolutePoints) {
      this.absolutePoints = [];
      this.absolutePoints.push(null);
      this.absolutePoints.push(point);
    } else {
      if (1 == this.absolutePoints.length) {
        this.absolutePoints.push(point);
      } else {
        this.absolutePoints[this.absolutePoints.length - 1] = point;
      }
    }
  }
};
mxCellState.prototype.setCursor = function(cursor) {
  if (null != this.shape) {
    this.shape.setCursor(cursor);
  }
  if (null != this.text) {
    this.text.setCursor(cursor);
  }
};
mxCellState.prototype.isFloatingTerminalPoint = function(source) {
  var tmp = this.getVisibleTerminalState(source);
  if (null == tmp) {
    return false;
  }
  source = this.view.graph.getConnectionConstraint(this, tmp, source);
  return null == source || null == source.point;
};
mxCellState.prototype.getVisibleTerminal = function(source) {
  source = this.getVisibleTerminalState(source);
  return null != source ? source.cell : null;
};
mxCellState.prototype.getVisibleTerminalState = function(source) {
  return source ? this.visibleSourceState : this.visibleTargetState;
};
mxCellState.prototype.setVisibleTerminalState = function(terminalState, source) {
  if (source) {
    this.visibleSourceState = terminalState;
  } else {
    this.visibleTargetState = terminalState;
  }
};
mxCellState.prototype.getCellBounds = function() {
  return this.cellBounds;
};
mxCellState.prototype.getPaintBounds = function() {
  return this.paintBounds;
};
mxCellState.prototype.updateCachedBounds = function() {
  var tr = this.view.translate;
  var s = this.view.scale;
  this.cellBounds = new mxRectangle(this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);
  this.paintBounds = mxRectangle.fromRectangle(this.cellBounds);
  if (null != this.shape) {
    if (this.shape.isPaintBoundsInverted()) {
      this.paintBounds.rotate90();
    }
  }
};
mxCellState.prototype.setState = function(state) {
  this.view = state.view;
  this.cell = state.cell;
  this.style = state.style;
  this.absolutePoints = state.absolutePoints;
  this.origin = state.origin;
  this.absoluteOffset = state.absoluteOffset;
  this.boundingBox = state.boundingBox;
  this.terminalDistance = state.terminalDistance;
  this.segments = state.segments;
  this.length = state.length;
  this.x = state.x;
  this.y = state.y;
  this.width = state.width;
  this.height = state.height;
  this.unscaledWidth = state.unscaledWidth;
  this.unscaledHeight = state.unscaledHeight;
};
mxCellState.prototype.clone = function() {
  var clone = new mxCellState(this.view, this.cell, this.style);
  if (null != this.absolutePoints) {
    clone.absolutePoints = [];
    for (var i = 0;i < this.absolutePoints.length;i++) {
      clone.absolutePoints[i] = this.absolutePoints[i].clone();
    }
  }
  if (null != this.origin) {
    clone.origin = this.origin.clone();
  }
  if (null != this.absoluteOffset) {
    clone.absoluteOffset = this.absoluteOffset.clone();
  }
  if (null != this.boundingBox) {
    clone.boundingBox = this.boundingBox.clone();
  }
  clone.terminalDistance = this.terminalDistance;
  clone.segments = this.segments;
  clone.length = this.length;
  clone.x = this.x;
  clone.y = this.y;
  clone.width = this.width;
  clone.height = this.height;
  clone.unscaledWidth = this.unscaledWidth;
  clone.unscaledHeight = this.unscaledHeight;
  return clone;
};
mxCellState.prototype.destroy = function() {
  this.view.graph.cellRenderer.destroy(this);
};
function mxGraphSelectionModel(graph) {
  this.graph = graph;
  this.cells = [];
}
mxGraphSelectionModel.prototype = new mxEventSource;
mxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;
mxGraphSelectionModel.prototype.doneResource = "none" != mxClient.language ? "done" : "";
mxGraphSelectionModel.prototype.updatingSelectionResource = "none" != mxClient.language ? "updatingSelection" : "";
mxGraphSelectionModel.prototype.graph = null;
mxGraphSelectionModel.prototype.singleSelection = false;
mxGraphSelectionModel.prototype.isSingleSelection = function() {
  return this.singleSelection;
};
mxGraphSelectionModel.prototype.setSingleSelection = function(singleSelection) {
  this.singleSelection = singleSelection;
};
mxGraphSelectionModel.prototype.isSelected = function(cell) {
  return null != cell ? 0 <= mxUtils.indexOf(this.cells, cell) : false;
};
mxGraphSelectionModel.prototype.isEmpty = function() {
  return 0 == this.cells.length;
};
mxGraphSelectionModel.prototype.clear = function() {
  this.changeSelection(null, this.cells);
};
mxGraphSelectionModel.prototype.setCell = function(cell) {
  if (null != cell) {
    this.setCells([cell]);
  }
};
mxGraphSelectionModel.prototype.setCells = function(cells) {
  if (null != cells) {
    if (this.singleSelection) {
      cells = [this.getFirstSelectableCell(cells)];
    }
    var tmp = [];
    for (var i = 0;i < cells.length;i++) {
      if (this.graph.isCellSelectable(cells[i])) {
        tmp.push(cells[i]);
      }
    }
    this.changeSelection(tmp, this.cells);
  }
};
mxGraphSelectionModel.prototype.getFirstSelectableCell = function(cells) {
  if (null != cells) {
    for (var i = 0;i < cells.length;i++) {
      if (this.graph.isCellSelectable(cells[i])) {
        return cells[i];
      }
    }
  }
  return null;
};
mxGraphSelectionModel.prototype.addCell = function(cell) {
  if (null != cell) {
    this.addCells([cell]);
  }
};
mxGraphSelectionModel.prototype.addCells = function(cells) {
  if (null != cells) {
    var remove = null;
    if (this.singleSelection) {
      remove = this.cells;
      cells = [this.getFirstSelectableCell(cells)];
    }
    var tmp = [];
    for (var i = 0;i < cells.length;i++) {
      if (!this.isSelected(cells[i])) {
        if (this.graph.isCellSelectable(cells[i])) {
          tmp.push(cells[i]);
        }
      }
    }
    this.changeSelection(tmp, remove);
  }
};
mxGraphSelectionModel.prototype.removeCell = function(cell) {
  if (null != cell) {
    this.removeCells([cell]);
  }
};
mxGraphSelectionModel.prototype.removeCells = function(cells) {
  if (null != cells) {
    var tmp = [];
    for (var i = 0;i < cells.length;i++) {
      if (this.isSelected(cells[i])) {
        tmp.push(cells[i]);
      }
    }
    this.changeSelection(null, tmp);
  }
};
mxGraphSelectionModel.prototype.changeSelection = function(parent, removed) {
  if (null != parent && (0 < parent.length && null != parent[0]) || null != removed && (0 < removed.length && null != removed[0])) {
    parent = new mxSelectionChange(this, parent, removed);
    parent.execute();
    removed = new mxUndoableEdit(this, false);
    removed.add(parent);
    this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", removed));
  }
};
mxGraphSelectionModel.prototype.cellAdded = function(cell) {
  if (!(null == cell)) {
    if (!this.isSelected(cell)) {
      this.cells.push(cell);
    }
  }
};
mxGraphSelectionModel.prototype.cellRemoved = function(cell) {
  if (null != cell) {
    cell = mxUtils.indexOf(this.cells, cell);
    if (0 <= cell) {
      this.cells.splice(cell, 1);
    }
  }
};
function mxSelectionChange(selectionModel, added, removed) {
  this.selectionModel = selectionModel;
  this.added = null != added ? added.slice() : null;
  this.removed = null != removed ? removed.slice() : null;
}
mxSelectionChange.prototype.execute = function() {
  var t0 = mxLog.enter("mxSelectionChange.execute");
  window.status = mxResources.get(this.selectionModel.updatingSelectionResource) || this.selectionModel.updatingSelectionResource;
  if (null != this.removed) {
    for (var i = 0;i < this.removed.length;i++) {
      this.selectionModel.cellRemoved(this.removed[i]);
    }
  }
  if (null != this.added) {
    for (i = 0;i < this.added.length;i++) {
      this.selectionModel.cellAdded(this.added[i]);
    }
  }
  i = this.added;
  this.added = this.removed;
  this.removed = i;
  window.status = mxResources.get(this.selectionModel.doneResource) || this.selectionModel.doneResource;
  mxLog.leave("mxSelectionChange.execute", t0);
  this.selectionModel.fireEvent(new mxEventObject(mxEvent.CHANGE, "added", this.added, "removed", this.removed));
};
function mxCellEditor(graph) {
  this.graph = graph;
  this.zoomHandler = mxUtils.bind(this, function() {
    if (this.graph.isEditing()) {
      this.resize();
    }
  });
  this.graph.view.addListener(mxEvent.SCALE, this.zoomHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.zoomHandler);
  this.changeHandler = mxUtils.bind(this, function(state) {
    if (null != this.editingCell) {
      state = this.graph.getView().getState(this.editingCell);
      if (null == state) {
        this.stopEditing(true);
      } else {
        this.updateTextAreaStyle(state);
      }
    }
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
}
mxCellEditor.prototype.graph = null;
mxCellEditor.prototype.textarea = null;
mxCellEditor.prototype.editingCell = null;
mxCellEditor.prototype.trigger = null;
mxCellEditor.prototype.modified = false;
mxCellEditor.prototype.autoSize = true;
mxCellEditor.prototype.selectText = true;
mxCellEditor.prototype.emptyLabelText = mxClient.IS_FF ? "<br>" : "";
mxCellEditor.prototype.escapeCancelsEditing = true;
mxCellEditor.prototype.textNode = "";
mxCellEditor.prototype.zIndex = 1;
mxCellEditor.prototype.minResize = new mxRectangle(0, 20);
mxCellEditor.prototype.wordWrapPadding = 0;
mxCellEditor.prototype.blurEnabled = false;
mxCellEditor.prototype.initialValue = null;
mxCellEditor.prototype.align = null;
mxCellEditor.prototype.init = function() {
  this.textarea = document.createElement("div");
  this.textarea.className = "mxCellEditor mxPlainTextEditor";
  this.textarea.contentEditable = true;
  if (mxClient.IS_GC) {
    this.textarea.style.minHeight = "1em";
  }
  this.textarea.style.position = this.isLegacyEditor() ? "absolute" : "relative";
  this.installListeners(this.textarea);
};
mxCellEditor.prototype.applyValue = function(state, value) {
  this.graph.labelChanged(state.cell, value, this.trigger);
};
mxCellEditor.prototype.setAlign = function(align) {
  if (null != this.textarea) {
    this.textarea.style.textAlign = align;
  }
  this.align = align;
  this.resize();
};
mxCellEditor.prototype.getInitialValue = function(result, trigger) {
  result = mxUtils.htmlEntities(this.graph.getEditingValue(result.cell, trigger), false);
  if (8 != document.documentMode) {
    if (9 != document.documentMode) {
      if (10 != document.documentMode) {
        result = mxUtils.replaceTrailingNewlines(result, "<div><br></div>");
      }
    }
  }
  return result.replace(/\n/g, "<br>");
};
mxCellEditor.prototype.getCurrentValue = function(cancel) {
  return mxUtils.extractTextWithWhitespace(this.textarea.childNodes);
};
mxCellEditor.prototype.isCancelEditingKeyEvent = function(evt) {
  return this.escapeCancelsEditing || (mxEvent.isShiftDown(evt) || (mxEvent.isControlDown(evt) || mxEvent.isMetaDown(evt)));
};
mxCellEditor.prototype.installListeners = function(node) {
  mxEvent.addListener(node, "dragstart", mxUtils.bind(this, function(evt) {
    this.graph.stopEditing(false);
    mxEvent.consume(evt);
  }));
  mxEvent.addListener(node, "blur", mxUtils.bind(this, function(evt) {
    if (this.blurEnabled) {
      this.focusLost(evt);
    }
  }));
  mxEvent.addListener(node, "keydown", mxUtils.bind(this, function(evt) {
    if (!mxEvent.isConsumed(evt)) {
      if (this.isStopEditingEvent(evt)) {
        this.graph.stopEditing(false);
        mxEvent.consume(evt);
      } else {
        if (27 == evt.keyCode) {
          this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));
          mxEvent.consume(evt);
        }
      }
    }
  }));
  var funct = mxUtils.bind(this, function(evt) {
    if (null != this.editingCell) {
      if (this.clearOnChange) {
        if (node.innerHTML == this.getEmptyLabelText()) {
          if (!mxClient.IS_FF || 8 != evt.keyCode && 46 != evt.keyCode) {
            this.clearOnChange = false;
            node.innerText = "";
          }
        }
      }
    }
  });
  mxEvent.addListener(node, "keypress", funct);
  mxEvent.addListener(node, "paste", funct);
  funct = mxUtils.bind(this, function(flex) {
    if (null != this.editingCell) {
      if (0 == this.textarea.innerHTML.length || "<br>" == this.textarea.innerHTML) {
        this.textarea.innerHTML = this.getEmptyLabelText();
        this.clearOnChange = 0 < this.textarea.innerHTML.length;
      } else {
        this.clearOnChange = false;
      }
    }
  });
  mxEvent.addListener(node, mxClient.IS_IE11 || mxClient.IS_IE ? "keyup" : "input", funct);
  mxEvent.addListener(node, "cut", funct);
  mxEvent.addListener(node, "paste", funct);
  funct = mxClient.IS_IE11 || mxClient.IS_IE ? "keydown" : "input";
  var resizeHandler = mxUtils.bind(this, function(evt) {
    if (null != this.editingCell) {
      if (this.autoSize) {
        if (!mxEvent.isConsumed(evt)) {
          if (null != this.resizeThread) {
            window.clearTimeout(this.resizeThread);
          }
          this.resizeThread = window.setTimeout(mxUtils.bind(this, function() {
            this.resizeThread = null;
            this.resize();
          }), 0);
        }
      }
    }
  });
  mxEvent.addListener(node, funct, resizeHandler);
  mxEvent.addListener(window, "resize", resizeHandler);
  if (9 <= document.documentMode) {
    mxEvent.addListener(node, "DOMNodeRemoved", resizeHandler);
    mxEvent.addListener(node, "DOMNodeInserted", resizeHandler);
  } else {
    mxEvent.addListener(node, "cut", resizeHandler);
    mxEvent.addListener(node, "paste", resizeHandler);
  }
};
mxCellEditor.prototype.isStopEditingEvent = function(evt) {
  return 113 == evt.keyCode || this.graph.isEnterStopsCellEditing() && (13 == evt.keyCode && (!mxEvent.isControlDown(evt) && !mxEvent.isShiftDown(evt)));
};
mxCellEditor.prototype.isEventSource = function(evt) {
  return mxEvent.getSource(evt) == this.textarea;
};
mxCellEditor.prototype.resize = function() {
  var state = this.graph.getView().getState(this.editingCell);
  if (null == state) {
    this.stopEditing(true);
  } else {
    if (null != this.textarea) {
      var bds = this.graph.getModel().isEdge(state.cell);
      var scale = this.graph.getView().scale;
      var m = null;
      if (this.autoSize && "fill" != state.style[mxConstants.STYLE_OVERFLOW]) {
        var oh = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
        m = null != state.text && null == this.align ? state.text.margin : null;
        if (null == m) {
          m = mxUtils.getAlignmentAsPoint(this.align || mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER), mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE));
        }
        if (bds) {
          if (this.bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0), null != oh) {
            var tmp = (parseFloat(oh) + 2) * scale;
            this.bounds.width = tmp;
            this.bounds.x += m.x * tmp;
          }
        } else {
          bds = mxRectangle.fromRectangle(state);
          var spacing = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
          var vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
          bds = null != state.shape && (spacing == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE) ? state.shape.getLabelBounds(bds) : bds;
          if (null != oh) {
            bds.width = parseFloat(oh) * scale;
          }
          if (!state.view.graph.cellRenderer.legacySpacing || "width" != state.style[mxConstants.STYLE_OVERFLOW] && "block" != state.style[mxConstants.STYLE_OVERFLOW]) {
            spacing = parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING, 2)) * scale;
            var spacingTop = (parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING_TOP, 0)) + mxText.prototype.baseSpacingTop) * scale + spacing;
            var spacingRight = (parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING_RIGHT, 0)) + mxText.prototype.baseSpacingRight) * scale + spacing;
            var spacingBottom = (parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING_BOTTOM, 0)) + mxText.prototype.baseSpacingBottom) * scale + spacing;
            var spacingLeft = (parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_SPACING_LEFT, 0)) + mxText.prototype.baseSpacingLeft) * scale + spacing;
            spacing = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
            vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
            bds = new mxRectangle(bds.x + spacingLeft, bds.y + spacingTop, bds.width - (spacing == mxConstants.ALIGN_CENTER && null == oh ? spacingLeft + spacingRight : 0), bds.height - (vpos == mxConstants.ALIGN_MIDDLE ? spacingTop + spacingBottom : 0));
            if (this.graph.isHtmlLabel(state.cell)) {
              bds.x -= mxSvgCanvas2D.prototype.foreignObjectPadding / 2;
              bds.y -= mxSvgCanvas2D.prototype.foreignObjectPadding / 2;
              bds.width += mxSvgCanvas2D.prototype.foreignObjectPadding;
            }
          }
          this.bounds = new mxRectangle(bds.x + state.absoluteOffset.x, bds.y + state.absoluteOffset.y, bds.width, bds.height);
        }
        if (this.graph.isWrapping(state.cell) && (2 <= this.bounds.width || 2 <= this.bounds.height)) {
          if (this.textarea.style.wordWrap = mxConstants.WORD_WRAP, this.textarea.style.whiteSpace = "normal", this.textarea.innerHTML != this.getEmptyLabelText()) {
            if (tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding, "relative" != this.textarea.style.position) {
              this.textarea.style.width = tmp + "px";
              if (this.textarea.scrollWidth > tmp) {
                this.textarea.style.width = this.textarea.scrollWidth + "px";
              }
            } else {
              if ("block" == state.style[mxConstants.STYLE_OVERFLOW] || "width" == state.style[mxConstants.STYLE_OVERFLOW]) {
                if (-0.5 == m.y || "width" == state.style[mxConstants.STYLE_OVERFLOW]) {
                  this.textarea.style.maxHeight = this.bounds.height + "px";
                }
                this.textarea.style.width = tmp + "px";
              } else {
                this.textarea.style.maxWidth = tmp + "px";
              }
            }
          } else {
            this.textarea.style.maxWidth = tmp + "px";
          }
        } else {
          this.textarea.style.whiteSpace = "nowrap";
          this.textarea.style.width = "";
        }
        if (8 == document.documentMode) {
          this.textarea.style.zoom = "1";
          this.textarea.style.height = "auto";
        }
        if (8 == document.documentMode) {
          state = this.textarea.scrollWidth;
          oh = this.textarea.scrollHeight;
          this.textarea.style.left = Math.max(0, Math.ceil((this.bounds.x - m.x * (this.bounds.width - (state + 1) * scale) + state * (scale - 1) * 0 + 2 * (m.x + 0.5)) / scale)) + "px";
          this.textarea.style.top = Math.max(0, Math.ceil((this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + 1 * Math.abs(m.y + 0.5)) / scale)) + "px";
          this.textarea.style.width = Math.round(state * scale) + "px";
          this.textarea.style.height = Math.round(oh * scale) + "px";
        } else {
          this.textarea.style.left = Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1) + "px";
          this.textarea.style.top = Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (-1 == m.y ? 3 : 0)) + 1) + "px";
        }
      } else {
        this.bounds = this.getEditorBounds(state);
        this.textarea.style.width = Math.round(this.bounds.width / scale) + "px";
        this.textarea.style.height = Math.round(this.bounds.height / scale) + "px";
        if (8 == document.documentMode) {
          this.textarea.style.left = Math.round(this.bounds.x) + "px";
          this.textarea.style.top = Math.round(this.bounds.y) + "px";
        } else {
          this.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + "px";
          this.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + "px";
        }
        if (this.graph.isWrapping(state.cell) && ((2 <= this.bounds.width || 2 <= this.bounds.height) && this.textarea.innerHTML != this.getEmptyLabelText())) {
          this.textarea.style.wordWrap = mxConstants.WORD_WRAP;
          this.textarea.style.whiteSpace = "normal";
          if ("fill" != state.style[mxConstants.STYLE_OVERFLOW]) {
            this.textarea.style.width = Math.round(this.bounds.width / scale) + this.wordWrapPadding + "px";
          }
        } else {
          this.textarea.style.whiteSpace = "nowrap";
          if ("fill" != state.style[mxConstants.STYLE_OVERFLOW]) {
            this.textarea.style.width = "";
          }
        }
      }
      mxUtils.setPrefixedStyle(this.textarea.style, "transformOrigin", "0px 0px");
      mxUtils.setPrefixedStyle(this.textarea.style, "transform", "scale(" + scale + "," + scale + ")" + (null == m ? "" : " translate(" + 100 * m.x + "%," + 100 * m.y + "%)"));
    }
  }
};
mxCellEditor.prototype.focusLost = function() {
  this.stopEditing(!this.graph.isInvokesStopCellEditing());
};
mxCellEditor.prototype.getBackgroundColor = function(state) {
  return null;
};
mxCellEditor.prototype.getBorderColor = function(state) {
  return null;
};
mxCellEditor.prototype.isLegacyEditor = function() {
  var a = false;
  if (mxClient.IS_SVG) {
    var root = this.graph.view.getDrawPane().ownerSVGElement;
    if (null != root) {
      root = mxUtils.getCurrentStyle(root);
      if (null != root) {
        a = "absolute" == root.position;
      }
    }
  }
  return!a;
};
mxCellEditor.prototype.updateTextAreaStyle = function(state) {
  this.graph.getView();
  var size = mxUtils.getValue(state.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);
  var family = mxUtils.getValue(state.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY);
  var color = mxUtils.getValue(state.style, mxConstants.STYLE_FONTCOLOR, "black");
  var align = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);
  var bold = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD;
  var italic = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC;
  var txtDecor = [];
  if ((mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
    txtDecor.push("underline");
  }
  if ((mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
    txtDecor.push("line-through");
  }
  this.textarea.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? Math.round(size * mxConstants.LINE_HEIGHT) + "px" : mxConstants.LINE_HEIGHT;
  this.textarea.style.backgroundColor = this.getBackgroundColor(state);
  this.textarea.style.textDecoration = txtDecor.join(" ");
  this.textarea.style.fontWeight = bold ? "bold" : "normal";
  this.textarea.style.fontStyle = italic ? "italic" : "";
  this.textarea.style.fontSize = Math.round(size) + "px";
  this.textarea.style.zIndex = this.zIndex;
  this.textarea.style.fontFamily = family;
  this.textarea.style.textAlign = align;
  this.textarea.style.outline = "none";
  this.textarea.style.color = color;
  size = this.getBorderColor(state);
  this.textarea.style.border = null != size ? "1px solid " + size : "none";
  size = this.textDirection = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
  if (size == mxConstants.TEXT_DIRECTION_AUTO) {
    if (!(null == state)) {
      if (!(null == state.text)) {
        if (!(state.text.dialect == mxConstants.DIALECT_STRICTHTML)) {
          if (!mxUtils.isNode(state.text.value)) {
            size = state.text.getAutoDirection();
          }
        }
      }
    }
  }
  if (size == mxConstants.TEXT_DIRECTION_LTR || size == mxConstants.TEXT_DIRECTION_RTL) {
    this.textarea.setAttribute("dir", size);
  } else {
    this.textarea.removeAttribute("dir");
  }
};
mxCellEditor.prototype.startEditing = function(cell, trigger) {
  this.stopEditing(true);
  this.align = null;
  if (null == this.textarea) {
    this.init();
  }
  if (null != this.graph.tooltipHandler) {
    this.graph.tooltipHandler.hideTooltip();
  }
  var state = this.graph.getView().getState(cell);
  if (null != state) {
    this.updateTextAreaStyle(state);
    this.textarea.innerHTML = this.getInitialValue(state, trigger) || "";
    this.initialValue = this.textarea.innerHTML;
    if (0 == this.textarea.innerHTML.length || "<br>" == this.textarea.innerHTML) {
      this.textarea.innerHTML = this.getEmptyLabelText();
      this.clearOnChange = true;
    } else {
      this.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText();
    }
    this.graph.container.appendChild(this.textarea);
    this.editingCell = cell;
    this.trigger = trigger;
    this.textNode = null;
    if (null != state.text) {
      if (this.isHideLabel(state)) {
        this.textNode = state.text.node;
        this.textNode.style.visibility = "hidden";
      }
    }
    if (this.autoSize) {
      if (this.graph.model.isEdge(state.cell) || "fill" != state.style[mxConstants.STYLE_OVERFLOW]) {
        window.setTimeout(mxUtils.bind(this, function() {
          this.resize();
        }), 0);
      }
    }
    this.resize();
    try {
      this.textarea.focus();
      if (this.isSelectText()) {
        if (0 < this.textarea.innerHTML.length) {
          if (this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange) {
            document.execCommand("selectAll", false, null);
          }
        }
      }
    } catch (d) {
    }
  }
};
mxCellEditor.prototype.isSelectText = function() {
  return this.selectText;
};
mxCellEditor.prototype.clearSelection = function() {
  var selection = null;
  if (window.getSelection) {
    selection = window.getSelection();
  } else {
    if (document.selection) {
      selection = document.selection;
    }
  }
  if (null != selection) {
    if (selection.empty) {
      selection.empty();
    } else {
      if (selection.removeAllRanges) {
        selection.removeAllRanges();
      }
    }
  }
};
mxCellEditor.prototype.stopEditing = function(cancel) {
  if (null != this.editingCell) {
    if (null != this.textNode) {
      this.textNode.style.visibility = "visible";
      this.textNode = null;
    }
    cancel = cancel ? null : this.graph.view.getState(this.editingCell);
    var value = this.initialValue;
    this.bounds = this.trigger = this.editingCell = this.initialValue = null;
    this.textarea.blur();
    this.clearSelection();
    if (null != this.textarea.parentNode) {
      this.textarea.parentNode.removeChild(this.textarea);
    }
    if (this.clearOnChange) {
      if (this.textarea.innerHTML == this.getEmptyLabelText()) {
        this.textarea.innerText = "";
        this.clearOnChange = false;
      }
    }
    if (null != cancel && (this.textarea.innerHTML != value || null != this.align)) {
      this.prepareTextarea();
      value = this.getCurrentValue(cancel);
      this.graph.getModel().beginUpdate();
      try {
        if (null != value) {
          this.applyValue(cancel, value);
        }
        if (null != this.align) {
          this.graph.setCellStyles(mxConstants.STYLE_ALIGN, this.align, [cancel.cell]);
        }
      } finally {
        this.graph.getModel().endUpdate();
      }
    }
    mxEvent.release(this.textarea);
    this.align = this.textarea = null;
  }
};
mxCellEditor.prototype.prepareTextarea = function() {
  if (null != this.textarea.lastChild) {
    if ("BR" == this.textarea.lastChild.nodeName) {
      this.textarea.removeChild(this.textarea.lastChild);
    }
  }
};
mxCellEditor.prototype.isHideLabel = function(state) {
  return true;
};
mxCellEditor.prototype.getMinimumSize = function(state) {
  var scale = this.graph.getView().scale;
  return new mxRectangle(0, 0, null == state.text ? 30 : state.text.size * scale + 20, "left" == this.textarea.style.textAlign ? 120 : 40);
};
mxCellEditor.prototype.getEditorBounds = function(state) {
  var align = this.graph.getModel().isEdge(state.cell);
  var result = this.graph.getView().scale;
  var tmp = this.getMinimumSize(state);
  var minWidth = tmp.width;
  tmp = tmp.height;
  if (!align && (state.view.graph.cellRenderer.legacySpacing && "fill" == state.style[mxConstants.STYLE_OVERFLOW])) {
    result = state.shape.getLabelBounds(mxRectangle.fromRectangle(state));
  } else {
    var spacingLeft = parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING, 2)) * result;
    var spacingTop = (parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_TOP, 0)) + mxText.prototype.baseSpacingTop) * result + spacingLeft;
    var hpos = (parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_RIGHT, 0)) + mxText.prototype.baseSpacingRight) * result + spacingLeft;
    var vpos = (parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_BOTTOM, 0)) + mxText.prototype.baseSpacingBottom) * result + spacingLeft;
    spacingLeft = (parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_LEFT, 0)) + mxText.prototype.baseSpacingLeft) * result + spacingLeft;
    result = new mxRectangle(state.x, state.y, Math.max(minWidth, state.width - spacingLeft - hpos), Math.max(tmp, state.height - spacingTop - vpos));
    hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    if (this.graph.isHtmlLabel(state.cell)) {
      result.width += mxSvgCanvas2D.prototype.foreignObjectPadding;
    }
    result = null != state.shape && (hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE) ? state.shape.getLabelBounds(result) : result;
    if (align) {
      result.x = state.absoluteOffset.x;
      result.y = state.absoluteOffset.y;
      if (null != state.text) {
        if (null != state.text.boundingBox) {
          if (0 < state.text.boundingBox.x) {
            result.x = state.text.boundingBox.x;
          }
          if (0 < state.text.boundingBox.y) {
            result.y = state.text.boundingBox.y;
          }
        }
      }
    } else {
      if (null != state.text) {
        if (null != state.text.boundingBox) {
          result.x = Math.min(result.x, state.text.boundingBox.x);
          result.y = Math.min(result.y, state.text.boundingBox.y);
        }
      }
    }
    result.x += spacingLeft;
    result.y += spacingTop;
    if (null != state.text) {
      if (null != state.text.boundingBox) {
        if (align) {
          result.width = Math.max(minWidth, state.text.boundingBox.width);
          result.height = Math.max(tmp, state.text.boundingBox.height);
        } else {
          result.width = Math.max(result.width, state.text.boundingBox.width);
          result.height = Math.max(result.height, state.text.boundingBox.height);
        }
      }
    }
    if (this.graph.getModel().isVertex(state.cell)) {
      align = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
      if (align == mxConstants.ALIGN_LEFT) {
        result.x -= state.width;
      } else {
        if (align == mxConstants.ALIGN_RIGHT) {
          result.x += state.width;
        }
      }
      align = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
      if (align == mxConstants.ALIGN_TOP) {
        result.y -= state.height;
      } else {
        if (align == mxConstants.ALIGN_BOTTOM) {
          result.y += state.height;
        }
      }
    }
  }
  return new mxRectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));
};
mxCellEditor.prototype.getEmptyLabelText = function(cell) {
  return this.emptyLabelText;
};
mxCellEditor.prototype.getEditingCell = function() {
  return this.editingCell;
};
mxCellEditor.prototype.destroy = function() {
  if (null != this.textarea) {
    mxEvent.release(this.textarea);
    if (null != this.textarea.parentNode) {
      this.textarea.parentNode.removeChild(this.textarea);
    }
    this.textarea = null;
  }
  if (null != this.changeHandler) {
    this.graph.getModel().removeListener(this.changeHandler);
    this.changeHandler = null;
  }
  if (this.zoomHandler) {
    this.graph.view.removeListener(this.zoomHandler);
    this.zoomHandler = null;
  }
};
function mxCellRenderer() {
}
mxCellRenderer.defaultShapes = {};
mxCellRenderer.prototype.defaultEdgeShape = mxConnector;
mxCellRenderer.prototype.defaultVertexShape = mxRectangleShape;
mxCellRenderer.prototype.defaultTextShape = mxText;
mxCellRenderer.prototype.legacyControlPosition = true;
mxCellRenderer.prototype.legacySpacing = true;
mxCellRenderer.prototype.antiAlias = true;
mxCellRenderer.prototype.minSvgStrokeWidth = 1;
mxCellRenderer.prototype.forceControlClickHandler = false;
mxCellRenderer.registerShape = function(key, shape) {
  mxCellRenderer.defaultShapes[key] = shape;
};
mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);
mxCellRenderer.registerShape(mxConstants.SHAPE_ELLIPSE, mxEllipse);
mxCellRenderer.registerShape(mxConstants.SHAPE_RHOMBUS, mxRhombus);
mxCellRenderer.registerShape(mxConstants.SHAPE_CYLINDER, mxCylinder);
mxCellRenderer.registerShape(mxConstants.SHAPE_CONNECTOR, mxConnector);
mxCellRenderer.registerShape(mxConstants.SHAPE_ACTOR, mxActor);
mxCellRenderer.registerShape(mxConstants.SHAPE_TRIANGLE, mxTriangle);
mxCellRenderer.registerShape(mxConstants.SHAPE_HEXAGON, mxHexagon);
mxCellRenderer.registerShape(mxConstants.SHAPE_CLOUD, mxCloud);
mxCellRenderer.registerShape(mxConstants.SHAPE_LINE, mxLine);
mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW, mxArrow);
mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW_CONNECTOR, mxArrowConnector);
mxCellRenderer.registerShape(mxConstants.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse);
mxCellRenderer.registerShape(mxConstants.SHAPE_SWIMLANE, mxSwimlane);
mxCellRenderer.registerShape(mxConstants.SHAPE_IMAGE, mxImageShape);
mxCellRenderer.registerShape(mxConstants.SHAPE_LABEL, mxLabel);
mxCellRenderer.prototype.initializeShape = function(state) {
  state.shape.dialect = state.view.graph.dialect;
  this.configureShape(state);
  state.shape.init(state.view.getDrawPane());
};
mxCellRenderer.prototype.createShape = function(state) {
  var name = null;
  if (null != state.style) {
    name = state.style[mxConstants.STYLE_SHAPE];
    name = null == mxCellRenderer.defaultShapes[name] ? mxStencilRegistry.getStencil(name) : null;
    name = null != name ? new mxShape(name) : new (this.getShapeConstructor(state));
  }
  return name;
};
mxCellRenderer.prototype.createIndicatorShape = function(state) {
  state.shape.indicatorShape = this.getShape(state.view.graph.getIndicatorShape(state));
};
mxCellRenderer.prototype.getShape = function(name) {
  return null != name ? mxCellRenderer.defaultShapes[name] : null;
};
mxCellRenderer.prototype.getShapeConstructor = function(state) {
  var ctor = this.getShape(state.style[mxConstants.STYLE_SHAPE]);
  if (null == ctor) {
    ctor = state.view.graph.getModel().isEdge(state.cell) ? this.defaultEdgeShape : this.defaultVertexShape;
  }
  return ctor;
};
mxCellRenderer.prototype.configureShape = function(state) {
  state.shape.apply(state);
  state.shape.image = state.view.graph.getImage(state);
  state.shape.indicatorColor = state.view.graph.getIndicatorColor(state);
  state.shape.indicatorStrokeColor = state.style[mxConstants.STYLE_INDICATOR_STROKECOLOR];
  state.shape.indicatorGradientColor = state.view.graph.getIndicatorGradientColor(state);
  state.shape.indicatorDirection = state.style[mxConstants.STYLE_INDICATOR_DIRECTION];
  state.shape.indicatorImage = state.view.graph.getIndicatorImage(state);
  this.postConfigureShape(state);
};
mxCellRenderer.prototype.postConfigureShape = function(state) {
  if (null != state.shape) {
    this.resolveColor(state, "indicatorGradientColor", mxConstants.STYLE_GRADIENTCOLOR);
    this.resolveColor(state, "indicatorColor", mxConstants.STYLE_FILLCOLOR);
    this.resolveColor(state, "gradient", mxConstants.STYLE_GRADIENTCOLOR);
    this.resolveColor(state, "stroke", mxConstants.STYLE_STROKECOLOR);
    this.resolveColor(state, "fill", mxConstants.STYLE_FILLCOLOR);
  }
};
mxCellRenderer.prototype.checkPlaceholderStyles = function(state) {
  if (null != state.style) {
    var values = ["inherit", "swimlane", "indicated"];
    var styles = [mxConstants.STYLE_FILLCOLOR, mxConstants.STYLE_STROKECOLOR, mxConstants.STYLE_GRADIENTCOLOR, mxConstants.STYLE_FONTCOLOR];
    for (var i = 0;i < styles.length;i++) {
      if (0 <= mxUtils.indexOf(values, state.style[styles[i]])) {
        return true;
      }
    }
  }
  return false;
};
mxCellRenderer.prototype.resolveColor = function(state, field, key) {
  var shape = key == mxConstants.STYLE_FONTCOLOR ? state.text : state.shape;
  if (null != shape) {
    var graph = state.view.graph;
    var value = shape[field];
    var cell = null;
    if ("inherit" == value) {
      cell = graph.model.getParent(state.cell);
    } else {
      if ("swimlane" == value) {
        shape[field] = key == mxConstants.STYLE_STROKECOLOR || key == mxConstants.STYLE_FONTCOLOR ? "#000000" : "#ffffff";
        cell = null != graph.model.getTerminal(state.cell, false) ? graph.model.getTerminal(state.cell, false) : state.cell;
        cell = graph.getSwimlane(cell);
        key = graph.swimlaneIndicatorColorAttribute;
      } else {
        if ("indicated" == value && null != state.shape) {
          shape[field] = state.shape.indicatorColor;
        } else {
          if (key != mxConstants.STYLE_FILLCOLOR && (value == mxConstants.STYLE_FILLCOLOR && null != state.shape)) {
            shape[field] = state.style[mxConstants.STYLE_FILLCOLOR];
          } else {
            if (key != mxConstants.STYLE_STROKECOLOR) {
              if (value == mxConstants.STYLE_STROKECOLOR) {
                if (null != state.shape) {
                  shape[field] = state.style[mxConstants.STYLE_STROKECOLOR];
                }
              }
            }
          }
        }
      }
    }
    if (null != cell) {
      state = graph.getView().getState(cell);
      shape[field] = null;
      if (null != state) {
        graph = key == mxConstants.STYLE_FONTCOLOR ? state.text : state.shape;
        shape[field] = null != graph && "indicatorColor" != field ? graph[field] : state.style[key];
      }
    }
  }
};
mxCellRenderer.prototype.getLabelValue = function(state) {
  return state.view.graph.getLabel(state.cell);
};
mxCellRenderer.prototype.createLabel = function(state, value) {
  var graph = state.view.graph;
  graph.getModel().isEdge(state.cell);
  if (0 < state.style[mxConstants.STYLE_FONTSIZE] || null == state.style[mxConstants.STYLE_FONTSIZE]) {
    var isForceHtml = graph.isHtmlLabel(state.cell) || null != value && mxUtils.isNode(value);
    state.text = new this.defaultTextShape(value, new mxRectangle, state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER, graph.getVerticalAlign(state), state.style[mxConstants.STYLE_FONTCOLOR], state.style[mxConstants.STYLE_FONTFAMILY], state.style[mxConstants.STYLE_FONTSIZE], state.style[mxConstants.STYLE_FONTSTYLE], state.style[mxConstants.STYLE_SPACING], state.style[mxConstants.STYLE_SPACING_TOP], state.style[mxConstants.STYLE_SPACING_RIGHT], state.style[mxConstants.STYLE_SPACING_BOTTOM],
    state.style[mxConstants.STYLE_SPACING_LEFT], state.style[mxConstants.STYLE_HORIZONTAL], state.style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR], state.style[mxConstants.STYLE_LABEL_BORDERCOLOR], graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style[mxConstants.STYLE_OVERFLOW], state.style[mxConstants.STYLE_LABEL_PADDING], mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION));
    state.text.opacity = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_OPACITY, 100);
    state.text.dialect = isForceHtml ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;
    state.text.style = state.style;
    state.text.state = state;
    this.initializeLabel(state, state.text);
    this.configureShape(state);
    var forceGetCell = false;
    var getState = function(evt) {
      var gridEnabled = state;
      if (mxClient.IS_TOUCH || forceGetCell) {
        gridEnabled = mxEvent.getClientX(evt);
        evt = mxEvent.getClientY(evt);
        evt = mxUtils.convertPoint(graph.container, gridEnabled, evt);
        gridEnabled = graph.view.getState(graph.getCellAt(evt.x, evt.y));
      }
      return gridEnabled;
    };
    mxEvent.addGestureListeners(state.text.node, mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
        forceGetCell = graph.dialect != mxConstants.DIALECT_SVG && "IMG" == mxEvent.getSource(evt).nodeName;
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isLabelEvent(state, evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));
        forceGetCell = false;
      }
    }));
    if (graph.nativeDblClickEnabled) {
      mxEvent.addListener(state.text.node, "dblclick", mxUtils.bind(this, function(evt) {
        if (this.isLabelEvent(state, evt)) {
          graph.dblClick(evt, state.cell);
          mxEvent.consume(evt);
        }
      }));
    }
  }
};
mxCellRenderer.prototype.initializeLabel = function(state, shape) {
  if (mxClient.IS_SVG && (mxClient.NO_FO && shape.dialect != mxConstants.DIALECT_SVG)) {
    shape.init(state.view.graph.container);
  } else {
    shape.init(state.view.getDrawPane());
  }
};
mxCellRenderer.prototype.createCellOverlays = function(state) {
  var overlays = state.view.graph.getCellOverlays(state.cell);
  var dict = null;
  if (null != overlays) {
    dict = new mxDictionary;
    for (var i = 0;i < overlays.length;i++) {
      var tmp = null != state.overlays ? state.overlays.remove(overlays[i]) : null;
      if (null == tmp) {
        tmp = new mxImageShape(new mxRectangle, overlays[i].image.src);
        tmp.dialect = state.view.graph.dialect;
        tmp.preserveImageAspect = false;
        tmp.overlay = overlays[i];
        this.initializeOverlay(state, tmp);
        this.installCellOverlayListeners(state, overlays[i], tmp);
        if (null != overlays[i].cursor) {
          tmp.node.style.cursor = overlays[i].cursor;
        }
        dict.put(overlays[i], tmp);
      } else {
        dict.put(overlays[i], tmp);
      }
    }
  }
  if (null != state.overlays) {
    state.overlays.visit(function(flex, shape) {
      shape.destroy();
    });
  }
  state.overlays = dict;
};
mxCellRenderer.prototype.initializeOverlay = function(state, overlay) {
  overlay.init(state.view.getOverlayPane());
};
mxCellRenderer.prototype.installCellOverlayListeners = function(state, overlay, shape) {
  var graph = state.view.graph;
  mxEvent.addListener(shape.node, "click", function(evt) {
    if (graph.isEditing()) {
      graph.stopEditing(!graph.isInvokesStopCellEditing());
    }
    overlay.fireEvent(new mxEventObject(mxEvent.CLICK, "event", evt, "cell", state.cell));
  });
  mxEvent.addGestureListeners(shape.node, function(evt) {
    mxEvent.consume(evt);
  }, function(evt) {
    graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));
  });
  if (mxClient.IS_TOUCH) {
    mxEvent.addListener(shape.node, "touchend", function(evt) {
      overlay.fireEvent(new mxEventObject(mxEvent.CLICK, "event", evt, "cell", state.cell));
    });
  }
};
mxCellRenderer.prototype.createControl = function(state) {
  var graph = state.view.graph;
  var image = graph.getFoldingImage(state);
  if (graph.foldingEnabled && null != image) {
    if (null == state.control) {
      var b = new mxRectangle(0, 0, image.width, image.height);
      state.control = new mxImageShape(b, image.src);
      state.control.preserveImageAspect = false;
      state.control.dialect = graph.dialect;
      this.initControl(state, state.control, true, this.createControlClickHandler(state));
    }
  } else {
    if (null != state.control) {
      state.control.destroy();
      state.control = null;
    }
  }
};
mxCellRenderer.prototype.createControlClickHandler = function(state) {
  var graph = state.view.graph;
  return mxUtils.bind(this, function(evt) {
    if (this.forceControlClickHandler || graph.isEnabled()) {
      var collapse = !graph.isCellCollapsed(state.cell);
      graph.foldCells(collapse, false, [state.cell], null, evt);
      mxEvent.consume(evt);
    }
  });
};
mxCellRenderer.prototype.initControl = function(state, node, handleEvents, clickHandler) {
  var graph = state.view.graph;
  if (graph.isHtmlLabel(state.cell) && (mxClient.NO_FO && graph.dialect == mxConstants.DIALECT_SVG)) {
    node.dialect = mxConstants.DIALECT_PREFERHTML;
    node.init(graph.container);
    node.node.style.zIndex = 1;
  } else {
    node.init(state.view.getOverlayPane());
  }
  node = node.innerNode || node.node;
  if (!(null == clickHandler)) {
    if (!mxClient.IS_IOS) {
      if (graph.isEnabled()) {
        node.style.cursor = "pointer";
      }
      mxEvent.addListener(node, "click", clickHandler);
    }
  }
  if (handleEvents) {
    var first = null;
    mxEvent.addGestureListeners(node, function(evt) {
      first = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
      graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
      mxEvent.consume(evt);
    }, function(evt) {
      graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));
    }, function(evt) {
      graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, state));
      mxEvent.consume(evt);
    });
    if (null != clickHandler) {
      if (mxClient.IS_IOS) {
        node.addEventListener("touchend", function(evt) {
          if (null != first) {
            var tol = graph.tolerance;
            if (Math.abs(first.x - mxEvent.getClientX(evt)) < tol) {
              if (Math.abs(first.y - mxEvent.getClientY(evt)) < tol) {
                clickHandler.call(clickHandler, evt);
                mxEvent.consume(evt);
              }
            }
          }
        }, true);
      }
    }
  }
  return node;
};
mxCellRenderer.prototype.isShapeEvent = function(state, evt) {
  return true;
};
mxCellRenderer.prototype.isLabelEvent = function(state, evt) {
  return true;
};
mxCellRenderer.prototype.installListeners = function(state) {
  var graph = state.view.graph;
  var getState = function(evt) {
    var gridEnabled = state;
    if (graph.dialect != mxConstants.DIALECT_SVG && "IMG" == mxEvent.getSource(evt).nodeName || mxClient.IS_TOUCH) {
      gridEnabled = mxEvent.getClientX(evt);
      evt = mxEvent.getClientY(evt);
      evt = mxUtils.convertPoint(graph.container, gridEnabled, evt);
      gridEnabled = graph.view.getState(graph.getCellAt(evt.x, evt.y));
    }
    return gridEnabled;
  };
  mxEvent.addGestureListeners(state.shape.node, mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
    }
  }), mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));
    }
  }), mxUtils.bind(this, function(evt) {
    if (this.isShapeEvent(state, evt)) {
      graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));
    }
  }));
  if (graph.nativeDblClickEnabled) {
    mxEvent.addListener(state.shape.node, "dblclick", mxUtils.bind(this, function(evt) {
      if (this.isShapeEvent(state, evt)) {
        graph.dblClick(evt, state.cell);
        mxEvent.consume(evt);
      }
    }));
  }
};
mxCellRenderer.prototype.redrawLabel = function(state, force) {
  var bounds = state.view.graph;
  var value = this.getLabelValue(state);
  var wrapping = bounds.isWrapping(state.cell);
  var clipping = bounds.isLabelClipped(state.cell);
  var dialect = state.view.graph.isHtmlLabel(state.cell) || null != value && mxUtils.isNode(value) ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;
  var overflow = state.style[mxConstants.STYLE_OVERFLOW] || "visible";
  if (!(null == state.text)) {
    if (!(state.text.wrap == wrapping && (state.text.clipped == clipping && (state.text.overflow == overflow && state.text.dialect == dialect)))) {
      state.text.destroy();
      state.text = null;
    }
  }
  if (null == state.text && (null != value && (mxUtils.isNode(value) || 0 < value.length))) {
    this.createLabel(state, value);
  } else {
    if (!(null == state.text)) {
      if (!(null != value && 0 != value.length)) {
        state.text.destroy();
        state.text = null;
      }
    }
  }
  if (null != state.text) {
    if (force) {
      if (null != state.text.lastValue) {
        if (this.isTextShapeInvalid(state, state.text)) {
          state.text.lastValue = null;
        }
      }
      state.text.resetStyles();
      state.text.apply(state);
      this.configureShape(state);
      state.text.valign = bounds.getVerticalAlign(state);
    }
    bounds = this.getLabelBounds(state);
    var nextScale = this.getTextScale(state);
    this.resolveColor(state, "color", mxConstants.STYLE_FONTCOLOR);
    if (force || (state.text.value != value || (state.text.isWrapping != wrapping || (state.text.overflow != overflow || (state.text.isClipping != clipping || (state.text.scale != nextScale || (state.text.dialect != dialect || (null == state.text.bounds || !state.text.bounds.equals(bounds))))))))) {
      state.text.dialect = dialect;
      state.text.value = value;
      state.text.bounds = bounds;
      state.text.scale = nextScale;
      state.text.wrap = wrapping;
      state.text.clipped = clipping;
      state.text.overflow = overflow;
      force = state.text.node.style.visibility;
      this.redrawLabelShape(state.text);
      state.text.node.style.visibility = force;
    }
  }
};
mxCellRenderer.prototype.isTextShapeInvalid = function(state, shape) {
  function check(property, stylename, defaultValue) {
    return "spacingTop" == stylename || ("spacingRight" == stylename || ("spacingBottom" == stylename || "spacingLeft" == stylename)) ? parseFloat(shape[property]) - parseFloat(shape.spacing) != (state.style[stylename] || defaultValue) : shape[property] != (state.style[stylename] || defaultValue);
  }
  return check("fontStyle", mxConstants.STYLE_FONTSTYLE, mxConstants.DEFAULT_FONTSTYLE) || (check("family", mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY) || (check("size", mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE) || (check("color", mxConstants.STYLE_FONTCOLOR, "black") || (check("align", mxConstants.STYLE_ALIGN, "") || (check("valign", mxConstants.STYLE_VERTICAL_ALIGN, "") || (check("spacing", mxConstants.STYLE_SPACING, 2) || (check("spacingTop", mxConstants.STYLE_SPACING_TOP,
  0) || (check("spacingRight", mxConstants.STYLE_SPACING_RIGHT, 0) || (check("spacingBottom", mxConstants.STYLE_SPACING_BOTTOM, 0) || (check("spacingLeft", mxConstants.STYLE_SPACING_LEFT, 0) || (check("horizontal", mxConstants.STYLE_HORIZONTAL, true) || (check("background", mxConstants.STYLE_LABEL_BACKGROUNDCOLOR) || (check("border", mxConstants.STYLE_LABEL_BORDERCOLOR) || (check("opacity", mxConstants.STYLE_TEXT_OPACITY, 100) || check("textDirection", mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION)))))))))))))));
};
mxCellRenderer.prototype.redrawLabelShape = function(shape) {
  shape.redraw();
};
mxCellRenderer.prototype.getTextScale = function(state) {
  return state.view.scale;
};
mxCellRenderer.prototype.getLabelBounds = function(state) {
  var tmp = state.view.graph;
  var scale = state.view.scale;
  var d = tmp.getModel().isEdge(state.cell);
  var bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y);
  if (d) {
    var spacing = state.text.getSpacing();
    bounds.x += spacing.x * scale;
    bounds.y += spacing.y * scale;
    tmp = tmp.getCellGeometry(state.cell);
    if (null != tmp) {
      bounds.width = Math.max(0, tmp.width * scale);
      bounds.height = Math.max(0, tmp.height * scale);
    }
  } else {
    if (state.text.isPaintBoundsInverted()) {
      tmp = bounds.x;
      bounds.x = bounds.y;
      bounds.y = tmp;
    }
    bounds.x += state.x;
    bounds.y += state.y;
    bounds.width = Math.max(1, state.width);
    bounds.height = Math.max(1, state.height);
  }
  if (state.text.isPaintBoundsInverted()) {
    tmp = (state.width - state.height) / 2;
    bounds.x += tmp;
    bounds.y -= tmp;
    tmp = bounds.width;
    bounds.width = bounds.height;
    bounds.height = tmp;
  }
  if (null != state.shape) {
    tmp = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    spacing = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    if (tmp == mxConstants.ALIGN_CENTER) {
      if (spacing == mxConstants.ALIGN_MIDDLE) {
        bounds = state.shape.getLabelBounds(bounds);
      }
    }
  }
  tmp = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
  if (null != tmp) {
    bounds.width = parseFloat(tmp) * scale;
  }
  if (!d) {
    this.rotateLabelBounds(state, bounds);
  }
  return bounds;
};
mxCellRenderer.prototype.rotateLabelBounds = function(state, bounds) {
  bounds.y -= state.text.margin.y * bounds.height;
  bounds.x -= state.text.margin.x * bounds.width;
  if (!this.legacySpacing || "fill" != state.style[mxConstants.STYLE_OVERFLOW] && ("width" != state.style[mxConstants.STYLE_OVERFLOW] && ("block" != state.style[mxConstants.STYLE_OVERFLOW] || "1" == state.style[mxConstants.STYLE_BLOCK_SPACING]))) {
    var s = state.view.scale;
    var rad = state.text.getSpacing("1" == state.style[mxConstants.STYLE_BLOCK_SPACING]);
    bounds.x += rad.x * s;
    bounds.y += rad.y * s;
    rad = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
    var vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
    var f = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
    bounds.width = Math.max(0, bounds.width - (rad == mxConstants.ALIGN_CENTER && null == f ? state.text.spacingLeft * s + state.text.spacingRight * s : 0));
    bounds.height = Math.max(0, bounds.height - (vpos == mxConstants.ALIGN_MIDDLE ? state.text.spacingTop * s + state.text.spacingBottom * s : 0));
  }
  rad = state.text.getTextRotation();
  if (0 != rad) {
    if (null != state) {
      if (state.view.graph.model.isVertex(state.cell)) {
        if (s = state.getCenterX(), state = state.getCenterY(), bounds.x != s || bounds.y != state) {
          rad *= Math.PI / 180;
          state = mxUtils.getRotatedPoint(new mxPoint(bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new mxPoint(s, state));
          bounds.x = state.x;
          bounds.y = state.y;
        }
      }
    }
  }
};
mxCellRenderer.prototype.redrawCellOverlays = function(state, force) {
  this.createCellOverlays(state);
  if (null != state.overlays) {
    var rotation = mxUtils.mod(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0), 90);
    var rad = mxUtils.toRadians(rotation);
    var cos = Math.cos(rad);
    var sin = Math.sin(rad);
    state.overlays.visit(function(bounds, shape) {
      bounds = shape.overlay.getBounds(state);
      if (!state.view.graph.getModel().isEdge(state.cell) && (null != state.shape && 0 != rotation)) {
        var cx = bounds.getCenterX();
        var cy = bounds.getCenterY();
        cy = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin, new mxPoint(state.getCenterX(), state.getCenterY()));
        cx = cy.x;
        cy = cy.y;
        bounds.x = Math.round(cx - bounds.width / 2);
        bounds.y = Math.round(cy - bounds.height / 2);
      }
      if (force || (null == shape.bounds || (shape.scale != state.view.scale || !shape.bounds.equals(bounds)))) {
        shape.bounds = bounds;
        shape.scale = state.view.scale;
        shape.redraw();
      }
    });
  }
};
mxCellRenderer.prototype.redrawControl = function(state, force) {
  var bounds = state.view.graph.getFoldingImage(state);
  if (null != state.control && null != bounds) {
    bounds = this.getControlBounds(state, bounds.width, bounds.height);
    var r = this.legacyControlPosition ? mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0) : state.shape.getTextRotation();
    var s = state.view.scale;
    if (force || (state.control.scale != s || (!state.control.bounds.equals(bounds) || state.control.rotation != r))) {
      state.control.rotation = r;
      state.control.bounds = bounds;
      state.control.scale = s;
      state.control.redraw();
    }
  }
};
mxCellRenderer.prototype.getControlBounds = function(state, w, h) {
  if (null != state.control) {
    var s = state.view.scale;
    var cx = state.getCenterX();
    var cy = state.getCenterY();
    if (!state.view.graph.getModel().isEdge(state.cell) && (cx = state.x + w * s, cy = state.y + h * s, null != state.shape)) {
      var cos = state.shape.getShapeRotation();
      if (this.legacyControlPosition) {
        cos = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);
      } else {
        if (state.shape.isPaintBoundsInverted()) {
          var rad = (state.width - state.height) / 2;
          cx += rad;
          cy -= rad;
        }
      }
      if (0 != cos) {
        rad = mxUtils.toRadians(cos);
        cos = Math.cos(rad);
        rad = Math.sin(rad);
        cy = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, rad, new mxPoint(state.getCenterX(), state.getCenterY()));
        cx = cy.x;
        cy = cy.y;
      }
    }
    return state.view.graph.getModel().isEdge(state.cell), new mxRectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s));
  }
  return null;
};
mxCellRenderer.prototype.insertStateAfter = function(state, htmlNode, node) {
  var shapes = this.getShapesForState(state);
  for (var i = 0;i < shapes.length;i++) {
    if (null != shapes[i] && null != shapes[i].node) {
      var f = shapes[i].node.parentNode != state.view.getDrawPane() && shapes[i].node.parentNode != state.view.getOverlayPane();
      var canvas = f ? node : htmlNode;
      if (null != canvas && canvas.nextSibling != shapes[i].node) {
        if (null == canvas.nextSibling) {
          canvas.parentNode.appendChild(shapes[i].node);
        } else {
          canvas.parentNode.insertBefore(shapes[i].node, canvas.nextSibling);
        }
      } else {
        if (null == canvas) {
          if (shapes[i].node.parentNode == state.view.graph.container) {
            for (canvas = state.view.canvas;null != canvas && canvas.parentNode != state.view.graph.container;) {
              canvas = canvas.parentNode;
            }
            if (null != canvas && null != canvas.nextSibling) {
              if (canvas.nextSibling != shapes[i].node) {
                shapes[i].node.parentNode.insertBefore(shapes[i].node, canvas.nextSibling);
              }
            } else {
              shapes[i].node.parentNode.appendChild(shapes[i].node);
            }
          } else {
            if (null != shapes[i].node.parentNode) {
              if (null != shapes[i].node.parentNode.firstChild) {
                if (shapes[i].node.parentNode.firstChild != shapes[i].node) {
                  shapes[i].node.parentNode.insertBefore(shapes[i].node, shapes[i].node.parentNode.firstChild);
                }
              }
            }
          }
        }
      }
      if (f) {
        node = shapes[i].node;
      } else {
        htmlNode = shapes[i].node;
      }
    }
  }
  return[htmlNode, node];
};
mxCellRenderer.prototype.getShapesForState = function(state) {
  return[state.shape, state.text, state.control];
};
mxCellRenderer.prototype.redraw = function(state, force, rendering) {
  force = this.redrawShape(state, force, rendering);
  if (!(null == state.shape)) {
    if (!(null != rendering && !rendering)) {
      this.redrawLabel(state, force);
      this.redrawCellOverlays(state, force);
      this.redrawControl(state, force);
    }
  }
};
mxCellRenderer.prototype.redrawShape = function(state, force, rendering) {
  var model = state.view.graph.model;
  var shapeChanged = false;
  if (null != state.shape) {
    if (null != state.shape.style) {
      if (null != state.style) {
        if (state.shape.style[mxConstants.STYLE_SHAPE] != state.style[mxConstants.STYLE_SHAPE]) {
          state.shape.destroy();
          state.shape = null;
        }
      }
    }
  }
  if (null == state.shape && (null != state.view.graph.container && (state.cell != state.view.currentRoot && (model.isVertex(state.cell) || model.isEdge(state.cell))))) {
    state.shape = this.createShape(state);
    if (null != state.shape) {
      state.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
      state.shape.antiAlias = this.antiAlias;
      this.createIndicatorShape(state);
      this.initializeShape(state);
      this.createCellOverlays(state);
      this.installListeners(state);
      state.view.graph.selectionCellsHandler.updateHandler(state);
    }
  } else {
    if (!force) {
      if (!(null == state.shape)) {
        if (!(mxUtils.equalEntries(state.shape.style, state.style) && !this.checkPlaceholderStyles(state))) {
          state.shape.resetStyles();
          this.configureShape(state);
          state.view.graph.selectionCellsHandler.updateHandler(state);
          force = true;
        }
      }
    }
  }
  if (null != state.shape) {
    if (state.shape.indicatorShape != this.getShape(state.view.graph.getIndicatorShape(state))) {
      if (null != state.shape.indicator) {
        state.shape.indicator.destroy();
        state.shape.indicator = null;
      }
      this.createIndicatorShape(state);
      if (null != state.shape.indicatorShape) {
        state.shape.indicator = new state.shape.indicatorShape;
        state.shape.indicator.dialect = state.shape.dialect;
        state.shape.indicator.init(state.node);
        force = true;
      }
    }
  }
  if (null != state.shape) {
    if (this.createControl(state), force || this.isShapeInvalid(state, state.shape)) {
      if (null != state.absolutePoints) {
        state.shape.points = state.absolutePoints.slice();
        state.shape.bounds = null;
      } else {
        state.shape.points = null;
        state.shape.bounds = new mxRectangle(state.x, state.y, state.width, state.height);
      }
      state.shape.scale = state.view.scale;
      if (null == rendering || rendering) {
        this.doRedrawShape(state);
      } else {
        state.shape.updateBoundingBox();
      }
      shapeChanged = true;
    }
  }
  return shapeChanged;
};
mxCellRenderer.prototype.doRedrawShape = function(state) {
  state.shape.redraw();
};
mxCellRenderer.prototype.isShapeInvalid = function(state, shape) {
  return null == shape.bounds || (shape.scale != state.view.scale || (null == state.absolutePoints && !shape.bounds.equals(state) || null != state.absolutePoints && !mxUtils.equalPoints(shape.points, state.absolutePoints)));
};
mxCellRenderer.prototype.destroy = function(state) {
  if (null != state.shape) {
    if (null != state.text) {
      state.text.destroy();
      state.text = null;
    }
    if (null != state.overlays) {
      state.overlays.visit(function(flex, shape) {
        shape.destroy();
      });
      state.overlays = null;
    }
    if (null != state.control) {
      state.control.destroy();
      state.control = null;
    }
    state.shape.destroy();
    state.shape = null;
  }
};
var mxEdgeStyle = {
  EntityRelation : function(state, source, target, bottomChannelY, points) {
    var view = state.view;
    var graph = view.graph;
    bottomChannelY = mxUtils.getValue(state.style, mxConstants.STYLE_SEGMENT, mxConstants.ENTITY_SEGMENT) * view.scale;
    var pts = state.absolutePoints;
    var p0 = pts[0];
    var pe = pts[pts.length - 1];
    pts = false;
    if (null != source) {
      var isTargetLeft = graph.getCellGeometry(source.cell);
      if (isTargetLeft.relative) {
        pts = 0.5 >= isTargetLeft.x;
      } else {
        if (null != target) {
          pts = (null != pe ? pe.x : target.x + target.width) < (null != p0 ? p0.x : source.x);
        }
      }
    }
    if (null != p0) {
      source = new mxCellState;
      source.x = p0.x;
      source.y = p0.y;
    } else {
      if (null != source) {
        var constraint = mxUtils.getPortConstraints(source, state, true, mxConstants.DIRECTION_MASK_NONE);
        if (constraint != mxConstants.DIRECTION_MASK_NONE) {
          if (constraint != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
            pts = constraint == mxConstants.DIRECTION_MASK_WEST;
          }
        }
      } else {
        return;
      }
    }
    isTargetLeft = true;
    if (null != target) {
      graph = graph.getCellGeometry(target.cell);
      if (graph.relative) {
        isTargetLeft = 0.5 >= graph.x;
      } else {
        if (null != source) {
          isTargetLeft = (null != p0 ? p0.x : source.x + source.width) < (null != pe ? pe.x : target.x);
        }
      }
    }
    if (null != pe) {
      target = new mxCellState;
      target.x = pe.x;
      target.y = pe.y;
    } else {
      if (null != target) {
        constraint = mxUtils.getPortConstraints(target, state, false, mxConstants.DIRECTION_MASK_NONE);
        if (constraint != mxConstants.DIRECTION_MASK_NONE) {
          if (constraint != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
            isTargetLeft = constraint == mxConstants.DIRECTION_MASK_WEST;
          }
        }
      }
    }
    if (null != source) {
      if (null != target) {
        state = pts ? source.x : source.x + source.width;
        source = view.getRoutingCenterY(source);
        p0 = isTargetLeft ? target.x : target.x + target.width;
        target = view.getRoutingCenterY(target);
        view = new mxPoint(state + (pts ? -bottomChannelY : bottomChannelY), source);
        graph = new mxPoint(p0 + (isTargetLeft ? -bottomChannelY : bottomChannelY), target);
        if (pts == isTargetLeft) {
          bottomChannelY = pts ? Math.min(state, p0) - bottomChannelY : Math.max(state, p0) + bottomChannelY;
          points.push(new mxPoint(bottomChannelY, source));
          points.push(new mxPoint(bottomChannelY, target));
        } else {
          if (view.x < graph.x == pts) {
            bottomChannelY = source + (target - source) / 2;
            points.push(view);
            points.push(new mxPoint(view.x, bottomChannelY));
            points.push(new mxPoint(graph.x, bottomChannelY));
          } else {
            points.push(view);
          }
          points.push(graph);
        }
      }
    }
  },
  Loop : function(state, source, pt, x, result) {
    pt = state.absolutePoints;
    var view = pt[pt.length - 1];
    if (null != pt[0] && null != view) {
      if (null != x && 0 < x.length) {
        for (source = 0;source < x.length;source++) {
          pt = x[source];
          pt = state.view.transformControlPoint(state, pt);
          result.push(new mxPoint(pt.x, pt.y));
        }
      }
    } else {
      if (null != source) {
        view = state.view;
        var graph = view.graph;
        pt = null != x && 0 < x.length ? x[0] : null;
        if (null != pt) {
          pt = view.transformControlPoint(state, pt);
          if (mxUtils.contains(source, pt.x, pt.y)) {
            pt = null;
          }
        }
        var dx = x = 0;
        var y = 0;
        var dy = 0;
        graph = mxUtils.getValue(state.style, mxConstants.STYLE_SEGMENT, graph.gridSize) * view.scale;
        state = mxUtils.getValue(state.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_WEST);
        if (state == mxConstants.DIRECTION_NORTH || state == mxConstants.DIRECTION_SOUTH) {
          x = view.getRoutingCenterX(source);
          dx = graph;
        } else {
          y = view.getRoutingCenterY(source);
          dy = graph;
        }
        if (null == pt || (pt.x < source.x || pt.x > source.x + source.width)) {
          if (null != pt) {
            x = pt.x;
            dy = Math.max(Math.abs(y - pt.y), dy);
          } else {
            if (state == mxConstants.DIRECTION_NORTH) {
              y = source.y - 2 * dx;
            } else {
              if (state == mxConstants.DIRECTION_SOUTH) {
                y = source.y + source.height + 2 * dx;
              } else {
                x = state == mxConstants.DIRECTION_EAST ? source.x - 2 * dy : source.x + source.width + 2 * dy;
              }
            }
          }
        } else {
          if (null != pt) {
            x = view.getRoutingCenterX(source);
            dx = Math.max(Math.abs(x - pt.x), dy);
            y = pt.y;
            dy = 0;
          }
        }
        result.push(new mxPoint(x - dx, y - dy));
        result.push(new mxPoint(x + dx, y + dy));
      }
    }
  },
  ElbowConnector : function(state, source, target, points, result) {
    var pt = null != points && 0 < points.length ? points[0] : null;
    var vertical = false;
    var top = false;
    if (null != source && null != target) {
      if (null != pt) {
        var left = Math.min(source.x, target.x);
        var right = Math.max(source.x + source.width, target.x + target.width);
        top = Math.min(source.y, target.y);
        var bottom = Math.max(source.y + source.height, target.y + target.height);
        pt = state.view.transformControlPoint(state, pt);
        vertical = pt.y < top || pt.y > bottom;
        top = pt.x < left || pt.x > right;
      } else {
        left = Math.max(source.x, target.x);
        right = Math.min(source.x + source.width, target.x + target.width);
        vertical = left == right;
        if (!vertical) {
          top = Math.max(source.y, target.y);
          bottom = Math.min(source.y + source.height, target.y + target.height);
          top = top == bottom;
        }
      }
    }
    if (top || !vertical && state.style[mxConstants.STYLE_ELBOW] != mxConstants.ELBOW_VERTICAL) {
      mxEdgeStyle.SideToSide(state, source, target, points, result);
    } else {
      mxEdgeStyle.TopToBottom(state, source, target, points, result);
    }
  },
  SideToSide : function(x, source, target, pt, result) {
    var y1 = x.view;
    pt = null != pt && 0 < pt.length ? pt[0] : null;
    var tmp = x.absolutePoints;
    var y = tmp[0];
    tmp = tmp[tmp.length - 1];
    if (null != pt) {
      pt = y1.transformControlPoint(x, pt);
    }
    if (null != y) {
      source = new mxCellState;
      source.x = y.x;
      source.y = y.y;
    }
    if (null != tmp) {
      target = new mxCellState;
      target.x = tmp.x;
      target.y = tmp.y;
    }
    if (null != source) {
      if (null != target) {
        x = Math.max(source.x, target.x);
        y = Math.min(source.x + source.width, target.x + target.width);
        x = null != pt ? pt.x : Math.round(y + (x - y) / 2);
        y = y1.getRoutingCenterY(source);
        y1 = y1.getRoutingCenterY(target);
        if (null != pt) {
          if (pt.y >= source.y) {
            if (pt.y <= source.y + source.height) {
              y = pt.y;
            }
          }
          if (pt.y >= target.y) {
            if (pt.y <= target.y + target.height) {
              y1 = pt.y;
            }
          }
        }
        if (!mxUtils.contains(target, x, y)) {
          if (!mxUtils.contains(source, x, y)) {
            result.push(new mxPoint(x, y));
          }
        }
        if (!mxUtils.contains(target, x, y1)) {
          if (!mxUtils.contains(source, x, y1)) {
            result.push(new mxPoint(x, y1));
          }
        }
        if (1 == result.length) {
          if (null != pt) {
            if (!mxUtils.contains(target, x, pt.y)) {
              if (!mxUtils.contains(source, x, pt.y)) {
                result.push(new mxPoint(x, pt.y));
              }
            }
          } else {
            y1 = Math.max(source.y, target.y);
            result.push(new mxPoint(x, y1 + (Math.min(source.y + source.height, target.y + target.height) - y1) / 2));
          }
        }
      }
    }
  },
  TopToBottom : function(x, source, target, pt, result) {
    var view = x.view;
    pt = null != pt && 0 < pt.length ? pt[0] : null;
    var tmp = x.absolutePoints;
    var y = tmp[0];
    tmp = tmp[tmp.length - 1];
    if (null != pt) {
      pt = view.transformControlPoint(x, pt);
    }
    if (null != y) {
      source = new mxCellState;
      source.x = y.x;
      source.y = y.y;
    }
    if (null != tmp) {
      target = new mxCellState;
      target.x = tmp.x;
      target.y = tmp.y;
    }
    if (null != source) {
      if (null != target) {
        y = Math.max(source.y, target.y);
        tmp = Math.min(source.y + source.height, target.y + target.height);
        x = view.getRoutingCenterX(source);
        if (null != pt) {
          if (pt.x >= source.x) {
            if (pt.x <= source.x + source.width) {
              x = pt.x;
            }
          }
        }
        y = null != pt ? pt.y : Math.round(tmp + (y - tmp) / 2);
        if (!mxUtils.contains(target, x, y)) {
          if (!mxUtils.contains(source, x, y)) {
            result.push(new mxPoint(x, y));
          }
        }
        x = null != pt && (pt.x >= target.x && pt.x <= target.x + target.width) ? pt.x : view.getRoutingCenterX(target);
        if (!mxUtils.contains(target, x, y)) {
          if (!mxUtils.contains(source, x, y)) {
            result.push(new mxPoint(x, y));
          }
        }
        if (1 == result.length) {
          if (null != pt && 1 == result.length) {
            if (!mxUtils.contains(target, pt.x, y)) {
              if (!mxUtils.contains(source, pt.x, y)) {
                result.push(new mxPoint(pt.x, y));
              }
            }
          } else {
            view = Math.max(source.x, target.x);
            result.push(new mxPoint(view + (Math.min(source.x + source.width, target.x + target.width) - view) / 2, y));
          }
        }
      }
    }
  },
  SegmentConnector : function(state, source, result, hint, hints) {
    var pts = mxEdgeStyle.scalePointArray(state.absolutePoints, state.view.scale);
    source = mxEdgeStyle.scaleCellState(source, state.view.scale);
    var target = mxEdgeStyle.scaleCellState(result, state.view.scale);
    result = [];
    var bbox = 0 < hints.length ? hints[0] : null;
    var horizontal = true;
    var pt = pts[0];
    if (null == pt && null != source) {
      pt = new mxPoint(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));
    } else {
      if (null != pt) {
        pt = pt.clone();
      }
    }
    var lastInx = pts.length - 1;
    if (null != hint && 0 < hint.length) {
      var children = [];
      for (var i = 0;i < hint.length;i++) {
        var tmp = state.view.transformControlPoint(state, hint[i], true);
        if (null != tmp) {
          children.push(tmp);
        }
      }
      if (0 == children.length) {
        return;
      }
      if (null != pt) {
        if (null != children[0]) {
          if (1 > Math.abs(children[0].x - pt.x)) {
            children[0].x = pt.x;
          }
          if (1 > Math.abs(children[0].y - pt.y)) {
            children[0].y = pt.y;
          }
        }
      }
      tmp = pts[lastInx];
      if (null != tmp) {
        if (null != children[children.length - 1]) {
          if (1 > Math.abs(children[children.length - 1].x - tmp.x)) {
            children[children.length - 1].x = tmp.x;
          }
          if (1 > Math.abs(children[children.length - 1].y - tmp.y)) {
            children[children.length - 1].y = tmp.y;
          }
        }
      }
      hint = children[0];
      var currentTerm = source;
      var currentPt = pts[0];
      var currentHint = hint;
      if (null != currentPt) {
        currentTerm = null;
      }
      for (i = 0;2 > i;i++) {
        var fixedVertAlign = null != currentPt && currentPt.x == currentHint.x;
        var fixedHozAlign = null != currentPt && currentPt.y == currentHint.y;
        var inHozChan = null != currentTerm && (currentHint.y >= currentTerm.y && currentHint.y <= currentTerm.y + currentTerm.height);
        var inVertChan = null != currentTerm && (currentHint.x >= currentTerm.x && currentHint.x <= currentTerm.x + currentTerm.width);
        currentTerm = fixedHozAlign || null == currentPt && inHozChan;
        currentHint = fixedVertAlign || null == currentPt && inVertChan;
        if (0 != i || !(currentTerm && currentHint || fixedVertAlign && fixedHozAlign)) {
          if (null != currentPt && (!fixedHozAlign && (!fixedVertAlign && (inHozChan || inVertChan)))) {
            horizontal = inHozChan ? false : true;
            break;
          }
          if (currentHint || currentTerm) {
            horizontal = currentTerm;
            if (1 == i) {
              horizontal = 0 == children.length % 2 ? currentTerm : currentHint;
            }
            break;
          }
        }
        currentTerm = target;
        currentPt = pts[lastInx];
        if (null != currentPt) {
          currentTerm = null;
        }
        currentHint = children[children.length - 1];
        if (fixedVertAlign) {
          if (fixedHozAlign) {
            children = children.slice(1);
          }
        }
      }
      if (horizontal && (null != pts[0] && pts[0].y != hint.y || null == pts[0] && (null != source && (hint.y < source.y || hint.y > source.y + source.height)))) {
        result.push(new mxPoint(pt.x, hint.y));
      } else {
        if (!horizontal) {
          if (null != pts[0] && pts[0].x != hint.x || null == pts[0] && (null != source && (hint.x < source.x || hint.x > source.x + source.width))) {
            result.push(new mxPoint(hint.x, pt.y));
          }
        }
      }
      if (horizontal) {
        pt.y = hint.y;
      } else {
        pt.x = hint.x;
      }
      for (i = 0;i < children.length;i++) {
        horizontal = !horizontal;
        hint = children[i];
        if (horizontal) {
          pt.y = hint.y;
        } else {
          pt.x = hint.x;
        }
        result.push(pt.clone());
      }
    } else {
      hint = pt;
      horizontal = true;
    }
    pt = pts[lastInx];
    if (null == pt) {
      if (null != target) {
        pt = new mxPoint(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));
      }
    }
    if (null != pt) {
      if (null != hint) {
        if (horizontal && (null != pts[lastInx] && pts[lastInx].y != hint.y || null == pts[lastInx] && (null != target && (hint.y < target.y || hint.y > target.y + target.height)))) {
          result.push(new mxPoint(pt.x, hint.y));
        } else {
          if (!horizontal) {
            if (null != pts[lastInx] && pts[lastInx].x != hint.x || null == pts[lastInx] && (null != target && (hint.x < target.x || hint.x > target.x + target.width))) {
              result.push(new mxPoint(hint.x, pt.y));
            }
          }
        }
      }
    }
    if (null == pts[0] && null != source) {
      for (;0 < result.length && (null != result[0] && mxUtils.contains(source, result[0].x, result[0].y));) {
        result.splice(0, 1);
      }
    }
    if (null == pts[lastInx] && null != target) {
      for (;0 < result.length && (null != result[result.length - 1] && mxUtils.contains(target, result[result.length - 1].x, result[result.length - 1].y));) {
        result.splice(result.length - 1, 1);
      }
    }
    for (i = 0;i < result.length;i++) {
      if (pts = result[i], pts.x = Math.round(pts.x * state.view.scale * 10) / 10, pts.y = Math.round(pts.y * state.view.scale * 10) / 10, null == bbox || (1 <= Math.abs(bbox.x - pts.x) || Math.abs(bbox.y - pts.y) >= Math.max(1, state.view.scale))) {
        hints.push(pts);
        bbox = pts;
      }
    }
    if (null != tmp) {
      if (null != hints[hints.length - 1]) {
        if (1 >= Math.abs(tmp.x - hints[hints.length - 1].x)) {
          if (1 >= Math.abs(tmp.y - hints[hints.length - 1].y)) {
            hints.splice(hints.length - 1, 1);
            if (null != hints[hints.length - 1]) {
              if (1 > Math.abs(hints[hints.length - 1].x - tmp.x)) {
                hints[hints.length - 1].x = tmp.x;
              }
              if (1 > Math.abs(hints[hints.length - 1].y - tmp.y)) {
                hints[hints.length - 1].y = tmp.y;
              }
            }
          }
        }
      }
    }
  },
  orthBuffer : 10,
  orthPointsFallback : true,
  dirVectors : [[-1, 0], [0, -1], [1, 0], [0, 1], [-1, 0], [0, -1], [1, 0]],
  wayPoints1 : [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  routePatterns : [[[513, 2308, 2081, 2562], [513, 1090, 514, 2184, 2114, 2561], [513, 1090, 514, 2564, 2184, 2562], [513, 2308, 2561, 1090, 514, 2568, 2308]], [[514, 1057, 513, 2308, 2081, 2562], [514, 2184, 2114, 2561], [514, 2184, 2562, 1057, 513, 2564, 2184], [514, 1057, 513, 2568, 2308, 2561]], [[1090, 514, 1057, 513, 2308, 2081, 2562], [2114, 2561], [1090, 2562, 1057, 513, 2564, 2184], [1090, 514, 1057, 513, 2308, 2561, 2568]], [[2081, 2562], [1057, 513, 1090, 514, 2184, 2114, 2561], [1057,
  513, 1090, 514, 2184, 2562, 2564], [1057, 2561, 1090, 514, 2568, 2308]]],
  inlineRoutePatterns : [[null, [2114, 2568], null, null], [null, [514, 2081, 2114, 2568], null, null], [null, [2114, 2561], null, null], [[2081, 2562], [1057, 2114, 2568], [2184, 2562], null]],
  vertexSeperations : [],
  limits : [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]],
  LEFT_MASK : 32,
  TOP_MASK : 64,
  RIGHT_MASK : 128,
  BOTTOM_MASK : 256,
  LEFT : 1,
  TOP : 2,
  RIGHT : 4,
  BOTTOM : 8,
  SIDE_MASK : 480,
  CENTER_MASK : 512,
  SOURCE_MASK : 1024,
  TARGET_MASK : 2048,
  VERTEX_MASK : 3072,
  getJettySize : function(state, isSource) {
    var value = mxUtils.getValue(state.style, isSource ? mxConstants.STYLE_SOURCE_JETTY_SIZE : mxConstants.STYLE_TARGET_JETTY_SIZE, mxUtils.getValue(state.style, mxConstants.STYLE_JETTY_SIZE, mxEdgeStyle.orthBuffer));
    if ("auto" == value) {
      if (mxUtils.getValue(state.style, isSource ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE) {
        state = mxUtils.getNumber(state.style, isSource ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);
        value = Math.max(2, Math.ceil((state + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer;
      } else {
        value = 2 * mxEdgeStyle.orthBuffer;
      }
    }
    return value;
  },
  scalePointArray : function(points, scale) {
    var result = [];
    if (null != points) {
      for (var i = 0;i < points.length;i++) {
        if (null != points[i]) {
          var pt = new mxPoint(Math.round(points[i].x / scale * 10) / 10, Math.round(points[i].y / scale * 10) / 10);
          result[i] = pt;
        } else {
          result[i] = null;
        }
      }
    } else {
      result = null;
    }
    return result;
  },
  scaleCellState : function(result, scale) {
    if (null != result) {
      var state = result.clone();
      state.setRect(Math.round(result.x / scale * 10) / 10, Math.round(result.y / scale * 10) / 10, Math.round(result.width / scale * 10) / 10, Math.round(result.height / scale * 10) / 10);
    } else {
      state = null;
    }
    return state;
  },
  OrthConnector : function(index, newRect, routePattern, controlHints, result) {
    var scaledSourceBuffer = index.view.graph;
    var sourceEdge = null == pState ? false : scaledSourceBuffer.getModel().isEdge(pState.cell);
    var targetEdge = null == state ? false : scaledSourceBuffer.getModel().isEdge(state.cell);
    scaledSourceBuffer = mxEdgeStyle.scalePointArray(index.absolutePoints, index.view.scale);
    var pState = mxEdgeStyle.scaleCellState(newRect, index.view.scale);
    var state = mxEdgeStyle.scaleCellState(routePattern, index.view.scale);
    var tmp = scaledSourceBuffer[0];
    var sourceLeftDist = scaledSourceBuffer[scaledSourceBuffer.length - 1];
    var sourceX = null != pState ? pState.x : tmp.x;
    var sourceBottomDist = null != pState ? pState.y : tmp.y;
    var sourceRightDist = null != pState ? pState.width : 0;
    var targetHeight = null != pState ? pState.height : 0;
    var targetX = null != state ? state.x : sourceLeftDist.x;
    var sourceY = null != state ? state.y : sourceLeftDist.y;
    var sourceWidth = null != state ? state.width : 0;
    var sourceHeight = null != state ? state.height : 0;
    scaledSourceBuffer = mxEdgeStyle.getJettySize(index, true);
    var scaledTargetBuffer = mxEdgeStyle.getJettySize(index, false);
    if (null != pState) {
      if (state == pState) {
        scaledSourceBuffer = scaledTargetBuffer = Math.max(scaledSourceBuffer, scaledTargetBuffer);
      }
    }
    var totalBuffer = scaledTargetBuffer + scaledSourceBuffer;
    var i = false;
    if (null != tmp && null != sourceLeftDist) {
      i = sourceLeftDist.x - tmp.x;
      var dotprod = sourceLeftDist.y - tmp.y;
      i = i * i + dotprod * dotprod < totalBuffer * totalBuffer;
    }
    if (i || (mxEdgeStyle.orthPointsFallback && (null != controlHints && 0 < controlHints.length) || (sourceEdge || targetEdge))) {
      mxEdgeStyle.SegmentConnector(index, newRect, routePattern, controlHints, result);
    } else {
      routePattern = [mxConstants.DIRECTION_MASK_ALL, mxConstants.DIRECTION_MASK_ALL];
      if (null != pState) {
        routePattern[0] = mxUtils.getPortConstraints(pState, index, true, mxConstants.DIRECTION_MASK_ALL);
        newRect = mxUtils.getValue(pState.style, mxConstants.STYLE_ROTATION, 0);
        if (0 != newRect) {
          newRect = mxUtils.getBoundingBox(new mxRectangle(sourceX, sourceBottomDist, sourceRightDist, targetHeight), newRect);
          sourceX = newRect.x;
          sourceBottomDist = newRect.y;
          sourceRightDist = newRect.width;
          targetHeight = newRect.height;
        }
      }
      if (null != state) {
        routePattern[1] = mxUtils.getPortConstraints(state, index, false, mxConstants.DIRECTION_MASK_ALL);
        newRect = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);
        if (0 != newRect) {
          newRect = mxUtils.getBoundingBox(new mxRectangle(targetX, sourceY, sourceWidth, sourceHeight), newRect);
          targetX = newRect.x;
          sourceY = newRect.y;
          sourceWidth = newRect.width;
          sourceHeight = newRect.height;
        }
      }
      newRect = [0, 0];
      sourceX = [[sourceX, sourceBottomDist, sourceRightDist, targetHeight], [targetX, sourceY, sourceWidth, sourceHeight]];
      scaledTargetBuffer = [scaledSourceBuffer, scaledTargetBuffer];
      for (i = 0;2 > i;i++) {
        mxEdgeStyle.limits[i][1] = sourceX[i][0] - scaledTargetBuffer[i];
        mxEdgeStyle.limits[i][2] = sourceX[i][1] - scaledTargetBuffer[i];
        mxEdgeStyle.limits[i][4] = sourceX[i][0] + sourceX[i][2] + scaledTargetBuffer[i];
        mxEdgeStyle.limits[i][8] = sourceX[i][1] + sourceX[i][3] + scaledTargetBuffer[i];
      }
      scaledTargetBuffer = sourceX[0][1] + sourceX[0][3] / 2;
      sourceBottomDist = sourceX[1][1] + sourceX[1][3] / 2;
      i = sourceX[0][0] + sourceX[0][2] / 2 - (sourceX[1][0] + sourceX[1][2] / 2);
      dotprod = scaledTargetBuffer - sourceBottomDist;
      scaledTargetBuffer = 0;
      if (0 > i) {
        scaledTargetBuffer = 0 > dotprod ? 2 : 1;
      } else {
        if (0 >= dotprod) {
          scaledTargetBuffer = 3;
          if (0 == i) {
            scaledTargetBuffer = 2;
          }
        }
      }
      sourceBottomDist = null;
      if (null != pState) {
        sourceBottomDist = tmp;
      }
      pState = [[0.5, 0.5], [0.5, 0.5]];
      for (i = 0;2 > i;i++) {
        if (null != sourceBottomDist) {
          pState[i][0] = (sourceBottomDist.x - sourceX[i][0]) / sourceX[i][2];
          if (1 >= Math.abs(sourceBottomDist.x - sourceX[i][0])) {
            newRect[i] = mxConstants.DIRECTION_MASK_WEST;
          } else {
            if (1 >= Math.abs(sourceBottomDist.x - sourceX[i][0] - sourceX[i][2])) {
              newRect[i] = mxConstants.DIRECTION_MASK_EAST;
            }
          }
          pState[i][1] = (sourceBottomDist.y - sourceX[i][1]) / sourceX[i][3];
          if (1 >= Math.abs(sourceBottomDist.y - sourceX[i][1])) {
            newRect[i] = mxConstants.DIRECTION_MASK_NORTH;
          } else {
            if (1 >= Math.abs(sourceBottomDist.y - sourceX[i][1] - sourceX[i][3])) {
              newRect[i] = mxConstants.DIRECTION_MASK_SOUTH;
            }
          }
        }
        sourceBottomDist = null;
        if (null != state) {
          sourceBottomDist = sourceLeftDist;
        }
      }
      i = sourceX[0][1] - (sourceX[1][1] + sourceX[1][3]);
      sourceLeftDist = sourceX[0][0] - (sourceX[1][0] + sourceX[1][2]);
      sourceBottomDist = sourceX[1][1] - (sourceX[0][1] + sourceX[0][3]);
      sourceRightDist = sourceX[1][0] - (sourceX[0][0] + sourceX[0][2]);
      mxEdgeStyle.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);
      mxEdgeStyle.vertexSeperations[2] = Math.max(i - totalBuffer, 0);
      mxEdgeStyle.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);
      mxEdgeStyle.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);
      totalBuffer = [];
      state = [];
      tmp = [];
      state[0] = sourceLeftDist >= sourceRightDist ? mxConstants.DIRECTION_MASK_WEST : mxConstants.DIRECTION_MASK_EAST;
      tmp[0] = i >= sourceBottomDist ? mxConstants.DIRECTION_MASK_NORTH : mxConstants.DIRECTION_MASK_SOUTH;
      state[1] = mxUtils.reversePortConstraints(state[0]);
      tmp[1] = mxUtils.reversePortConstraints(tmp[0]);
      sourceLeftDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;
      sourceBottomDist = i >= sourceBottomDist ? i : sourceBottomDist;
      sourceRightDist = [[0, 0], [0, 0]];
      targetHeight = false;
      for (i = 0;2 > i;i++) {
        if (0 == newRect[i]) {
          if (0 == (state[i] & routePattern[i])) {
            state[i] = mxUtils.reversePortConstraints(state[i]);
          }
          if (0 == (tmp[i] & routePattern[i])) {
            tmp[i] = mxUtils.reversePortConstraints(tmp[i]);
          }
          sourceRightDist[i][0] = tmp[i];
          sourceRightDist[i][1] = state[i];
        }
      }
      if (0 < sourceBottomDist) {
        if (0 < sourceLeftDist) {
          if (0 < (state[0] & routePattern[0]) && 0 < (tmp[1] & routePattern[1])) {
            sourceRightDist[0][0] = state[0];
            sourceRightDist[0][1] = tmp[0];
            sourceRightDist[1][0] = tmp[1];
            sourceRightDist[1][1] = state[1];
            targetHeight = true;
          } else {
            if (0 < (tmp[0] & routePattern[0])) {
              if (0 < (state[1] & routePattern[1])) {
                sourceRightDist[0][0] = tmp[0];
                sourceRightDist[0][1] = state[0];
                sourceRightDist[1][0] = state[1];
                sourceRightDist[1][1] = tmp[1];
                targetHeight = true;
              }
            }
          }
        }
      }
      if (0 < sourceBottomDist) {
        if (!targetHeight) {
          sourceRightDist[0][0] = tmp[0];
          sourceRightDist[0][1] = state[0];
          sourceRightDist[1][0] = tmp[1];
          sourceRightDist[1][1] = state[1];
          targetHeight = true;
        }
      }
      if (0 < sourceLeftDist) {
        if (!targetHeight) {
          sourceRightDist[0][0] = state[0];
          sourceRightDist[0][1] = tmp[0];
          sourceRightDist[1][0] = state[1];
          sourceRightDist[1][1] = tmp[1];
        }
      }
      for (i = 0;2 > i;i++) {
        if (0 == newRect[i]) {
          if (0 == (sourceRightDist[i][0] & routePattern[i]) && (sourceRightDist[i][0] = sourceRightDist[i][1]), totalBuffer[i] = sourceRightDist[i][0] & routePattern[i], totalBuffer[i] |= (sourceRightDist[i][1] & routePattern[i]) << 8, totalBuffer[i] |= (sourceRightDist[1 - i][i] & routePattern[i]) << 16, totalBuffer[i] |= (sourceRightDist[1 - i][1 - i] & routePattern[i]) << 24, 0 == (totalBuffer[i] & 15) && (totalBuffer[i] <<= 8), 0 == (totalBuffer[i] & 3840) && (totalBuffer[i] = totalBuffer[i] &
          15 | totalBuffer[i] >> 8), 0 == (totalBuffer[i] & 983040) && (totalBuffer[i] = totalBuffer[i] & 65535 | (totalBuffer[i] & 251658240) >> 8), newRect[i] = totalBuffer[i] & 15, routePattern[i] == mxConstants.DIRECTION_MASK_WEST || (routePattern[i] == mxConstants.DIRECTION_MASK_NORTH || (routePattern[i] == mxConstants.DIRECTION_MASK_EAST || routePattern[i] == mxConstants.DIRECTION_MASK_SOUTH))) {
            newRect[i] = routePattern[i];
          }
        }
      }
      routePattern = newRect[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : newRect[0];
      totalBuffer = newRect[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : newRect[1];
      routePattern -= scaledTargetBuffer;
      totalBuffer -= scaledTargetBuffer;
      if (1 > routePattern) {
        routePattern += 4;
      }
      if (1 > totalBuffer) {
        totalBuffer += 4;
      }
      routePattern = mxEdgeStyle.routePatterns[routePattern - 1][totalBuffer - 1];
      mxEdgeStyle.wayPoints1[0][0] = sourceX[0][0];
      mxEdgeStyle.wayPoints1[0][1] = sourceX[0][1];
      switch(newRect[0]) {
        case mxConstants.DIRECTION_MASK_WEST:
          mxEdgeStyle.wayPoints1[0][0] -= scaledSourceBuffer;
          mxEdgeStyle.wayPoints1[0][1] += pState[0][1] * sourceX[0][3];
          break;
        case mxConstants.DIRECTION_MASK_SOUTH:
          mxEdgeStyle.wayPoints1[0][0] += pState[0][0] * sourceX[0][2];
          mxEdgeStyle.wayPoints1[0][1] += sourceX[0][3] + scaledSourceBuffer;
          break;
        case mxConstants.DIRECTION_MASK_EAST:
          mxEdgeStyle.wayPoints1[0][0] += sourceX[0][2] + scaledSourceBuffer;
          mxEdgeStyle.wayPoints1[0][1] += pState[0][1] * sourceX[0][3];
          break;
        case mxConstants.DIRECTION_MASK_NORTH:
          mxEdgeStyle.wayPoints1[0][0] += pState[0][0] * sourceX[0][2];
          mxEdgeStyle.wayPoints1[0][1] -= scaledSourceBuffer;
      }
      scaledSourceBuffer = 0;
      state = totalBuffer = 0 < (newRect[0] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 : 1;
      for (i = 0;i < routePattern.length;i++) {
        tmp = routePattern[i] & 15;
        targetHeight = tmp == mxConstants.DIRECTION_MASK_EAST ? 3 : tmp;
        targetHeight += scaledTargetBuffer;
        if (4 < targetHeight) {
          targetHeight -= 4;
        }
        sourceLeftDist = mxEdgeStyle.dirVectors[targetHeight - 1];
        tmp = 0 < targetHeight % 2 ? 0 : 1;
        if (tmp != totalBuffer) {
          scaledSourceBuffer++;
          mxEdgeStyle.wayPoints1[scaledSourceBuffer][0] = mxEdgeStyle.wayPoints1[scaledSourceBuffer - 1][0];
          mxEdgeStyle.wayPoints1[scaledSourceBuffer][1] = mxEdgeStyle.wayPoints1[scaledSourceBuffer - 1][1];
        }
        targetX = 0 < (routePattern[i] & mxEdgeStyle.TARGET_MASK);
        sourceY = 0 < (routePattern[i] & mxEdgeStyle.SOURCE_MASK);
        sourceBottomDist = (routePattern[i] & mxEdgeStyle.SIDE_MASK) >> 5;
        sourceBottomDist <<= scaledTargetBuffer;
        if (15 < sourceBottomDist) {
          sourceBottomDist >>= 4;
        }
        sourceRightDist = 0 < (routePattern[i] & mxEdgeStyle.CENTER_MASK);
        if ((sourceY || targetX) && 9 > sourceBottomDist) {
          targetHeight = sourceY ? 0 : 1;
          sourceBottomDist = sourceRightDist && 0 == tmp ? sourceX[targetHeight][0] + pState[targetHeight][0] * sourceX[targetHeight][2] : sourceRightDist ? sourceX[targetHeight][1] + pState[targetHeight][1] * sourceX[targetHeight][3] : mxEdgeStyle.limits[targetHeight][sourceBottomDist];
          if (0 == tmp) {
            sourceBottomDist = (sourceBottomDist - mxEdgeStyle.wayPoints1[scaledSourceBuffer][0]) * sourceLeftDist[0];
            if (0 < sourceBottomDist) {
              mxEdgeStyle.wayPoints1[scaledSourceBuffer][0] += sourceLeftDist[0] * sourceBottomDist;
            }
          } else {
            sourceBottomDist = (sourceBottomDist - mxEdgeStyle.wayPoints1[scaledSourceBuffer][1]) * sourceLeftDist[1];
            if (0 < sourceBottomDist) {
              mxEdgeStyle.wayPoints1[scaledSourceBuffer][1] += sourceLeftDist[1] * sourceBottomDist;
            }
          }
        } else {
          if (sourceRightDist) {
            mxEdgeStyle.wayPoints1[scaledSourceBuffer][0] += sourceLeftDist[0] * Math.abs(mxEdgeStyle.vertexSeperations[targetHeight] / 2);
            mxEdgeStyle.wayPoints1[scaledSourceBuffer][1] += sourceLeftDist[1] * Math.abs(mxEdgeStyle.vertexSeperations[targetHeight] / 2);
          }
        }
        if (0 < scaledSourceBuffer && mxEdgeStyle.wayPoints1[scaledSourceBuffer][tmp] == mxEdgeStyle.wayPoints1[scaledSourceBuffer - 1][tmp]) {
          scaledSourceBuffer--;
        } else {
          totalBuffer = tmp;
        }
      }
      for (i = 0;i <= scaledSourceBuffer && (i != scaledSourceBuffer || ((0 < (newRect[1] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 : 1) == state ? 0 : 1) == (scaledSourceBuffer + 1) % 2);i++) {
        result.push(new mxPoint(Math.round(mxEdgeStyle.wayPoints1[i][0] * index.view.scale * 10) / 10, Math.round(mxEdgeStyle.wayPoints1[i][1] * index.view.scale * 10) / 10));
      }
      for (index = 1;index < result.length;) {
        if (null == result[index - 1] || (null == result[index] || (result[index - 1].x != result[index].x || result[index - 1].y != result[index].y))) {
          index++;
        } else {
          result.splice(index, 1);
        }
      }
    }
  },
  getRoutePattern : function(dir, dx, dy, quad) {
    var sourceIndex = dir[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : dir[0];
    dir = dir[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : dir[1];
    sourceIndex -= dx;
    dir -= dx;
    if (1 > sourceIndex) {
      sourceIndex += 4;
    }
    if (1 > dir) {
      dir += 4;
    }
    dx = routePatterns[sourceIndex - 1][dir - 1];
    if (!(0 != dy && 0 != quad)) {
      if (!(null == inlineRoutePatterns[sourceIndex - 1][dir - 1])) {
        dx = inlineRoutePatterns[sourceIndex - 1][dir - 1];
      }
    }
    return dx;
  }
};
var mxStyleRegistry = {
  values : [],
  putValue : function(name, obj) {
    mxStyleRegistry.values[name] = obj;
  },
  getValue : function(cell) {
    return mxStyleRegistry.values[cell];
  },
  getName : function(value) {
    for (var key in mxStyleRegistry.values) {
      if (mxStyleRegistry.values[key] == value) {
        return key;
      }
    }
    return null;
  }
};
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_LOOP, mxEdgeStyle.Loop);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector);
mxStyleRegistry.putValue(mxConstants.PERIMETER_ELLIPSE, mxPerimeter.EllipsePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_RECTANGLE, mxPerimeter.RectanglePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_RHOMBUS, mxPerimeter.RhombusPerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_TRIANGLE, mxPerimeter.TrianglePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_HEXAGON, mxPerimeter.HexagonPerimeter);
function mxGraphView(graph) {
  this.graph = graph;
  this.translate = new mxPoint;
  this.graphBounds = new mxRectangle;
  this.states = new mxDictionary;
}
mxGraphView.prototype = new mxEventSource;
mxGraphView.prototype.constructor = mxGraphView;
mxGraphView.prototype.EMPTY_POINT = new mxPoint;
mxGraphView.prototype.doneResource = "none" != mxClient.language ? "done" : "";
mxGraphView.prototype.updatingDocumentResource = "none" != mxClient.language ? "updatingDocument" : "";
mxGraphView.prototype.allowEval = false;
mxGraphView.prototype.captureDocumentGesture = true;
mxGraphView.prototype.rendering = true;
mxGraphView.prototype.graph = null;
mxGraphView.prototype.currentRoot = null;
mxGraphView.prototype.graphBounds = null;
mxGraphView.prototype.scale = 1;
mxGraphView.prototype.translate = null;
mxGraphView.prototype.states = null;
mxGraphView.prototype.updateStyle = false;
mxGraphView.prototype.lastNode = null;
mxGraphView.prototype.lastHtmlNode = null;
mxGraphView.prototype.lastForegroundNode = null;
mxGraphView.prototype.lastForegroundHtmlNode = null;
mxGraphView.prototype.getGraphBounds = function() {
  return this.graphBounds;
};
mxGraphView.prototype.setGraphBounds = function(value) {
  this.graphBounds = value;
};
mxGraphView.prototype.getBounds = function(cells) {
  var result = null;
  if (null != cells && 0 < cells.length) {
    var model = this.graph.getModel();
    for (var i = 0;i < cells.length;i++) {
      if (model.isVertex(cells[i]) || model.isEdge(cells[i])) {
        var parent = this.getState(cells[i]);
        if (null != parent) {
          if (null == result) {
            result = mxRectangle.fromRectangle(parent);
          } else {
            result.add(parent);
          }
        }
      }
    }
  }
  return result;
};
mxGraphView.prototype.setCurrentRoot = function(graph) {
  if (this.currentRoot != graph) {
    var parent = new mxCurrentRootChange(this, graph);
    parent.execute();
    var edit = new mxUndoableEdit(this, true);
    edit.add(parent);
    this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", edit));
    this.graph.sizeDidChange();
  }
  return graph;
};
mxGraphView.prototype.scaleAndTranslate = function(scale, dx, dy) {
  var previousScale = this.scale;
  var previousTranslate = new mxPoint(this.translate.x, this.translate.y);
  if (this.scale != scale || (this.translate.x != dx || this.translate.y != dy)) {
    this.scale = scale;
    this.translate.x = dx;
    this.translate.y = dy;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.SCALE_AND_TRANSLATE, "scale", scale, "previousScale", previousScale, "translate", this.translate, "previousTranslate", previousTranslate));
};
mxGraphView.prototype.getScale = function() {
  return this.scale;
};
mxGraphView.prototype.setScale = function(scale) {
  var previousScale = this.scale;
  if (this.scale != scale) {
    this.scale = scale;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.SCALE, "scale", scale, "previousScale", previousScale));
};
mxGraphView.prototype.getTranslate = function() {
  return this.translate;
};
mxGraphView.prototype.setTranslate = function(dx, dy) {
  var previousTranslate = new mxPoint(this.translate.x, this.translate.y);
  if (this.translate.x != dx || this.translate.y != dy) {
    this.translate.x = dx;
    this.translate.y = dy;
    if (this.isEventsEnabled()) {
      this.viewStateChanged();
    }
  }
  this.fireEvent(new mxEventObject(mxEvent.TRANSLATE, "translate", this.translate, "previousTranslate", previousTranslate));
};
mxGraphView.prototype.viewStateChanged = function() {
  this.revalidate();
  this.graph.sizeDidChange();
};
mxGraphView.prototype.refresh = function() {
  if (null != this.currentRoot) {
    this.clear();
  }
  this.revalidate();
};
mxGraphView.prototype.revalidate = function() {
  this.invalidate();
  this.validate();
};
mxGraphView.prototype.clear = function(cell, force, recurse) {
  var model = this.graph.getModel();
  cell = cell || model.getRoot();
  force = null != force ? force : false;
  recurse = null != recurse ? recurse : true;
  this.removeState(cell);
  if (recurse && (force || cell != this.currentRoot)) {
    recurse = model.getChildCount(cell);
    for (var i = 0;i < recurse;i++) {
      this.clear(model.getChildAt(cell, i), force);
    }
  } else {
    this.invalidate(cell);
  }
};
mxGraphView.prototype.invalidate = function(cell, recurse, isConnect) {
  var model = this.graph.getModel();
  cell = cell || model.getRoot();
  recurse = null != recurse ? recurse : true;
  isConnect = null != isConnect ? isConnect : true;
  var i = this.getState(cell);
  if (null != i) {
    i.invalid = true;
  }
  if (!cell.invalidating) {
    cell.invalidating = true;
    if (recurse) {
      var childCount = model.getChildCount(cell);
      for (i = 0;i < childCount;i++) {
        var child = model.getChildAt(cell, i);
        this.invalidate(child, recurse, isConnect);
      }
    }
    if (isConnect) {
      childCount = model.getEdgeCount(cell);
      for (i = 0;i < childCount;i++) {
        this.invalidate(model.getEdgeAt(cell, i), recurse, isConnect);
      }
    }
    delete cell.invalidating;
  }
};
mxGraphView.prototype.validate = function(cell) {
  var t0 = mxLog.enter("mxGraphView.validate");
  window.status = mxResources.get(this.updatingDocumentResource) || this.updatingDocumentResource;
  this.resetValidationState();
  var maxDisplay = null;
  if (!(null == this.canvas)) {
    if (!(null != this.textDiv)) {
      if (!(8 != document.documentMode)) {
        if (!mxClient.IS_EM) {
          this.placeholder = document.createElement("div");
          this.placeholder.style.position = "absolute";
          this.placeholder.style.width = this.canvas.clientWidth + "px";
          this.placeholder.style.height = this.canvas.clientHeight + "px";
          this.canvas.parentNode.appendChild(this.placeholder);
          maxDisplay = this.drawPane.style.display;
          this.canvas.style.display = "none";
          this.textDiv = document.createElement("div");
          this.textDiv.style.position = "absolute";
          this.textDiv.style.whiteSpace = "nowrap";
          this.textDiv.style.visibility = "hidden";
          this.textDiv.style.display = "inline-block";
          this.textDiv.style.zoom = "1";
          document.body.appendChild(this.textDiv);
        }
      }
    }
  }
  cell = this.getBoundingBox(this.validateCellState(this.validateCell(cell || (null != this.currentRoot ? this.currentRoot : this.graph.getModel().getRoot()))));
  this.setGraphBounds(null != cell ? cell : this.getEmptyBounds());
  this.validateBackground();
  if (null != maxDisplay) {
    this.canvas.style.display = maxDisplay;
    this.textDiv.parentNode.removeChild(this.textDiv);
    if (null != this.placeholder) {
      this.placeholder.parentNode.removeChild(this.placeholder);
    }
    this.textDiv = null;
  }
  this.resetValidationState();
  window.status = mxResources.get(this.doneResource) || this.doneResource;
  mxLog.leave("mxGraphView.validate", t0);
};
mxGraphView.prototype.getEmptyBounds = function() {
  return new mxRectangle(this.translate.x * this.scale, this.translate.y * this.scale);
};
mxGraphView.prototype.getBoundingBox = function(state, model) {
  model = null != model ? model : true;
  var bbox = null;
  if (null != state && (null != state.shape && (null != state.shape.boundingBox && (bbox = state.shape.boundingBox.clone())), null != state.text && (null != state.text.boundingBox && (null != bbox ? bbox.add(state.text.boundingBox) : bbox = state.text.boundingBox.clone())), model)) {
    model = this.graph.getModel();
    var childCount = model.getChildCount(state.cell);
    for (var i = 0;i < childCount;i++) {
      var parent = this.getBoundingBox(this.getState(model.getChildAt(state.cell, i)));
      if (null != parent) {
        if (null == bbox) {
          bbox = parent;
        } else {
          bbox.add(parent);
        }
      }
    }
  }
  return bbox;
};
mxGraphView.prototype.createBackgroundPageShape = function(bounds) {
  return new mxRectangleShape(bounds, "white", "black");
};
mxGraphView.prototype.validateBackground = function() {
  this.validateBackgroundImage();
  this.validateBackgroundPage();
};
mxGraphView.prototype.validateBackgroundImage = function() {
  var bg = this.graph.getBackgroundImage();
  if (null != bg) {
    if (null == this.backgroundImage || this.backgroundImage.image != bg.src) {
      if (null != this.backgroundImage) {
        this.backgroundImage.destroy();
      }
      var bounds = new mxRectangle(0, 0, 1, 1);
      this.backgroundImage = new mxImageShape(bounds, bg.src);
      this.backgroundImage.dialect = this.graph.dialect;
      this.backgroundImage.init(this.backgroundPane);
      this.backgroundImage.redraw();
      if (!(8 != document.documentMode)) {
        if (!mxClient.IS_EM) {
          mxEvent.addGestureListeners(this.backgroundImage.node, mxUtils.bind(this, function(evt) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
          }), mxUtils.bind(this, function(evt) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
          }), mxUtils.bind(this, function(evt) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
          }));
        }
      }
    }
    this.redrawBackgroundImage(this.backgroundImage, bg);
  } else {
    if (null != this.backgroundImage) {
      this.backgroundImage.destroy();
      this.backgroundImage = null;
    }
  }
};
mxGraphView.prototype.validateBackgroundPage = function() {
  if (this.graph.pageVisible) {
    var bounds = this.getBackgroundPageBounds();
    if (null == this.backgroundPageShape) {
      this.backgroundPageShape = this.createBackgroundPageShape(bounds);
      this.backgroundPageShape.scale = this.scale;
      this.backgroundPageShape.isShadow = true;
      this.backgroundPageShape.dialect = this.graph.dialect;
      this.backgroundPageShape.init(this.backgroundPane);
      this.backgroundPageShape.redraw();
      if (this.graph.nativeDblClickEnabled) {
        mxEvent.addListener(this.backgroundPageShape.node, "dblclick", mxUtils.bind(this, function(evt) {
          this.graph.dblClick(evt);
        }));
      }
      mxEvent.addGestureListeners(this.backgroundPageShape.node, mxUtils.bind(this, function(evt) {
        this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
      }), mxUtils.bind(this, function(evt) {
        if (null != this.graph.tooltipHandler) {
          if (this.graph.tooltipHandler.isHideOnHover()) {
            this.graph.tooltipHandler.hide();
          }
        }
        if (this.graph.isMouseDown) {
          if (!mxEvent.isConsumed(evt)) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
          }
        }
      }), mxUtils.bind(this, function(evt) {
        this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
      }));
    } else {
      this.backgroundPageShape.scale = this.scale;
      this.backgroundPageShape.bounds = bounds;
      this.backgroundPageShape.redraw();
    }
  } else {
    if (null != this.backgroundPageShape) {
      this.backgroundPageShape.destroy();
      this.backgroundPageShape = null;
    }
  }
};
mxGraphView.prototype.getBackgroundPageBounds = function() {
  var fmt = this.graph.pageFormat;
  var ps = this.scale * this.graph.pageScale;
  return new mxRectangle(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);
};
mxGraphView.prototype.redrawBackgroundImage = function(backgroundImage, bg) {
  backgroundImage.scale = this.scale;
  backgroundImage.bounds.x = this.scale * (this.translate.x + bg.x);
  backgroundImage.bounds.y = this.scale * (this.translate.y + bg.y);
  backgroundImage.bounds.width = this.scale * bg.width;
  backgroundImage.bounds.height = this.scale * bg.height;
  backgroundImage.redraw();
};
mxGraphView.prototype.validateCell = function(cell, visible) {
  if (null != cell) {
    if (visible = (null != visible ? visible : true) && this.graph.isCellVisible(cell), null == this.getState(cell, visible) || visible) {
      var model = this.graph.getModel();
      var childCount = model.getChildCount(cell);
      for (var i = 0;i < childCount;i++) {
        this.validateCell(model.getChildAt(cell, i), visible && (!this.isCellCollapsed(cell) || cell == this.currentRoot));
      }
    } else {
      this.removeState(cell);
    }
  }
  return cell;
};
mxGraphView.prototype.validateCellState = function(cell, recurse) {
  recurse = null != recurse ? recurse : true;
  var state = null;
  if (null != cell && (state = this.getState(cell), null != state)) {
    var model = this.graph.getModel();
    if (state.invalid) {
      state.invalid = false;
      if (null == state.style || state.invalidStyle) {
        state.style = this.graph.getCellStyle(state.cell);
        state.invalidStyle = false;
      }
      if (cell != this.currentRoot) {
        this.validateCellState(model.getParent(cell), false);
      }
      state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);
      state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);
      this.updateCellState(state);
      if (!(cell == this.currentRoot)) {
        if (!state.invalid) {
          this.graph.cellRenderer.redraw(state, false, this.isRendering());
          state.updateCachedBounds();
        }
      }
    }
    if (recurse && !state.invalid) {
      if (null != state.shape) {
        this.stateValidated(state);
      }
      recurse = model.getChildCount(cell);
      for (var i = 0;i < recurse;i++) {
        this.validateCellState(model.getChildAt(cell, i));
      }
    }
  }
  return state;
};
mxGraphView.prototype.updateCellState = function(state) {
  state.absoluteOffset.x = 0;
  state.absoluteOffset.y = 0;
  state.origin.x = 0;
  state.origin.y = 0;
  state.length = 0;
  if (state.cell != this.currentRoot) {
    var model = this.graph.getModel();
    var pState = this.getState(model.getParent(state.cell));
    if (null != pState) {
      if (pState.cell != this.currentRoot) {
        state.origin.x += pState.origin.x;
        state.origin.y += pState.origin.y;
      }
    }
    var offset = this.graph.getChildOffsetForCell(state.cell);
    if (null != offset) {
      state.origin.x += offset.x;
      state.origin.y += offset.y;
    }
    var geo = this.graph.getCellGeometry(state.cell);
    if (null != geo) {
      if (!model.isEdge(state.cell)) {
        offset = null != geo.offset ? geo.offset : this.EMPTY_POINT;
        if (geo.relative && null != pState) {
          if (model.isEdge(pState.cell)) {
            offset = this.getPoint(pState, geo);
            if (null != offset) {
              state.origin.x += offset.x / this.scale - pState.origin.x - this.translate.x;
              state.origin.y += offset.y / this.scale - pState.origin.y - this.translate.y;
            }
          } else {
            state.origin.x += geo.x * pState.unscaledWidth + offset.x;
            state.origin.y += geo.y * pState.unscaledHeight + offset.y;
          }
        } else {
          state.absoluteOffset.x = this.scale * offset.x;
          state.absoluteOffset.y = this.scale * offset.y;
          state.origin.x += geo.x;
          state.origin.y += geo.y;
        }
      }
      state.x = this.scale * (this.translate.x + state.origin.x);
      state.y = this.scale * (this.translate.y + state.origin.y);
      state.width = this.scale * geo.width;
      state.unscaledWidth = geo.width;
      state.height = this.scale * geo.height;
      state.unscaledHeight = geo.height;
      if (model.isVertex(state.cell)) {
        this.updateVertexState(state, geo);
      }
      if (model.isEdge(state.cell)) {
        this.updateEdgeState(state, geo);
      }
    }
  }
  state.updateCachedBounds();
};
mxGraphView.prototype.isCellCollapsed = function(cell) {
  return this.graph.isCellCollapsed(cell);
};
mxGraphView.prototype.updateVertexState = function(state, cos) {
  var rad = this.graph.getModel();
  var pState = this.getState(rad.getParent(state.cell));
  if (cos.relative && (null != pState && (!rad.isEdge(pState.cell) && (rad = mxUtils.toRadians(pState.style[mxConstants.STYLE_ROTATION] || "0"), 0 != rad)))) {
    cos = Math.cos(rad);
    rad = Math.sin(rad);
    var ct = new mxPoint(state.getCenterX(), state.getCenterY());
    pState = new mxPoint(pState.getCenterX(), pState.getCenterY());
    pState = mxUtils.getRotatedPoint(ct, cos, rad, pState);
    state.x = pState.x - state.width / 2;
    state.y = pState.y - state.height / 2;
  }
  this.updateVertexLabelOffset(state);
};
mxGraphView.prototype.updateEdgeState = function(state, geo) {
  var source = state.getVisibleTerminalState(true);
  var target = state.getVisibleTerminalState(false);
  if (null != this.graph.model.getTerminal(state.cell, true) && null == source || (null == source && null == geo.getTerminalPoint(true) || (null != this.graph.model.getTerminal(state.cell, false) && null == target || null == target && null == geo.getTerminalPoint(false)))) {
    this.clear(state.cell, true);
  } else {
    this.updateFixedTerminalPoints(state, source, target);
    this.updatePoints(state, geo.points, source, target);
    this.updateFloatingTerminalPoints(state, source, target);
    geo = state.absolutePoints;
    if (state.cell != this.currentRoot && (null == geo || (2 > geo.length || (null == geo[0] || null == geo[geo.length - 1])))) {
      this.clear(state.cell, true);
    } else {
      this.updateEdgeBounds(state);
      this.updateEdgeLabelOffset(state);
    }
  }
};
mxGraphView.prototype.updateVertexLabelOffset = function(state) {
  var align = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
  if (align == mxConstants.ALIGN_LEFT) {
    align = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
    align = null != align ? align * this.scale : state.width;
    state.absoluteOffset.x -= align;
  } else {
    if (align == mxConstants.ALIGN_RIGHT) {
      state.absoluteOffset.x += state.width;
    } else {
      if (align == mxConstants.ALIGN_CENTER && (align = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null), null != align)) {
        var hpos = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER);
        var dx = 0;
        if (hpos == mxConstants.ALIGN_CENTER) {
          dx = 0.5;
        } else {
          if (hpos == mxConstants.ALIGN_RIGHT) {
            dx = 1;
          }
        }
        if (0 != dx) {
          state.absoluteOffset.x -= (align * this.scale - state.width) * dx;
        }
      }
    }
  }
  align = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
  if (align == mxConstants.ALIGN_TOP) {
    state.absoluteOffset.y -= state.height;
  } else {
    if (align == mxConstants.ALIGN_BOTTOM) {
      state.absoluteOffset.y += state.height;
    }
  }
};
mxGraphView.prototype.resetValidationState = function() {
  this.lastForegroundHtmlNode = this.lastForegroundNode = this.lastHtmlNode = this.lastNode = null;
};
mxGraphView.prototype.stateValidated = function(state) {
  var fg = this.graph.getModel().isEdge(state.cell) && this.graph.keepEdgesInForeground || this.graph.getModel().isVertex(state.cell) && this.graph.keepEdgesInBackground;
  state = this.graph.cellRenderer.insertStateAfter(state, fg ? this.lastForegroundNode || this.lastNode : this.lastNode, fg ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode);
  if (fg) {
    this.lastForegroundHtmlNode = state[1];
    this.lastForegroundNode = state[0];
  } else {
    this.lastHtmlNode = state[1];
    this.lastNode = state[0];
  }
};
mxGraphView.prototype.updateFixedTerminalPoints = function(edge, source, target) {
  this.updateFixedTerminalPoint(edge, source, true, this.graph.getConnectionConstraint(edge, source, true));
  this.updateFixedTerminalPoint(edge, target, false, this.graph.getConnectionConstraint(edge, target, false));
};
mxGraphView.prototype.updateFixedTerminalPoint = function(edge, terminal, source, constraint) {
  edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);
};
mxGraphView.prototype.getFixedTerminalPoint = function(edge, terminal, source, constraint) {
  var pt = null;
  if (null != constraint) {
    pt = this.graph.getConnectionPoint(terminal, constraint, false);
  }
  if (null == pt && null == terminal) {
    terminal = this.scale;
    constraint = this.translate;
    var orig = edge.origin;
    pt = this.graph.getCellGeometry(edge.cell).getTerminalPoint(source);
    if (null != pt) {
      pt = new mxPoint(terminal * (constraint.x + pt.x + orig.x), terminal * (constraint.y + pt.y + orig.y));
    }
  }
  return pt;
};
mxGraphView.prototype.updateBoundsFromStencil = function(state) {
  var previous = null;
  if (null != state && (null != state.shape && (null != state.shape.stencil && "fixed" == state.shape.stencil.aspect))) {
    previous = mxRectangle.fromRectangle(state);
    var asp = state.shape.stencil.computeAspect(state.style, state.x, state.y, state.width, state.height);
    state.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);
  }
  return previous;
};
mxGraphView.prototype.updatePoints = function(edge, points, source, target) {
  if (null != edge) {
    var pts = [];
    pts.push(edge.absolutePoints[0]);
    var edgeStyle = this.getEdgeStyle(edge, points, source, target);
    if (null != edgeStyle) {
      source = this.getTerminalPort(edge, source, true);
      target = this.getTerminalPort(edge, target, false);
      var trgBounds = this.updateBoundsFromStencil(source);
      var srcBounds = this.updateBoundsFromStencil(target);
      edgeStyle(edge, source, target, points, pts);
      if (null != trgBounds) {
        source.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);
      }
      if (null != srcBounds) {
        target.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);
      }
    } else {
      if (null != points) {
        for (edgeStyle = 0;edgeStyle < points.length;edgeStyle++) {
          if (null != points[edgeStyle]) {
            source = mxUtils.clone(points[edgeStyle]);
            pts.push(this.transformControlPoint(edge, source));
          }
        }
      }
    }
    points = edge.absolutePoints;
    pts.push(points[points.length - 1]);
    edge.absolutePoints = pts;
  }
};
mxGraphView.prototype.transformControlPoint = function(state, pt, scale) {
  return null != state && null != pt ? (state = state.origin, scale = scale ? 1 : this.scale, new mxPoint(scale * (pt.x + this.translate.x + state.x), scale * (pt.y + this.translate.y + state.y))) : null;
};
mxGraphView.prototype.isLoopStyleEnabled = function(edge, points, source, target) {
  var sc = this.graph.getConnectionConstraint(edge, source, true);
  var tc = this.graph.getConnectionConstraint(edge, target, false);
  return!(null == points || 2 > points.length) || mxUtils.getValue(edge.style, mxConstants.STYLE_ORTHOGONAL_LOOP, false) && (null != sc && null != sc.point || null != tc && null != tc.point) ? false : null != source && source == target;
};
mxGraphView.prototype.getEdgeStyle = function(edge, points, source, target) {
  edge = this.isLoopStyleEnabled(edge, points, source, target) ? mxUtils.getValue(edge.style, mxConstants.STYLE_LOOP, this.graph.defaultLoopStyle) : mxUtils.getValue(edge.style, mxConstants.STYLE_NOEDGESTYLE, false) ? null : edge.style[mxConstants.STYLE_EDGE];
  if ("string" == typeof edge) {
    points = mxStyleRegistry.getValue(edge);
    if (null == points) {
      if (this.isAllowEval()) {
        points = mxUtils.eval(edge);
      }
    }
    edge = points;
  }
  return "function" == typeof edge ? edge : null;
};
mxGraphView.prototype.updateFloatingTerminalPoints = function(state, source, target) {
  var pts = state.absolutePoints;
  var p0 = pts[0];
  if (null == pts[pts.length - 1]) {
    if (null != target) {
      this.updateFloatingTerminalPoint(state, target, source, false);
    }
  }
  if (null == p0) {
    if (null != source) {
      this.updateFloatingTerminalPoint(state, source, target, true);
    }
  }
};
mxGraphView.prototype.updateFloatingTerminalPoint = function(edge, start, end, source) {
  edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);
};
mxGraphView.prototype.getFloatingTerminalPoint = function(edge, start, alpha, source) {
  start = this.getTerminalPort(edge, start, source);
  var next = this.getNextPoint(edge, alpha, source);
  var orth = this.graph.isOrthogonal(edge);
  alpha = mxUtils.toRadians(Number(start.style[mxConstants.STYLE_ROTATION] || "0"));
  var c = new mxPoint(start.getCenterX(), start.getCenterY());
  if (0 != alpha) {
    var cos = Math.cos(-alpha);
    var sin = Math.sin(-alpha);
    next = mxUtils.getRotatedPoint(next, cos, sin, c);
  }
  cos = parseFloat(edge.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
  cos += parseFloat(edge.style[source ? mxConstants.STYLE_SOURCE_PERIMETER_SPACING : mxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0);
  edge = this.getPerimeterPoint(start, next, 0 == alpha && orth, cos);
  if (0 != alpha) {
    cos = Math.cos(alpha);
    sin = Math.sin(alpha);
    edge = mxUtils.getRotatedPoint(edge, cos, sin, c);
  }
  return edge;
};
mxGraphView.prototype.getTerminalPort = function(state, terminal, source) {
  state = mxUtils.getValue(state.style, source ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT);
  if (null != state) {
    state = this.getState(this.graph.getModel().getCell(state));
    if (null != state) {
      terminal = state;
    }
  }
  return terminal;
};
mxGraphView.prototype.getPerimeterPoint = function(terminal, next, orthogonal, bounds) {
  var point = null;
  if (null != terminal) {
    var perimeter = this.getPerimeterFunction(terminal);
    if (null != perimeter && (null != next && (bounds = this.getPerimeterBounds(terminal, bounds), 0 < bounds.width || 0 < bounds.height))) {
      point = new mxPoint(next.x, next.y);
      var flipV = next = false;
      if (this.graph.model.isVertex(terminal.cell)) {
        next = 1 == mxUtils.getValue(terminal.style, mxConstants.STYLE_FLIPH, 0);
        flipV = 1 == mxUtils.getValue(terminal.style, mxConstants.STYLE_FLIPV, 0);
        if (null != terminal.shape) {
          if (null != terminal.shape.stencil) {
            next = 1 == mxUtils.getValue(terminal.style, "stencilFlipH", 0) || next;
            flipV = 1 == mxUtils.getValue(terminal.style, "stencilFlipV", 0) || flipV;
          }
        }
        if (next) {
          point.x = 2 * bounds.getCenterX() - point.x;
        }
        if (flipV) {
          point.y = 2 * bounds.getCenterY() - point.y;
        }
      }
      point = perimeter(bounds, terminal, point, orthogonal);
      if (null != point) {
        if (next) {
          point.x = 2 * bounds.getCenterX() - point.x;
        }
        if (flipV) {
          point.y = 2 * bounds.getCenterY() - point.y;
        }
      }
    }
    if (null == point) {
      point = this.getPoint(terminal);
    }
  }
  return point;
};
mxGraphView.prototype.getRoutingCenterX = function(cell) {
  var f = null != cell.style ? parseFloat(cell.style[mxConstants.STYLE_ROUTING_CENTER_X]) || 0 : 0;
  return cell.getCenterX() + f * cell.width;
};
mxGraphView.prototype.getRoutingCenterY = function(cell) {
  var f = null != cell.style ? parseFloat(cell.style[mxConstants.STYLE_ROUTING_CENTER_Y]) || 0 : 0;
  return cell.getCenterY() + f * cell.height;
};
mxGraphView.prototype.getPerimeterBounds = function(terminal, border) {
  border = null != border ? border : 0;
  if (null != terminal) {
    border += parseFloat(terminal.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
  }
  return terminal.getPerimeterBounds(border * this.scale);
};
mxGraphView.prototype.getPerimeterFunction = function(cell) {
  cell = cell.style[mxConstants.STYLE_PERIMETER];
  if ("string" == typeof cell) {
    var parent = mxStyleRegistry.getValue(cell);
    if (null == parent) {
      if (this.isAllowEval()) {
        parent = mxUtils.eval(cell);
      }
    }
    cell = parent;
  }
  return "function" == typeof cell ? cell : null;
};
mxGraphView.prototype.getNextPoint = function(edge, opposite, source) {
  edge = edge.absolutePoints;
  var count = null;
  if (null != edge) {
    if (2 <= edge.length) {
      count = edge.length;
      count = edge[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];
    }
  }
  if (null == count) {
    if (null != opposite) {
      count = new mxPoint(opposite.getCenterX(), opposite.getCenterY());
    }
  }
  return count;
};
mxGraphView.prototype.getVisibleTerminal = function(cell, source) {
  var model = this.graph.getModel();
  for (source = cell = model.getTerminal(cell, source);null != cell && cell != this.currentRoot;) {
    if (!this.graph.isCellVisible(source) || this.isCellCollapsed(cell)) {
      source = cell;
    }
    cell = model.getParent(cell);
  }
  if (!(null == source)) {
    if (!(model.contains(source) && (model.getParent(source) != model.getRoot() && source != this.currentRoot))) {
      source = null;
    }
  }
  return source;
};
mxGraphView.prototype.updateEdgeBounds = function(state) {
  var points = state.absolutePoints;
  var p0 = points[0];
  var pe = points[points.length - 1];
  if (p0.x != pe.x || p0.y != pe.y) {
    var segment = pe.x - p0.x;
    var pt = pe.y - p0.y;
    state.terminalDistance = Math.sqrt(segment * segment + pt * pt);
  } else {
    state.terminalDistance = 0;
  }
  pe = 0;
  var segments = [];
  pt = p0;
  if (null != pt) {
    p0 = pt.x;
    var minY = pt.y;
    var maxX = p0;
    var maxY = minY;
    for (var i = 1;i < points.length;i++) {
      var tmp = points[i];
      if (null != tmp) {
        segment = pt.x - tmp.x;
        pt = pt.y - tmp.y;
        segment = Math.sqrt(segment * segment + pt * pt);
        segments.push(segment);
        pe += segment;
        pt = tmp;
        p0 = Math.min(pt.x, p0);
        minY = Math.min(pt.y, minY);
        maxX = Math.max(pt.x, maxX);
        maxY = Math.max(pt.y, maxY);
      }
    }
    state.length = pe;
    state.segments = segments;
    state.x = p0;
    state.y = minY;
    state.width = Math.max(1, maxX - p0);
    state.height = Math.max(1, maxY - minY);
  }
};
mxGraphView.prototype.getPoint = function(state, geometry) {
  var x = state.getCenterX();
  var y = state.getCenterY();
  if (null == state.segments || null != geometry && !geometry.relative) {
    if (null != geometry) {
      geometry = geometry.offset;
      if (null != geometry) {
        x += geometry.x;
        y += geometry.y;
      }
    }
  } else {
    var pointCount = state.absolutePoints.length;
    var tmp = Math.round(((null != geometry ? geometry.x / 2 : 0) + 0.5) * state.length);
    var segment = state.segments[0];
    var length = 0;
    for (var index = 1;tmp >= Math.round(length + segment) && index < pointCount - 1;) {
      length += segment;
      segment = state.segments[index++];
    }
    pointCount = 0 == segment ? 0 : (tmp - length) / segment;
    tmp = state.absolutePoints[index - 1];
    state = state.absolutePoints[index];
    if (null != tmp) {
      if (null != state) {
        index = x = y = 0;
        if (null != geometry) {
          y = geometry.y;
          geometry = geometry.offset;
          if (null != geometry) {
            x = geometry.x;
            index = geometry.y;
          }
        }
        geometry = state.x - tmp.x;
        state = state.y - tmp.y;
        x = tmp.x + geometry * pointCount + ((0 == segment ? 0 : state / segment) * y + x) * this.scale;
        y = tmp.y + state * pointCount - ((0 == segment ? 0 : geometry / segment) * y - index) * this.scale;
      }
    }
  }
  return new mxPoint(x, y);
};
mxGraphView.prototype.getRelativePoint = function(edgeState, x, y) {
  var geo = this.graph.getModel().getGeometry(edgeState.cell);
  if (null != geo) {
    var yDistance = edgeState.absolutePoints.length;
    if (geo.relative && 1 < yDistance) {
      geo = edgeState.length;
      var segments = edgeState.segments;
      var p0 = edgeState.absolutePoints[0];
      var pe = edgeState.absolutePoints[1];
      var cx = mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
      var value = 0;
      var index = 0;
      var tmp = 0;
      for (var i = 2;i < yDistance;i++) {
        p0 = pe;
        pe = edgeState.absolutePoints[i];
        p0 = mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
        tmp += segments[i - 2];
        if (p0 <= cx) {
          cx = p0;
          index = i - 1;
          value = tmp;
        }
      }
      yDistance = segments[index];
      p0 = edgeState.absolutePoints[index];
      pe = edgeState.absolutePoints[index + 1];
      cx = pe.x;
      segments = pe.y;
      edgeState = p0.x - cx;
      index = p0.y - segments;
      cx = edgeState - (x - cx);
      segments = index - (y - segments);
      segments = cx * edgeState + segments * index;
      edgeState = Math.sqrt(0 >= segments ? 0 : segments * segments / (edgeState * edgeState + index * index));
      if (edgeState > yDistance) {
        edgeState = yDistance;
      }
      yDistance = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));
      if (-1 == mxUtils.relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y)) {
        yDistance = -yDistance;
      }
      return new mxPoint((geo / 2 - value - edgeState) / geo * -2, yDistance / this.scale);
    }
  }
  return new mxPoint;
};
mxGraphView.prototype.updateEdgeLabelOffset = function(state) {
  var pts = state.absolutePoints;
  state.absoluteOffset.x = state.getCenterX();
  state.absoluteOffset.y = state.getCenterY();
  if (null != pts && (0 < pts.length && null != state.segments)) {
    var geometry = this.graph.getCellGeometry(state.cell);
    if (geometry.relative) {
      var p0 = this.getPoint(state, geometry);
      if (null != p0) {
        state.absoluteOffset = p0;
      }
    } else {
      p0 = pts[0];
      var pe = pts[pts.length - 1];
      if (null != p0 && null != pe) {
        pts = pe.x - p0.x;
        var dy = pe.y - p0.y;
        var y0 = pe = 0;
        geometry = geometry.offset;
        if (null != geometry) {
          pe = geometry.x;
          y0 = geometry.y;
        }
        geometry = p0.y + dy / 2 + y0 * this.scale;
        state.absoluteOffset.x = p0.x + pts / 2 + pe * this.scale;
        state.absoluteOffset.y = geometry;
      }
    }
  }
};
mxGraphView.prototype.getState = function(cell, visible) {
  visible = visible || false;
  var state = null;
  if (null != cell) {
    state = this.states.get(cell);
    if (visible) {
      if (null == state || this.updateStyle) {
        if (this.graph.isCellVisible(cell)) {
          if (null == state) {
            state = this.createState(cell);
            this.states.put(cell, state);
          } else {
            state.style = this.graph.getCellStyle(cell);
          }
        }
      }
    }
  }
  return state;
};
mxGraphView.prototype.isRendering = function() {
  return this.rendering;
};
mxGraphView.prototype.setRendering = function(value) {
  this.rendering = value;
};
mxGraphView.prototype.isAllowEval = function() {
  return this.allowEval;
};
mxGraphView.prototype.setAllowEval = function(value) {
  this.allowEval = value;
};
mxGraphView.prototype.getStates = function() {
  return this.states;
};
mxGraphView.prototype.setStates = function(states) {
  this.states = states;
};
mxGraphView.prototype.getCellStates = function(cells) {
  if (null == cells) {
    return this.states;
  }
  var result = [];
  for (var i = 0;i < cells.length;i++) {
    var state = this.getState(cells[i]);
    if (null != state) {
      result.push(state);
    }
  }
  return result;
};
mxGraphView.prototype.removeState = function(cell) {
  var state = null;
  if (null != cell) {
    state = this.states.remove(cell);
    if (null != state) {
      this.graph.cellRenderer.destroy(state);
      state.invalid = true;
      state.destroy();
    }
  }
  return state;
};
mxGraphView.prototype.createState = function(cell) {
  return new mxCellState(this, cell, this.graph.getCellStyle(cell));
};
mxGraphView.prototype.getCanvas = function() {
  return this.canvas;
};
mxGraphView.prototype.getBackgroundPane = function() {
  return this.backgroundPane;
};
mxGraphView.prototype.getDrawPane = function() {
  return this.drawPane;
};
mxGraphView.prototype.getOverlayPane = function() {
  return this.overlayPane;
};
mxGraphView.prototype.getDecoratorPane = function() {
  return this.decoratorPane;
};
mxGraphView.prototype.isContainerEvent = function(evt) {
  evt = mxEvent.getSource(evt);
  return evt == this.graph.container || (evt.parentNode == this.backgroundPane || (null != evt.parentNode && evt.parentNode.parentNode == this.backgroundPane || (evt == this.canvas.parentNode || (evt == this.canvas || (evt == this.backgroundPane || (evt == this.drawPane || (evt == this.overlayPane || evt == this.decoratorPane)))))));
};
mxGraphView.prototype.isScrollEvent = function(evt) {
  var offset = mxUtils.getOffset(this.graph.container);
  evt = new mxPoint(evt.clientX - offset.x, evt.clientY - offset.y);
  offset = this.graph.container.offsetWidth;
  var inWidth = this.graph.container.clientWidth;
  if (offset > inWidth && (evt.x > inWidth + 2 && evt.x <= offset)) {
    return true;
  }
  offset = this.graph.container.offsetHeight;
  inWidth = this.graph.container.clientHeight;
  return offset > inWidth && (evt.y > inWidth + 2 && evt.y <= offset) ? true : false;
};
mxGraphView.prototype.init = function() {
  this.installListeners();
  if (this.graph.dialect == mxConstants.DIALECT_SVG) {
    this.createSvg();
  } else {
    this.createHtml();
  }
};
mxGraphView.prototype.installListeners = function() {
  var graph = this.graph;
  var node = graph.container;
  if (null != node) {
    if (mxClient.IS_TOUCH) {
      mxEvent.addListener(node, "gesturestart", mxUtils.bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent.consume(evt);
      }));
      mxEvent.addListener(node, "gesturechange", mxUtils.bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent.consume(evt);
      }));
      mxEvent.addListener(node, "gestureend", mxUtils.bind(this, function(evt) {
        graph.fireGestureEvent(evt);
        mxEvent.consume(evt);
      }));
    }
    mxEvent.addGestureListeners(node, mxUtils.bind(this, function(evt) {
      if (!!this.isContainerEvent(evt)) {
        if (!((mxClient.IS_IE || (mxClient.IS_IE11 || (mxClient.IS_GC || (mxClient.IS_OP || mxClient.IS_SF)))) && this.isScrollEvent(evt))) {
          graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
        }
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isContainerEvent(evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
      }
    }), mxUtils.bind(this, function(evt) {
      if (this.isContainerEvent(evt)) {
        graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
      }
    }));
    mxEvent.addListener(node, "dblclick", mxUtils.bind(this, function(evt) {
      if (this.isContainerEvent(evt)) {
        graph.dblClick(evt);
      }
    }));
    graph.addMouseListener({
      mouseDown : function(cell, sender) {
        graph.popupMenuHandler.hideMenu();
      },
      mouseMove : function() {
      },
      mouseUp : function() {
      }
    });
    this.moveHandler = mxUtils.bind(this, function(evt) {
      if (null != graph.tooltipHandler) {
        if (graph.tooltipHandler.isHideOnHover()) {
          graph.tooltipHandler.hide();
        }
      }
      if (this.captureDocumentGesture && (graph.isMouseDown && (null != graph.container && (!this.isContainerEvent(evt) && ("none" != graph.container.style.display && ("hidden" != graph.container.style.visibility && !mxEvent.isConsumed(evt))))))) {
        var mxEffects = graph.fireMouseEvent;
        var child = mxEvent.MOUSE_MOVE;
        var pt = null;
        if (mxClient.IS_TOUCH) {
          pt = mxEvent.getClientX(evt);
          var y = mxEvent.getClientY(evt);
          pt = mxUtils.convertPoint(node, pt, y);
          pt = graph.view.getState(graph.getCellAt(pt.x, pt.y));
        }
        mxEffects.call(graph, child, new mxMouseEvent(evt, pt));
      }
    });
    this.endHandler = mxUtils.bind(this, function(evt) {
      if (this.captureDocumentGesture) {
        if (graph.isMouseDown) {
          if (null != graph.container) {
            if (!this.isContainerEvent(evt)) {
              if ("none" != graph.container.style.display) {
                if ("hidden" != graph.container.style.visibility) {
                  graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
                }
              }
            }
          }
        }
      }
    });
    mxEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);
  }
};
mxGraphView.prototype.createHtml = function() {
  var container = this.graph.container;
  if (null != container) {
    this.canvas = this.createHtmlPane("100%", "100%");
    this.canvas.style.overflow = "hidden";
    this.backgroundPane = this.createHtmlPane("1px", "1px");
    this.drawPane = this.createHtmlPane("1px", "1px");
    this.overlayPane = this.createHtmlPane("1px", "1px");
    this.decoratorPane = this.createHtmlPane("1px", "1px");
    this.canvas.appendChild(this.backgroundPane);
    this.canvas.appendChild(this.drawPane);
    this.canvas.appendChild(this.overlayPane);
    this.canvas.appendChild(this.decoratorPane);
    container.appendChild(this.canvas);
    this.updateContainerStyle(container);
  }
};
mxGraphView.prototype.updateHtmlCanvasSize = function(width, height) {
  if (null != this.graph.container) {
    var oh = this.graph.container.offsetHeight;
    this.canvas.style.width = this.graph.container.offsetWidth < width ? width + "px" : "100%";
    this.canvas.style.height = oh < height ? height + "px" : "100%";
  }
};
mxGraphView.prototype.createHtmlPane = function(width, height) {
  var pane = document.createElement("DIV");
  if (null != width && null != height) {
    pane.style.position = "absolute";
    pane.style.left = "0px";
    pane.style.top = "0px";
    pane.style.width = width;
    pane.style.height = height;
  } else {
    pane.style.position = "relative";
  }
  return pane;
};
mxGraphView.prototype.createSvg = function() {
  var container = this.graph.container;
  this.canvas = document.createElementNS(mxConstants.NS_SVG, "g");
  this.backgroundPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.backgroundPane);
  this.drawPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.drawPane);
  this.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.overlayPane);
  this.decoratorPane = document.createElementNS(mxConstants.NS_SVG, "g");
  this.canvas.appendChild(this.decoratorPane);
  var root = document.createElementNS(mxConstants.NS_SVG, "svg");
  root.style.left = "0px";
  root.style.top = "0px";
  root.style.width = "100%";
  root.style.height = "100%";
  root.style.display = "block";
  root.appendChild(this.canvas);
  if (mxClient.IS_IE || mxClient.IS_IE11) {
    root.style.overflow = "hidden";
  }
  if (null != container) {
    container.appendChild(root);
    this.updateContainerStyle(container);
  }
};
mxGraphView.prototype.updateContainerStyle = function(container) {
  var style = mxUtils.getCurrentStyle(container);
  if (null != style) {
    if ("static" == style.position) {
      container.style.position = "relative";
    }
  }
  if (mxClient.IS_POINTER) {
    container.style.touchAction = "none";
  }
};
mxGraphView.prototype.destroy = function() {
  var root = null != this.canvas ? this.canvas.ownerSVGElement : null;
  if (null == root) {
    root = this.canvas;
  }
  if (null != root) {
    if (null != root.parentNode) {
      this.clear(this.currentRoot, true);
      mxEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);
      mxEvent.release(this.graph.container);
      root.parentNode.removeChild(root);
      this.decoratorPane = this.overlayPane = this.drawPane = this.backgroundPane = this.canvas = this.endHandler = this.moveHandler = null;
    }
  }
};
function mxCurrentRootChange(next, root) {
  this.view = next;
  this.previous = this.root = root;
  this.isUp = null == root;
  if (!this.isUp) {
    next = this.view.currentRoot;
    for (var model = this.view.graph.getModel();null != next;) {
      if (next == root) {
        this.isUp = true;
        break;
      }
      next = model.getParent(next);
    }
  }
}
mxCurrentRootChange.prototype.execute = function() {
  var tmp = this.view.currentRoot;
  this.view.currentRoot = this.previous;
  this.previous = tmp;
  tmp = this.view.graph.getTranslateForRoot(this.view.currentRoot);
  if (null != tmp) {
    this.view.translate = new mxPoint(-tmp.x, -tmp.y);
  }
  if (this.isUp) {
    this.view.clear(this.view.currentRoot, true);
    this.view.validate();
  } else {
    this.view.refresh();
  }
  this.view.fireEvent(new mxEventObject(this.isUp ? mxEvent.UP : mxEvent.DOWN, "root", this.view.currentRoot, "previous", this.previous));
  this.isUp = !this.isUp;
};
function mxGraph(container, model, renderHint, stylesheet, rendering) {
  this.mouseListeners = null;
  this.renderHint = renderHint;
  this.dialect = mxClient.IS_SVG ? mxConstants.DIALECT_SVG : renderHint == mxConstants.RENDERING_HINT_FASTEST ? mxConstants.DIALECT_STRICTHTML : renderHint == mxConstants.RENDERING_HINT_FASTER ? mxConstants.DIALECT_PREFERHTML : mxConstants.DIALECT_MIXEDHTML;
  this.model = null != model ? model : new mxGraphModel;
  this.multiplicities = [];
  this.imageBundles = [];
  this.cellRenderer = this.createCellRenderer();
  this.setSelectionModel(this.createSelectionModel());
  this.setStylesheet(null != stylesheet ? stylesheet : this.createStylesheet());
  this.view = this.createGraphView();
  this.view.rendering = null != rendering ? rendering : this.view.rendering;
  this.graphModelChangeListener = mxUtils.bind(this, function(flex, evt) {
    this.graphModelChanged(evt.getProperty("edit").changes);
  });
  this.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener);
  this.createHandlers();
  if (null != container) {
    this.init(container);
  }
  if (this.view.rendering) {
    this.view.revalidate();
  }
}
if (mxLoadResources) {
  mxResources.add(mxClient.basePath + "/resources/graph");
} else {
  mxClient.defaultBundles.push(mxClient.basePath + "/resources/graph");
}
mxGraph.prototype = new mxEventSource;
mxGraph.prototype.constructor = mxGraph;
mxGraph.prototype.mouseListeners = null;
mxGraph.prototype.isMouseDown = false;
mxGraph.prototype.model = null;
mxGraph.prototype.view = null;
mxGraph.prototype.stylesheet = null;
mxGraph.prototype.selectionModel = null;
mxGraph.prototype.cellEditor = null;
mxGraph.prototype.cellRenderer = null;
mxGraph.prototype.multiplicities = null;
mxGraph.prototype.renderHint = null;
mxGraph.prototype.dialect = null;
mxGraph.prototype.gridSize = 10;
mxGraph.prototype.gridEnabled = true;
mxGraph.prototype.portsEnabled = true;
mxGraph.prototype.nativeDblClickEnabled = true;
mxGraph.prototype.doubleTapEnabled = true;
mxGraph.prototype.doubleTapTimeout = 500;
mxGraph.prototype.doubleTapTolerance = 25;
mxGraph.prototype.lastTouchY = 0;
mxGraph.prototype.lastTouchY = 0;
mxGraph.prototype.lastTouchTime = 0;
mxGraph.prototype.tapAndHoldEnabled = true;
mxGraph.prototype.tapAndHoldDelay = 500;
mxGraph.prototype.tapAndHoldInProgress = false;
mxGraph.prototype.tapAndHoldValid = false;
mxGraph.prototype.initialTouchX = 0;
mxGraph.prototype.initialTouchY = 0;
mxGraph.prototype.tolerance = 4;
mxGraph.prototype.defaultOverlap = 0.5;
mxGraph.prototype.defaultParent = null;
mxGraph.prototype.alternateEdgeStyle = null;
mxGraph.prototype.backgroundImage = null;
mxGraph.prototype.pageVisible = false;
mxGraph.prototype.pageBreaksVisible = false;
mxGraph.prototype.pageBreakColor = "gray";
mxGraph.prototype.pageBreakDashed = true;
mxGraph.prototype.minPageBreakDist = 20;
mxGraph.prototype.preferPageSize = false;
mxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;
mxGraph.prototype.pageScale = 1.5;
mxGraph.prototype.enabled = true;
mxGraph.prototype.escapeEnabled = true;
mxGraph.prototype.invokesStopCellEditing = true;
mxGraph.prototype.enterStopsCellEditing = false;
mxGraph.prototype.useScrollbarsForPanning = true;
mxGraph.prototype.exportEnabled = true;
mxGraph.prototype.importEnabled = true;
mxGraph.prototype.cellsLocked = false;
mxGraph.prototype.cellsCloneable = true;
mxGraph.prototype.foldingEnabled = true;
mxGraph.prototype.cellsEditable = true;
mxGraph.prototype.cellsDeletable = true;
mxGraph.prototype.cellsMovable = true;
mxGraph.prototype.edgeLabelsMovable = true;
mxGraph.prototype.vertexLabelsMovable = false;
mxGraph.prototype.dropEnabled = false;
mxGraph.prototype.splitEnabled = true;
mxGraph.prototype.cellsResizable = true;
mxGraph.prototype.cellsBendable = true;
mxGraph.prototype.cellsSelectable = true;
mxGraph.prototype.cellsDisconnectable = true;
mxGraph.prototype.autoSizeCells = false;
mxGraph.prototype.autoSizeCellsOnAdd = false;
mxGraph.prototype.autoScroll = true;
mxGraph.prototype.ignoreScrollbars = false;
mxGraph.prototype.translateToScrollPosition = false;
mxGraph.prototype.timerAutoScroll = false;
mxGraph.prototype.allowAutoPanning = false;
mxGraph.prototype.autoExtend = true;
mxGraph.prototype.maximumGraphBounds = null;
mxGraph.prototype.minimumGraphSize = null;
mxGraph.prototype.minimumContainerSize = null;
mxGraph.prototype.maximumContainerSize = null;
mxGraph.prototype.resizeContainer = false;
mxGraph.prototype.border = 0;
mxGraph.prototype.keepEdgesInForeground = false;
mxGraph.prototype.keepEdgesInBackground = false;
mxGraph.prototype.allowNegativeCoordinates = true;
mxGraph.prototype.constrainChildren = true;
mxGraph.prototype.constrainRelativeChildren = false;
mxGraph.prototype.extendParents = true;
mxGraph.prototype.extendParentsOnAdd = true;
mxGraph.prototype.extendParentsOnMove = false;
mxGraph.prototype.recursiveResize = false;
mxGraph.prototype.collapseToPreferredSize = true;
mxGraph.prototype.zoomFactor = 1.2;
mxGraph.prototype.keepSelectionVisibleOnZoom = false;
mxGraph.prototype.centerZoom = true;
mxGraph.prototype.resetViewOnRootChange = true;
mxGraph.prototype.resetEdgesOnResize = false;
mxGraph.prototype.resetEdgesOnMove = false;
mxGraph.prototype.resetEdgesOnConnect = true;
mxGraph.prototype.allowLoops = false;
mxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop;
mxGraph.prototype.multigraph = true;
mxGraph.prototype.connectableEdges = false;
mxGraph.prototype.allowDanglingEdges = true;
mxGraph.prototype.cloneInvalidEdges = false;
mxGraph.prototype.disconnectOnMove = true;
mxGraph.prototype.labelsVisible = true;
mxGraph.prototype.htmlLabels = false;
mxGraph.prototype.swimlaneSelectionEnabled = true;
mxGraph.prototype.swimlaneNesting = true;
mxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR;
mxGraph.prototype.imageBundles = null;
mxGraph.prototype.minFitScale = 0.1;
mxGraph.prototype.maxFitScale = 8;
mxGraph.prototype.panDx = 0;
mxGraph.prototype.panDy = 0;
mxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + "/collapsed.gif", 9, 9);
mxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + "/expanded.gif", 9, 9);
mxGraph.prototype.warningImage = new mxImage(mxClient.imageBasePath + "/warning" + (mxClient.IS_MAC ? ".png" : ".gif"), 16, 16);
mxGraph.prototype.alreadyConnectedResource = "none" != mxClient.language ? "alreadyConnected" : "";
mxGraph.prototype.containsValidationErrorsResource = "none" != mxClient.language ? "containsValidationErrors" : "";
mxGraph.prototype.collapseExpandResource = "none" != mxClient.language ? "collapse-expand" : "";
mxGraph.prototype.init = function(container) {
  this.container = container;
  this.cellEditor = this.createCellEditor();
  this.view.init();
  this.sizeDidChange();
  mxEvent.addListener(container, "mouseleave", mxUtils.bind(this, function(evt) {
    if (null != this.tooltipHandler) {
      if (null != this.tooltipHandler.div) {
        if (this.tooltipHandler.div != evt.relatedTarget) {
          this.tooltipHandler.hide();
        }
      }
    }
  }));
  if (mxClient.IS_IE) {
    mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
      this.destroy();
    }));
    mxEvent.addListener(container, "selectstart", mxUtils.bind(this, function(evt) {
      return this.isEditing() || !this.isMouseDown && !mxEvent.isShiftDown(evt);
    }));
  }
};
mxGraph.prototype.createHandlers = function() {
  this.tooltipHandler = this.createTooltipHandler();
  this.tooltipHandler.setEnabled(false);
  this.selectionCellsHandler = this.createSelectionCellsHandler();
  this.connectionHandler = this.createConnectionHandler();
  this.connectionHandler.setEnabled(false);
  this.graphHandler = this.createGraphHandler();
  this.panningHandler = this.createPanningHandler();
  this.panningHandler.panningEnabled = false;
  this.popupMenuHandler = this.createPopupMenuHandler();
};
mxGraph.prototype.createTooltipHandler = function() {
  return new mxTooltipHandler(this);
};
mxGraph.prototype.createSelectionCellsHandler = function() {
  return new mxSelectionCellsHandler(this);
};
mxGraph.prototype.createConnectionHandler = function() {
  return new mxConnectionHandler(this);
};
mxGraph.prototype.createGraphHandler = function() {
  return new mxGraphHandler(this);
};
mxGraph.prototype.createPanningHandler = function() {
  return new mxPanningHandler(this);
};
mxGraph.prototype.createPopupMenuHandler = function() {
  return new mxPopupMenuHandler(this);
};
mxGraph.prototype.createSelectionModel = function() {
  return new mxGraphSelectionModel(this);
};
mxGraph.prototype.createStylesheet = function() {
  return new mxStylesheet;
};
mxGraph.prototype.createGraphView = function() {
  return new mxGraphView(this);
};
mxGraph.prototype.createCellRenderer = function() {
  return new mxCellRenderer;
};
mxGraph.prototype.createCellEditor = function() {
  return new mxCellEditor(this);
};
mxGraph.prototype.getModel = function() {
  return this.model;
};
mxGraph.prototype.getView = function() {
  return this.view;
};
mxGraph.prototype.getStylesheet = function() {
  return this.stylesheet;
};
mxGraph.prototype.setStylesheet = function(stylesheet) {
  this.stylesheet = stylesheet;
};
mxGraph.prototype.getSelectionModel = function() {
  return this.selectionModel;
};
mxGraph.prototype.setSelectionModel = function(selectionModel) {
  this.selectionModel = selectionModel;
};
mxGraph.prototype.getSelectionCellsForChanges = function(changes, ignoreFn) {
  var dict = new mxDictionary;
  var cells = [];
  var addCell = mxUtils.bind(this, function(cell) {
    if (!dict.get(cell) && this.model.contains(cell)) {
      if (this.model.isEdge(cell) || this.model.isVertex(cell)) {
        dict.put(cell, true);
        cells.push(cell);
      } else {
        var childCount = this.model.getChildCount(cell);
        for (var i = 0;i < childCount;i++) {
          addCell(this.model.getChildAt(cell, i));
        }
      }
    }
  });
  for (var i = 0;i < changes.length;i++) {
    var change = changes[i];
    if (change.constructor != mxRootChange && (null == ignoreFn || !ignoreFn(change))) {
      var cell = null;
      if (change instanceof mxChildChange) {
        cell = change.child;
      } else {
        if (null != change.cell) {
          if (change.cell instanceof mxCell) {
            cell = change.cell;
          }
        }
      }
      if (null != cell) {
        addCell(cell);
      }
    }
  }
  return cells;
};
mxGraph.prototype.graphModelChanged = function(changes) {
  for (var i = 0;i < changes.length;i++) {
    this.processChange(changes[i]);
  }
  this.updateSelection();
  this.view.validate();
  this.sizeDidChange();
};
mxGraph.prototype.updateSelection = function() {
  var cells = this.getSelectionCells();
  var removed = [];
  for (var i = 0;i < cells.length;i++) {
    if (this.model.contains(cells[i]) && this.isCellVisible(cells[i])) {
      for (var cell = this.model.getParent(cells[i]);null != cell && cell != this.view.currentRoot;) {
        if (this.isCellCollapsed(cell) || !this.isCellVisible(cell)) {
          removed.push(cells[i]);
          break;
        }
        cell = this.model.getParent(cell);
      }
    } else {
      removed.push(cells[i]);
    }
  }
  this.removeSelectionCells(removed);
};
mxGraph.prototype.processChange = function(change) {
  if (change instanceof mxRootChange) {
    this.clearSelection();
    this.setDefaultParent(null);
    this.removeStateForCell(change.previous);
    if (this.resetViewOnRootChange) {
      this.view.scale = 1;
      this.view.translate.x = 0;
      this.view.translate.y = 0;
    }
    this.fireEvent(new mxEventObject(mxEvent.ROOT));
  } else {
    if (change instanceof mxChildChange) {
      var cell = this.model.getParent(change.child);
      this.view.invalidate(change.child, true, true);
      if (!this.model.contains(cell) || this.isCellCollapsed(cell)) {
        this.view.invalidate(change.child, true, true);
        this.removeStateForCell(change.child);
        if (this.view.currentRoot == change.child) {
          this.home();
        }
      }
      if (cell != change.previous) {
        if (null != cell) {
          this.view.invalidate(cell, false, false);
        }
        if (null != change.previous) {
          this.view.invalidate(change.previous, false, false);
        }
      }
    } else {
      if (change instanceof mxTerminalChange || change instanceof mxGeometryChange) {
        if (change instanceof mxTerminalChange || (null == change.previous && null != change.geometry || null != change.previous && !change.previous.equals(change.geometry))) {
          this.view.invalidate(change.cell);
        }
      } else {
        if (change instanceof mxValueChange) {
          this.view.invalidate(change.cell, false, false);
        } else {
          if (change instanceof mxStyleChange) {
            this.view.invalidate(change.cell, true, true);
            change = this.view.getState(change.cell);
            if (null != change) {
              change.invalidStyle = true;
            }
          } else {
            if (null != change.cell) {
              if (change.cell instanceof mxCell) {
                this.removeStateForCell(change.cell);
              }
            }
          }
        }
      }
    }
  }
};
mxGraph.prototype.removeStateForCell = function(cell) {
  var childCount = this.model.getChildCount(cell);
  for (var i = 0;i < childCount;i++) {
    this.removeStateForCell(this.model.getChildAt(cell, i));
  }
  this.view.invalidate(cell, false, true);
  this.view.removeState(cell);
};
mxGraph.prototype.addCellOverlay = function(cell, overlay) {
  if (null == cell.overlays) {
    cell.overlays = [];
  }
  cell.overlays.push(overlay);
  var state = this.view.getState(cell);
  if (null != state) {
    this.cellRenderer.redraw(state);
  }
  this.fireEvent(new mxEventObject(mxEvent.ADD_OVERLAY, "cell", cell, "overlay", overlay));
  return overlay;
};
mxGraph.prototype.getCellOverlays = function(cell) {
  return cell.overlays;
};
mxGraph.prototype.removeCellOverlay = function(cell, overlay) {
  if (null == overlay) {
    this.removeCellOverlays(cell);
  } else {
    var state = mxUtils.indexOf(cell.overlays, overlay);
    if (0 <= state) {
      cell.overlays.splice(state, 1);
      if (0 == cell.overlays.length) {
        cell.overlays = null;
      }
      state = this.view.getState(cell);
      if (null != state) {
        this.cellRenderer.redraw(state);
      }
      this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, "cell", cell, "overlay", overlay));
    } else {
      overlay = null;
    }
  }
  return overlay;
};
mxGraph.prototype.removeCellOverlays = function(cell) {
  var overlays = cell.overlays;
  if (null != overlays) {
    cell.overlays = null;
    var state = this.view.getState(cell);
    if (null != state) {
      this.cellRenderer.redraw(state);
    }
    for (state = 0;state < overlays.length;state++) {
      this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, "cell", cell, "overlay", overlays[state]));
    }
  }
  return overlays;
};
mxGraph.prototype.clearCellOverlays = function(cell) {
  cell = null != cell ? cell : this.model.getRoot();
  this.removeCellOverlays(cell);
  var childCount = this.model.getChildCount(cell);
  for (var i = 0;i < childCount;i++) {
    var child = this.model.getChildAt(cell, i);
    this.clearCellOverlays(child);
  }
};
mxGraph.prototype.setCellWarning = function(cell, overlay, img, isSelect) {
  if (null != overlay && 0 < overlay.length) {
    return img = null != img ? img : this.warningImage, overlay = new mxCellOverlay(img, "<font color=red>" + overlay + "</font>"), isSelect && overlay.addListener(mxEvent.CLICK, mxUtils.bind(this, function(flex, editor) {
      if (this.isEnabled()) {
        this.setSelectionCell(cell);
      }
    })), this.addCellOverlay(cell, overlay);
  }
  this.removeCellOverlays(cell);
  return null;
};
mxGraph.prototype.startEditing = function(evt) {
  this.startEditingAtCell(null, evt);
};
mxGraph.prototype.startEditingAtCell = function(cell, evt) {
  if (!(null != evt && mxEvent.isMultiTouchEvent(evt))) {
    if (null == cell) {
      cell = this.getSelectionCell();
      if (!(null == cell)) {
        if (!this.isCellEditable(cell)) {
          cell = null;
        }
      }
    }
    if (null != cell) {
      this.fireEvent(new mxEventObject(mxEvent.START_EDITING, "cell", cell, "event", evt));
      this.cellEditor.startEditing(cell, evt);
      this.fireEvent(new mxEventObject(mxEvent.EDITING_STARTED, "cell", cell, "event", evt));
    }
  }
};
mxGraph.prototype.getEditingValue = function(cell, evt) {
  return this.convertValueToString(cell);
};
mxGraph.prototype.stopEditing = function(cancel) {
  this.cellEditor.stopEditing(cancel);
  this.fireEvent(new mxEventObject(mxEvent.EDITING_STOPPED, "cancel", cancel));
};
mxGraph.prototype.labelChanged = function(cell, value, evt) {
  this.model.beginUpdate();
  try {
    var old = cell.value;
    this.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));
    this.fireEvent(new mxEventObject(mxEvent.LABEL_CHANGED, "cell", cell, "value", value, "old", old, "event", evt));
  } finally {
    this.model.endUpdate();
  }
  return cell;
};
mxGraph.prototype.cellLabelChanged = function(cell, value, autoSize) {
  this.model.beginUpdate();
  try {
    this.model.setValue(cell, value);
    if (autoSize) {
      this.cellSizeUpdated(cell, false);
    }
  } finally {
    this.model.endUpdate();
  }
};
mxGraph.prototype.escape = function(evt) {
  this.fireEvent(new mxEventObject(mxEvent.ESCAPE, "event", evt));
};
mxGraph.prototype.click = function(me) {
  var evt = me.getEvent();
  var swimlane = me.getCell();
  var cell = new mxEventObject(mxEvent.CLICK, "event", evt, "cell", swimlane);
  if (me.isConsumed()) {
    cell.consume();
  }
  this.fireEvent(cell);
  if (this.isEnabled() && (!mxEvent.isConsumed(evt) && !cell.isConsumed())) {
    if (null != swimlane) {
      if (this.isTransparentClickEvent(evt)) {
        var active = false;
        me = this.getCellAt(me.graphX, me.graphY, null, null, null, mxUtils.bind(this, function(state) {
          var selected = this.isCellSelected(state.cell);
          active = active || selected;
          return!active || (selected || state.cell != swimlane && this.model.isAncestor(state.cell, swimlane));
        }));
        if (null != me) {
          swimlane = me;
        }
      }
    } else {
      if (this.isSwimlaneSelectionEnabled() && (swimlane = this.getSwimlaneAt(me.getGraphX(), me.getGraphY()), !(null == swimlane || this.isToggleEvent(evt) && mxEvent.isAltDown(evt)))) {
        cell = swimlane;
        for (me = [];null != cell;) {
          cell = this.model.getParent(cell);
          var isCollapsed = this.view.getState(cell);
          if (this.isSwimlane(cell)) {
            if (null != isCollapsed) {
              me.push(cell);
            }
          }
        }
        if (0 < me.length) {
          me = me.reverse();
          me.splice(0, 0, swimlane);
          me.push(swimlane);
          for (cell = 0;cell < me.length - 1;cell++) {
            if (this.isCellSelected(me[cell])) {
              swimlane = me[this.isToggleEvent(evt) ? cell : cell + 1];
            }
          }
        }
      }
    }
    if (null != swimlane) {
      this.selectCellForEvent(swimlane, evt);
    } else {
      if (!this.isToggleEvent(evt)) {
        this.clearSelection();
      }
    }
  }
};
mxGraph.prototype.isSiblingSelected = function(cell) {
  var model = this.model;
  var parent = model.getParent(cell);
  var childCount = model.getChildCount(parent);
  for (var i = 0;i < childCount;i++) {
    var child = model.getChildAt(parent, i);
    if (cell != child && this.isCellSelected(child)) {
      return true;
    }
  }
  return false;
};
mxGraph.prototype.dblClick = function(evt, cell) {
  var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, "event", evt, "cell", cell);
  this.fireEvent(mxe);
  if (!!this.isEnabled()) {
    if (!mxEvent.isConsumed(evt)) {
      if (!mxe.isConsumed()) {
        if (!(null == cell)) {
          if (!!this.isCellEditable(cell)) {
            if (!this.isEditing(cell)) {
              this.startEditingAtCell(cell, evt);
              mxEvent.consume(evt);
            }
          }
        }
      }
    }
  }
};
mxGraph.prototype.tapAndHold = function(me) {
  var evt = me.getEvent();
  var mxe = new mxEventObject(mxEvent.TAP_AND_HOLD, "event", evt, "cell", me.getCell());
  this.fireEvent(mxe);
  if (mxe.isConsumed()) {
    this.panningHandler.panningTrigger = false;
  }
  if (this.isEnabled()) {
    if (!mxEvent.isConsumed(evt)) {
      if (!mxe.isConsumed()) {
        if (this.connectionHandler.isEnabled()) {
          evt = this.view.getState(this.connectionHandler.marker.getCell(me));
          if (null != evt) {
            this.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;
            this.connectionHandler.marker.markedState = evt;
            this.connectionHandler.marker.mark();
            this.connectionHandler.first = new mxPoint(me.getGraphX(), me.getGraphY());
            this.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);
            this.connectionHandler.previous = evt;
            this.connectionHandler.fireEvent(new mxEventObject(mxEvent.START, "state", this.connectionHandler.previous));
          }
        }
      }
    }
  }
};
mxGraph.prototype.scrollPointToVisible = function(x, y, extend, border) {
  if (this.timerAutoScroll || !this.ignoreScrollbars && !mxUtils.hasScrollbars(this.container)) {
    if (this.allowAutoPanning) {
      if (!this.panningHandler.isActive()) {
        if (null == this.panningManager) {
          this.panningManager = this.createPanningManager();
        }
        this.panningManager.panTo(x + this.panDx, y + this.panDy);
      }
    }
  } else {
    var c = this.container;
    border = null != border ? border : 20;
    if (x >= c.scrollLeft && (y >= c.scrollTop && (x <= c.scrollLeft + c.clientWidth && y <= c.scrollTop + c.clientHeight))) {
      var dx = c.scrollLeft + c.clientWidth - x;
      if (dx < border) {
        if (x = c.scrollLeft, c.scrollLeft += border - dx, extend && x == c.scrollLeft) {
          if (this.dialect == mxConstants.DIALECT_SVG) {
            x = this.view.getDrawPane().ownerSVGElement;
            var width = this.container.scrollWidth + border - dx;
            x.style.width = width + "px";
          } else {
            width = Math.max(c.clientWidth, c.scrollWidth) + border - dx;
            x = this.view.getCanvas();
            x.style.width = width + "px";
          }
          c.scrollLeft += border - dx;
        }
      } else {
        dx = x - c.scrollLeft;
        if (dx < border) {
          c.scrollLeft -= border - dx;
        }
      }
      dx = c.scrollTop + c.clientHeight - y;
      if (dx < border) {
        x = c.scrollTop;
        c.scrollTop += border - dx;
        if (x == c.scrollTop) {
          if (extend) {
            if (this.dialect == mxConstants.DIALECT_SVG) {
              x = this.view.getDrawPane().ownerSVGElement;
              y = this.container.scrollHeight + border - dx;
              x.style.height = y + "px";
            } else {
              y = Math.max(c.clientHeight, c.scrollHeight) + border - dx;
              x = this.view.getCanvas();
              x.style.height = y + "px";
            }
            c.scrollTop += border - dx;
          }
        }
      } else {
        dx = y - c.scrollTop;
        if (dx < border) {
          c.scrollTop -= border - dx;
        }
      }
    }
  }
};
mxGraph.prototype.createPanningManager = function() {
  return new mxPanningManager(this);
};
mxGraph.prototype.getBorderSizes = function() {
  var css = mxUtils.getCurrentStyle(this.container);
  return new mxRectangle(mxUtils.parseCssNumber(css.paddingLeft) + ("none" != css.borderLeftStyle ? mxUtils.parseCssNumber(css.borderLeftWidth) : 0), mxUtils.parseCssNumber(css.paddingTop) + ("none" != css.borderTopStyle ? mxUtils.parseCssNumber(css.borderTopWidth) : 0), mxUtils.parseCssNumber(css.paddingRight) + ("none" != css.borderRightStyle ? mxUtils.parseCssNumber(css.borderRightWidth) : 0), mxUtils.parseCssNumber(css.paddingBottom) + ("none" != css.borderBottomStyle ? mxUtils.parseCssNumber(css.borderBottomWidth) :
  0));
};
mxGraph.prototype.getPreferredPageSize = function(bounds, width, height) {
  bounds = this.view.translate;
  var fmt = this.pageFormat;
  var ps = this.pageScale;
  fmt = new mxRectangle(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));
  return new mxRectangle(0, 0, (this.pageBreaksVisible ? Math.ceil(width / fmt.width) : 1) * fmt.width + 2 + bounds.x, (this.pageBreaksVisible ? Math.ceil(height / fmt.height) : 1) * fmt.height + 2 + bounds.y);
};
mxGraph.prototype.fit = function(border, keepOrigin, margin, enabled, s2, ignoreHeight, bounds) {
  if (null != this.container) {
    border = null != border ? border : this.getBorder();
    keepOrigin = null != keepOrigin ? keepOrigin : false;
    margin = null != margin ? margin : 0;
    enabled = null != enabled ? enabled : true;
    s2 = null != s2 ? s2 : false;
    ignoreHeight = null != ignoreHeight ? ignoreHeight : false;
    var s = this.getBorderSizes();
    var w1 = this.container.offsetWidth - s.x - s.width - 1;
    var h1 = null != bounds ? bounds : this.container.offsetHeight - s.y - s.height - 1;
    bounds = this.view.getGraphBounds();
    if (0 < bounds.width && 0 < bounds.height) {
      if (keepOrigin) {
        if (null != bounds.x) {
          if (null != bounds.y) {
            bounds = bounds.clone();
            bounds.width += bounds.x;
            bounds.height += bounds.y;
            bounds.x = 0;
            bounds.y = 0;
          }
        }
      }
      s = this.view.scale;
      var w2 = bounds.width / s;
      var h2 = bounds.height / s;
      if (null != this.backgroundImage) {
        if (null != this.backgroundImage.width) {
          if (null != this.backgroundImage.height) {
            w2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);
            h2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);
          }
        }
      }
      var b = (keepOrigin ? border : 2 * border) + margin + 1;
      w1 -= b;
      h1 -= b;
      s2 = s2 ? h1 / h2 : ignoreHeight ? w1 / w2 : Math.min(w1 / w2, h1 / h2);
      if (null != this.minFitScale) {
        s2 = Math.max(s2, this.minFitScale);
      }
      if (null != this.maxFitScale) {
        s2 = Math.min(s2, this.maxFitScale);
      }
      if (enabled) {
        if (keepOrigin) {
          if (this.view.scale != s2) {
            this.view.setScale(s2);
          }
        } else {
          if (mxUtils.hasScrollbars(this.container)) {
            this.view.setScale(s2);
            border = this.getGraphBounds();
            if (null != border.x) {
              this.container.scrollLeft = border.x;
            }
            if (null != border.y) {
              this.container.scrollTop = border.y;
            }
          } else {
            this.view.scaleAndTranslate(s2, null != bounds.x ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border, null != bounds.y ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border);
          }
        }
      } else {
        return s2;
      }
    }
  }
  return this.view.scale;
};
mxGraph.prototype.sizeDidChange = function() {
  var bounds = this.getGraphBounds();
  if (null != this.container) {
    var height = this.getBorder();
    var width = Math.max(0, bounds.x) + bounds.width + 2 * height;
    height = Math.max(0, bounds.y) + bounds.height + 2 * height;
    if (null != this.minimumContainerSize) {
      width = Math.max(width, this.minimumContainerSize.width);
      height = Math.max(height, this.minimumContainerSize.height);
    }
    if (this.resizeContainer) {
      this.doResizeContainer(width, height);
    }
    if (this.preferPageSize || !mxClient.IS_IE && this.pageVisible) {
      var size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));
      if (null != size) {
        width = size.width * this.view.scale;
        height = size.height * this.view.scale;
      }
    }
    if (null != this.minimumGraphSize) {
      width = Math.max(width, this.minimumGraphSize.width * this.view.scale);
      height = Math.max(height, this.minimumGraphSize.height * this.view.scale);
    }
    width = Math.ceil(width);
    height = Math.ceil(height);
    if (this.dialect == mxConstants.DIALECT_SVG) {
      size = this.view.getDrawPane().ownerSVGElement;
      if (null != size) {
        size.style.minWidth = Math.max(1, width) + "px";
        size.style.minHeight = Math.max(1, height) + "px";
        size.style.width = "100%";
        size.style.height = "100%";
      }
    } else {
      this.view.canvas.style.minWidth = Math.max(1, width) + "px";
      this.view.canvas.style.minHeight = Math.max(1, height) + "px";
    }
    this.updatePageBreaks(this.pageBreaksVisible, width, height);
  }
  this.fireEvent(new mxEventObject(mxEvent.SIZE, "bounds", bounds));
};
mxGraph.prototype.doResizeContainer = function(width, height) {
  if (null != this.maximumContainerSize) {
    width = Math.min(this.maximumContainerSize.width, width);
    height = Math.min(this.maximumContainerSize.height, height);
  }
  this.container.style.width = Math.ceil(width) + "px";
  this.container.style.height = Math.ceil(height) + "px";
};
mxGraph.prototype.updatePageBreaks = function(visible, scale, spacing) {
  scale = this.view.scale;
  spacing = this.view.translate;
  var gb = this.pageFormat;
  var ps = scale * this.pageScale;
  var bounds = new mxRectangle(0, 0, gb.width * ps, gb.height * ps);
  gb = mxRectangle.fromRectangle(this.getGraphBounds());
  gb.width = Math.max(1, gb.width);
  gb.height = Math.max(1, gb.height);
  bounds.x = Math.floor((gb.x - spacing.x * scale) / bounds.width) * bounds.width + spacing.x * scale;
  bounds.y = Math.floor((gb.y - spacing.y * scale) / bounds.height) * bounds.height + spacing.y * scale;
  gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;
  gb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;
  var horizontalCount = (visible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist) ? Math.ceil(gb.height / bounds.height) + 1 : 0;
  var verticalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;
  var right = (verticalCount - 1) * bounds.width;
  var bottom = (horizontalCount - 1) * bounds.height;
  if (null == this.horizontalPageBreaks) {
    if (0 < horizontalCount) {
      this.horizontalPageBreaks = [];
    }
  }
  if (null == this.verticalPageBreaks) {
    if (0 < verticalCount) {
      this.verticalPageBreaks = [];
    }
  }
  visible = mxUtils.bind(this, function(breaks) {
    if (null != breaks) {
      var count = breaks == this.horizontalPageBreaks ? horizontalCount : verticalCount;
      for (var i = 0;i <= count;i++) {
        var pageBreak = breaks == this.horizontalPageBreaks ? [new mxPoint(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)), new mxPoint(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height))] : [new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)), new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom))];
        if (null != breaks[i]) {
          breaks[i].points = pageBreak;
          breaks[i].redraw();
        } else {
          pageBreak = new mxPolyline(pageBreak, this.pageBreakColor);
          pageBreak.dialect = this.dialect;
          pageBreak.pointerEvents = false;
          pageBreak.isDashed = this.pageBreakDashed;
          pageBreak.init(this.view.backgroundPane);
          pageBreak.redraw();
          breaks[i] = pageBreak;
        }
      }
      for (i = count;i < breaks.length;i++) {
        breaks[i].destroy();
      }
      breaks.splice(count, breaks.length - count);
    }
  });
  visible(this.horizontalPageBreaks);
  visible(this.verticalPageBreaks);
};
mxGraph.prototype.getCurrentCellStyle = function(cell, ignoreState) {
  ignoreState = ignoreState ? null : this.view.getState(cell);
  return null != ignoreState ? ignoreState.style : this.getCellStyle(cell);
};
mxGraph.prototype.getCellStyle = function(cell, directed) {
  directed = null != directed ? directed : true;
  var stylename = this.model.getStyle(cell);
  var style = this.model.isEdge(cell) ? this.stylesheet.getDefaultEdgeStyle() : this.stylesheet.getDefaultVertexStyle();
  if (null != stylename) {
    style = this.stylesheet.getCellStyle(stylename, style, directed);
  } else {
    if (null != style) {
      style = mxUtils.clone(style);
    }
  }
  if (null == style) {
    style = {};
  } else {
    if (directed) {
      style = this.postProcessCellStyle(cell, style);
    }
  }
  return style;
};
mxGraph.prototype.postProcessCellStyle = function(image, style) {
  if (null != style) {
    var comma = style[mxConstants.STYLE_IMAGE];
    image = this.getImageFromBundles(comma);
    if (null != image) {
      style[mxConstants.STYLE_IMAGE] = image;
    } else {
      image = comma;
    }
    if (null != image) {
      if ("data:image/" == image.substring(0, 11)) {
        if ("data:image/svg+xml,<" == image.substring(0, 20)) {
          image = image.substring(0, 19) + encodeURIComponent(image.substring(19));
        } else {
          if ("data:image/svg+xml,%3C" != image.substring(0, 22)) {
            comma = image.indexOf(",");
            if (0 < comma) {
              if (";base64," != image.substring(comma - 7, comma + 1)) {
                image = image.substring(0, comma) + ";base64," + image.substring(comma + 1);
              }
            }
          }
        }
        style[mxConstants.STYLE_IMAGE] = image;
      }
    }
  }
  return style;
};
mxGraph.prototype.setCellStyle = function(style, cells) {
  cells = cells || this.getSelectionCells();
  if (null != cells) {
    this.model.beginUpdate();
    try {
      for (var i = 0;i < cells.length;i++) {
        this.model.setStyle(cells[i], style);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.toggleCellStyle = function(key, defaultValue, cell) {
  cell = cell || this.getSelectionCell();
  return this.toggleCellStyles(key, defaultValue, [cell]);
};
mxGraph.prototype.toggleCellStyles = function(cells, defaultValue, key) {
  defaultValue = null != defaultValue ? defaultValue : false;
  key = key || this.getEditableCells(this.getSelectionCells());
  var style = null;
  if (null != key) {
    if (0 < key.length) {
      style = this.getCurrentCellStyle(key[0]);
      style = mxUtils.getValue(style, cells, defaultValue) ? 0 : 1;
      this.setCellStyles(cells, style, key);
    }
  }
  return style;
};
mxGraph.prototype.setCellStyles = function(key, value, cells) {
  cells = cells || this.getEditableCells(this.getSelectionCells());
  mxUtils.setCellStyles(this.model, cells, key, value);
};
mxGraph.prototype.toggleCellStyleFlags = function(key, flag, cells) {
  this.setCellStyleFlags(key, flag, null, cells);
};
mxGraph.prototype.setCellStyleFlags = function(key, flag, value, cells) {
  cells = cells || this.getEditableCells(this.getSelectionCells());
  if (null != cells) {
    if (0 < cells.length) {
      if (null == value) {
        value = this.getCurrentCellStyle(cells[0]);
        value = (parseInt(value[key] || 0) & flag) != flag;
      }
      mxUtils.setCellStyleFlags(this.model, cells, key, flag, value);
    }
  }
};
mxGraph.prototype.getOriginForCell = function(cell) {
  cell = this.model.getParent(cell);
  for (var result = new mxPoint;null != cell;) {
    var geo = this.getCellGeometry(cell);
    if (!(null == geo)) {
      if (!geo.relative) {
        result.x += geo.x;
        result.y += geo.y;
      }
    }
    cell = this.model.getParent(cell);
  }
  return result;
};
mxGraph.prototype.alignCells = function(align, cells, param) {
  if (null == cells) {
    cells = this.getMovableCells(this.getSelectionCells());
  }
  if (null != cells && 1 < cells.length) {
    if (null == param) {
      for (var i = 0;i < cells.length;i++) {
        var result = this.getOriginForCell(cells[i]);
        var geo = this.getCellGeometry(cells[i]);
        if (!this.model.isEdge(cells[i]) && (null != geo && !geo.relative)) {
          if (null == param) {
            if (align == mxConstants.ALIGN_CENTER) {
              param = result.x + geo.x + geo.width / 2;
              break;
            } else {
              if (align == mxConstants.ALIGN_RIGHT) {
                param = result.x + geo.x + geo.width;
              } else {
                if (align == mxConstants.ALIGN_TOP) {
                  param = result.y + geo.y;
                } else {
                  if (align == mxConstants.ALIGN_MIDDLE) {
                    param = result.y + geo.y + geo.height / 2;
                    break;
                  } else {
                    param = align == mxConstants.ALIGN_BOTTOM ? result.y + geo.y + geo.height : result.x + geo.x;
                  }
                }
              }
            }
          } else {
            param = align == mxConstants.ALIGN_RIGHT ? Math.max(param, result.x + geo.x + geo.width) : align == mxConstants.ALIGN_TOP ? Math.min(param, result.y + geo.y) : align == mxConstants.ALIGN_BOTTOM ? Math.max(param, result.y + geo.y + geo.height) : Math.min(param, result.x + geo.x);
          }
        }
      }
    }
    if (null != param) {
      cells = mxUtils.sortCells(cells);
      this.model.beginUpdate();
      try {
        for (i = 0;i < cells.length;i++) {
          result = this.getOriginForCell(cells[i]);
          geo = this.getCellGeometry(cells[i]);
          if (!this.model.isEdge(cells[i])) {
            if (!(null == geo)) {
              if (!geo.relative) {
                geo = geo.clone();
                if (align == mxConstants.ALIGN_CENTER) {
                  geo.x = param - result.x - geo.width / 2;
                } else {
                  if (align == mxConstants.ALIGN_RIGHT) {
                    geo.x = param - result.x - geo.width;
                  } else {
                    if (align == mxConstants.ALIGN_TOP) {
                      geo.y = param - result.y;
                    } else {
                      if (align == mxConstants.ALIGN_MIDDLE) {
                        geo.y = param - result.y - geo.height / 2;
                      } else {
                        if (align == mxConstants.ALIGN_BOTTOM) {
                          geo.y = param - result.y - geo.height;
                        } else {
                          geo.x = param - result.x;
                        }
                      }
                    }
                  }
                }
                this.resizeCell(cells[i], geo);
              }
            }
          }
        }
        this.fireEvent(new mxEventObject(mxEvent.ALIGN_CELLS, "align", align, "cells", cells));
      } finally {
        this.model.endUpdate();
      }
    }
  }
  return cells;
};
mxGraph.prototype.flipEdge = function(edge) {
  if (null != edge && null != this.alternateEdgeStyle) {
    this.model.beginUpdate();
    try {
      var style = this.model.getStyle(edge);
      if (null == style || 0 == style.length) {
        this.model.setStyle(edge, this.alternateEdgeStyle);
      } else {
        this.model.setStyle(edge, null);
      }
      this.resetEdge(edge);
      this.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, "edge", edge));
    } finally {
      this.model.endUpdate();
    }
  }
  return edge;
};
mxGraph.prototype.addImageBundle = function(bundle) {
  this.imageBundles.push(bundle);
};
mxGraph.prototype.removeImageBundle = function(bundle) {
  var tmp = [];
  for (var i = 0;i < this.imageBundles.length;i++) {
    if (this.imageBundles[i] != bundle) {
      tmp.push(this.imageBundles[i]);
    }
  }
  this.imageBundles = tmp;
};
mxGraph.prototype.getImageFromBundles = function(state) {
  if (null != state) {
    for (var i = 0;i < this.imageBundles.length;i++) {
      var image = this.imageBundles[i].getImage(state);
      if (null != image) {
        return image;
      }
    }
  }
  return null;
};
mxGraph.prototype.orderCells = function(back, cells, recurse) {
  if (null == cells) {
    cells = mxUtils.sortCells(this.getEditableCells(this.getSelectionCells()), true);
  }
  this.model.beginUpdate();
  try {
    this.cellsOrdered(cells, back, recurse);
    this.fireEvent(new mxEventObject(mxEvent.ORDER_CELLS, "back", back, "cells", cells, "increment", recurse));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph.prototype.cellsOrdered = function(cells, back, recurse) {
  if (null != cells) {
    this.model.beginUpdate();
    try {
      for (var i = 0;i < cells.length;i++) {
        var parent = this.model.getParent(cells[i]);
        if (back) {
          if (recurse) {
            this.model.add(parent, cells[i], Math.max(0, parent.getIndex(cells[i]) - 1));
          } else {
            this.model.add(parent, cells[i], i);
          }
        } else {
          if (recurse) {
            this.model.add(parent, cells[i], Math.min(this.model.getChildCount(parent) - 1, parent.getIndex(cells[i]) + 1));
          } else {
            this.model.add(parent, cells[i], this.model.getChildCount(parent) - 1);
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_ORDERED, "back", back, "cells", cells, "increment", recurse));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.groupCells = function(group, border, cells) {
  if (null == cells) {
    cells = mxUtils.sortCells(this.getSelectionCells(), true);
  }
  cells = this.getCellsForGroup(cells);
  if (null == group) {
    group = this.createGroupCell(cells);
  }
  var bounds = this.getBoundsForGroup(group, cells, border);
  if (1 < cells.length && null != bounds) {
    var parent = this.model.getParent(group);
    if (null == parent) {
      parent = this.model.getParent(cells[0]);
    }
    this.model.beginUpdate();
    try {
      if (null == this.getCellGeometry(group)) {
        this.model.setGeometry(group, new mxGeometry);
      }
      var index = this.model.getChildCount(parent);
      this.cellsAdded([group], parent, index, null, null, false, false, false);
      index = this.model.getChildCount(group);
      this.cellsAdded(cells, group, index, null, null, false, false, false);
      this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);
      this.cellsResized([group], [bounds], false);
      this.fireEvent(new mxEventObject(mxEvent.GROUP_CELLS, "group", group, "border", border, "cells", cells));
    } finally {
      this.model.endUpdate();
    }
  }
  return group;
};
mxGraph.prototype.getCellsForGroup = function(cells) {
  var result = [];
  if (null != cells && 0 < cells.length) {
    var c = this.model.getParent(cells[0]);
    result.push(cells[0]);
    for (var i = 1;i < cells.length;i++) {
      if (this.model.getParent(cells[i]) == c) {
        result.push(cells[i]);
      }
    }
  }
  return result;
};
mxGraph.prototype.getBoundsForGroup = function(tmp, result, border) {
  result = this.getBoundingBoxFromGeometry(result, true);
  if (null != result) {
    if (this.isSwimlane(tmp)) {
      tmp = this.getStartSize(tmp);
      result.x -= tmp.width;
      result.y -= tmp.height;
      result.width += tmp.width;
      result.height += tmp.height;
    }
    if (null != border) {
      result.x -= border;
      result.y -= border;
      result.width += 2 * border;
      result.height += 2 * border;
    }
  }
  return result;
};
mxGraph.prototype.createGroupCell = function(cells) {
  cells = new mxCell("");
  cells.setVertex(true);
  cells.setConnectable(false);
  return cells;
};
mxGraph.prototype.ungroupCells = function(cells) {
  var result = [];
  if (null == cells) {
    cells = this.getCellsForUngroup();
  }
  if (null != cells && 0 < cells.length) {
    this.model.beginUpdate();
    try {
      for (var j = 0;j < cells.length;j++) {
        var children = this.model.getChildren(cells[j]);
        if (null != children && 0 < children.length) {
          children = children.slice();
          var parent = this.model.getParent(cells[j]);
          var index = this.model.getChildCount(parent);
          this.cellsAdded(children, parent, index, null, null, true);
          result = result.concat(children);
          for (var i = 0;i < children.length;i++) {
            if (this.model.isVertex(children[i])) {
              var pstate = this.view.getState(children[i]);
              var geo = this.getCellGeometry(children[i]);
              if (null != pstate) {
                if (null != geo) {
                  if (geo.relative) {
                    geo = geo.clone();
                    geo.x = pstate.origin.x;
                    geo.y = pstate.origin.y;
                    geo.relative = false;
                    this.model.setGeometry(children[i], geo);
                  }
                }
              }
            }
          }
        }
      }
      this.removeCellsAfterUngroup(cells);
      this.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, "cells", cells));
    } finally {
      this.model.endUpdate();
    }
  }
  return result;
};
mxGraph.prototype.getCellsForUngroup = function() {
  var cells = this.getEditableCells(this.getSelectionCells());
  var tmp = [];
  for (var i = 0;i < cells.length;i++) {
    if (this.model.isVertex(cells[i])) {
      if (0 < this.model.getChildCount(cells[i])) {
        tmp.push(cells[i]);
      }
    }
  }
  return tmp;
};
mxGraph.prototype.removeCellsAfterUngroup = function(cells) {
  this.cellsRemoved(this.addAllEdges(cells));
};
mxGraph.prototype.removeCellsFromParent = function(cells) {
  if (null == cells) {
    cells = this.getSelectionCells();
  }
  this.model.beginUpdate();
  try {
    var parent = this.getDefaultParent();
    var index = this.model.getChildCount(parent);
    this.cellsAdded(cells, parent, index, null, null, true);
    this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, "cells", cells));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph.prototype.updateGroupBounds = function(cells, border, moveGroup, topBorder, rightBorder, bottomBorder, leftBorder) {
  if (null == cells) {
    cells = this.getSelectionCells();
  }
  border = null != border ? border : 0;
  moveGroup = null != moveGroup ? moveGroup : false;
  topBorder = null != topBorder ? topBorder : 0;
  rightBorder = null != rightBorder ? rightBorder : 0;
  bottomBorder = null != bottomBorder ? bottomBorder : 0;
  leftBorder = null != leftBorder ? leftBorder : 0;
  this.model.beginUpdate();
  try {
    for (var i = cells.length - 1;0 <= i;i--) {
      var geo = this.getCellGeometry(cells[i]);
      if (null != geo) {
        var children = this.getChildCells(cells[i]);
        if (null != children && 0 < children.length) {
          var bounds = this.getBoundingBoxFromGeometry(children, true);
          if (null != bounds && (0 < bounds.width && 0 < bounds.height)) {
            var size = this.isSwimlane(cells[i]) ? this.getActualStartSize(cells[i], true) : new mxRectangle;
            geo = geo.clone();
            if (moveGroup) {
              geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);
              geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);
            }
            geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);
            geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);
            this.model.setGeometry(cells[i], geo);
            this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);
          }
        }
      }
    }
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph.prototype.getBoundingBox = function(cells) {
  var result = null;
  if (null != cells && 0 < cells.length) {
    for (var i = 0;i < cells.length;i++) {
      if (this.model.isVertex(cells[i]) || this.model.isEdge(cells[i])) {
        var parent = this.view.getBoundingBox(this.view.getState(cells[i]), true);
        if (null != parent) {
          if (null == result) {
            result = mxRectangle.fromRectangle(parent);
          } else {
            result.add(parent);
          }
        }
      }
    }
  }
  return result;
};
mxGraph.prototype.cloneCell = function(cell, includeChildren, mapping, keepPosition) {
  return this.cloneCells([cell], includeChildren, mapping, keepPosition)[0];
};
mxGraph.prototype.cloneCells = function(cells, includeChildren, x, keepPosition) {
  includeChildren = null != includeChildren ? includeChildren : true;
  var clones = null;
  if (null != cells) {
    var dict = new mxDictionary;
    clones = [];
    for (var i = 0;i < cells.length;i++) {
      dict.put(cells[i], true);
      clones.push(cells[i]);
    }
    if (0 < clones.length) {
      var scale = this.view.scale;
      var tr = this.view.translate;
      clones = this.model.cloneCells(cells, true, x);
      for (i = 0;i < cells.length;i++) {
        if (!includeChildren && (this.model.isEdge(clones[i]) && null != this.getEdgeValidationError(clones[i], this.model.getTerminal(clones[i], true), this.model.getTerminal(clones[i], false)))) {
          clones[i] = null;
        } else {
          var points = this.model.getGeometry(clones[i]);
          if (null != points) {
            var j = this.view.getState(cells[i]);
            var y = this.view.getState(this.model.getParent(cells[i]));
            if (null != j && null != y) {
              if (x = keepPosition ? 0 : y.origin.x, y = keepPosition ? 0 : y.origin.y, this.model.isEdge(clones[i])) {
                if (j = j.absolutePoints, null != j) {
                  for (var cell = this.model.getTerminal(cells[i], true);null != cell && !dict.get(cell);) {
                    cell = this.model.getParent(cell);
                  }
                  if (null == cell) {
                    if (null != j[0]) {
                      points.setTerminalPoint(new mxPoint(j[0].x / scale - tr.x, j[0].y / scale - tr.y), true);
                    }
                  }
                  for (cell = this.model.getTerminal(cells[i], false);null != cell && !dict.get(cell);) {
                    cell = this.model.getParent(cell);
                  }
                  var n = j.length - 1;
                  if (null == cell) {
                    if (null != j[n]) {
                      points.setTerminalPoint(new mxPoint(j[n].x / scale - tr.x, j[n].y / scale - tr.y), false);
                    }
                  }
                  points = points.points;
                  if (null != points) {
                    for (j = 0;j < points.length;j++) {
                      points[j].x += x;
                      points[j].y += y;
                    }
                  }
                }
              } else {
                points.translate(x, y);
              }
            }
          }
        }
      }
    } else {
      clones = [];
    }
  }
  return clones;
};
mxGraph.prototype.insertVertex = function(parent, edge, value, x, y, width, height, style, relative) {
  edge = this.createVertex(parent, edge, value, x, y, width, height, style, relative);
  return this.addCell(edge, parent);
};
mxGraph.prototype.createVertex = function(result, id, vertex, x, y, width, height, style, relative) {
  result = new mxGeometry(x, y, width, height);
  result.relative = null != relative ? relative : false;
  vertex = new mxCell(vertex, result, style);
  vertex.setId(id);
  vertex.setVertex(true);
  vertex.setConnectable(true);
  return vertex;
};
mxGraph.prototype.insertEdge = function(parent, edge, value, source, target, style) {
  edge = this.createEdge(parent, edge, value, source, target, style);
  return this.addEdge(edge, parent, source, target);
};
mxGraph.prototype.createEdge = function(edge, id, target, source, to, style) {
  edge = new mxCell(target, new mxGeometry, style);
  edge.setId(id);
  edge.setEdge(true);
  edge.geometry.relative = true;
  return edge;
};
mxGraph.prototype.addEdge = function(edge, parent, source, target, index) {
  return this.addCell(edge, parent, index, source, target);
};
mxGraph.prototype.addCell = function(cell, parent, index, source, target) {
  return this.addCells([cell], parent, index, source, target)[0];
};
mxGraph.prototype.addCells = function(cells, parent, index, source, target, absolute) {
  if (null == parent) {
    parent = this.getDefaultParent();
  }
  if (null == index) {
    index = this.model.getChildCount(parent);
  }
  this.model.beginUpdate();
  try {
    this.cellsAdded(cells, parent, index, source, target, null != absolute ? absolute : false, true);
    this.fireEvent(new mxEventObject(mxEvent.ADD_CELLS, "cells", cells, "parent", parent, "index", index, "source", source, "target", target));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph.prototype.cellsAdded = function(cells, parent, index, source, target, absolute, constrain, layer) {
  if (null != cells && (null != parent && null != index)) {
    this.model.beginUpdate();
    try {
      var i = absolute ? this.view.getState(parent) : null;
      var o1 = null != i ? i.origin : null;
      var zero = new mxPoint(0, 0);
      for (i = 0;i < cells.length;i++) {
        if (null == cells[i]) {
          index--;
        } else {
          var previous = this.model.getParent(cells[i]);
          if (null != o1 && (cells[i] != parent && parent != previous)) {
            var oldState = this.view.getState(previous);
            var o2 = null != oldState ? oldState.origin : zero;
            var geo = this.model.getGeometry(cells[i]);
            if (null != geo) {
              var x = o2.x - o1.x;
              var y = o2.y - o1.y;
              geo = geo.clone();
              geo.translate(x, y);
              if (!geo.relative) {
                if (!!this.model.isVertex(cells[i])) {
                  if (!this.isAllowNegativeCoordinates()) {
                    geo.x = Math.max(0, geo.x);
                    geo.y = Math.max(0, geo.y);
                  }
                }
              }
              this.model.setGeometry(cells[i], geo);
            }
          }
          if (parent == previous) {
            if (index + i > this.model.getChildCount(parent)) {
              index--;
            }
          }
          this.model.add(parent, cells[i], index + i);
          if (this.autoSizeCellsOnAdd) {
            this.autoSizeCell(cells[i], true);
          }
          if (null == layer || layer) {
            if (this.isExtendParentsOnAdd(cells[i])) {
              if (this.isExtendParent(cells[i])) {
                this.extendParent(cells[i]);
              }
            }
          }
          if (null == constrain || constrain) {
            this.constrainChild(cells[i]);
          }
          if (null != source) {
            this.cellConnected(cells[i], source, true);
          }
          if (null != target) {
            this.cellConnected(cells[i], target, false);
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_ADDED, "cells", cells, "parent", parent, "index", index, "source", source, "target", target, "absolute", absolute));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.autoSizeCell = function(cell, recurse) {
  if (null != recurse ? recurse : 1) {
    recurse = this.model.getChildCount(cell);
    for (var i = 0;i < recurse;i++) {
      this.autoSizeCell(this.model.getChildAt(cell, i));
    }
  }
  if (this.getModel().isVertex(cell)) {
    if (this.isAutoSizeCell(cell)) {
      this.updateCellSize(cell);
    }
  }
};
mxGraph.prototype.removeCells = function(cells, includeEdges) {
  includeEdges = null != includeEdges ? includeEdges : true;
  if (null == cells) {
    cells = this.getDeletableCells(this.getSelectionCells());
  }
  if (includeEdges) {
    cells = this.getDeletableCells(this.addAllEdges(cells));
  } else {
    cells = cells.slice();
    var edges = this.getDeletableCells(this.getAllEdges(cells));
    var dict = new mxDictionary;
    for (var i = 0;i < cells.length;i++) {
      dict.put(cells[i], true);
    }
    for (i = 0;i < edges.length;i++) {
      if (!(null != this.view.getState(edges[i]))) {
        if (!dict.get(edges[i])) {
          dict.put(edges[i], true);
          cells.push(edges[i]);
        }
      }
    }
  }
  this.model.beginUpdate();
  try {
    this.cellsRemoved(cells);
    this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS, "cells", cells, "includeEdges", includeEdges));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph.prototype.cellsRemoved = function(cells) {
  if (null != cells && 0 < cells.length) {
    var scale = this.view.scale;
    var tr = this.view.translate;
    this.model.beginUpdate();
    try {
      var dict = new mxDictionary;
      for (var i = 0;i < cells.length;i++) {
        dict.put(cells[i], true);
      }
      for (i = 0;i < cells.length;i++) {
        var edges = this.getAllEdges([cells[i]]);
        var disconnectTerminal = mxUtils.bind(this, function(cell, source) {
          var geo = this.model.getGeometry(cell);
          if (null != geo) {
            var terminal = this.model.getTerminal(cell, source);
            var state = false;
            for (var tmp = terminal;null != tmp;) {
              if (cells[i] == tmp) {
                state = true;
                break;
              }
              tmp = this.model.getParent(tmp);
            }
            if (state) {
              geo = geo.clone();
              state = this.view.getState(cell);
              if (null != state && null != state.absolutePoints) {
                terminal = state.absolutePoints;
                tmp = source ? 0 : terminal.length - 1;
                geo.setTerminalPoint(new mxPoint(terminal[tmp].x / scale - tr.x - state.origin.x, terminal[tmp].y / scale - tr.y - state.origin.y), source);
              } else {
                terminal = this.view.getState(terminal);
                if (null != terminal) {
                  geo.setTerminalPoint(new mxPoint(terminal.getCenterX() / scale - tr.x, terminal.getCenterY() / scale - tr.y), source);
                }
              }
              this.model.setGeometry(cell, geo);
              this.model.setTerminal(cell, null, source);
            }
          }
        });
        for (var j = 0;j < edges.length;j++) {
          if (!dict.get(edges[j])) {
            dict.put(edges[j], true);
            disconnectTerminal(edges[j], true);
            disconnectTerminal(edges[j], false);
          }
        }
        this.model.remove(cells[i]);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, "cells", cells));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.splitEdge = function(edge, cells, newEdge, dx, dy, source, y, parent) {
  dx = dx || 0;
  dy = dy || 0;
  parent = null != parent ? parent : this.model.getParent(edge);
  source = this.model.getTerminal(edge, true);
  this.model.beginUpdate();
  try {
    if (null == newEdge) {
      newEdge = this.cloneCell(edge);
      var state = this.view.getState(edge);
      var geo = this.getCellGeometry(newEdge);
      if (null != geo && (null != geo.points && null != state)) {
        var t = this.view.translate;
        var s = this.view.scale;
        var idx = mxUtils.findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);
        geo.points = geo.points.slice(0, idx);
        geo = this.getCellGeometry(edge);
        if (null != geo) {
          if (null != geo.points) {
            geo = geo.clone();
            geo.points = geo.points.slice(idx);
            this.model.setGeometry(edge, geo);
          }
        }
      }
    }
    this.cellsMoved(cells, dx, dy, false, false);
    this.cellsAdded(cells, parent, this.model.getChildCount(parent), null, null, true);
    this.cellsAdded([newEdge], parent, this.model.getChildCount(parent), source, cells[0], false);
    this.cellConnected(edge, cells[0], true);
    this.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, "edge", edge, "cells", cells, "newEdge", newEdge, "dx", dx, "dy", dy));
  } finally {
    this.model.endUpdate();
  }
  return newEdge;
};
mxGraph.prototype.toggleCells = function(show, cells, includeEdges) {
  if (null == cells) {
    cells = this.getSelectionCells();
  }
  if (includeEdges) {
    cells = this.addAllEdges(cells);
  }
  this.model.beginUpdate();
  try {
    this.cellsToggled(cells, show);
    this.fireEvent(new mxEventObject(mxEvent.TOGGLE_CELLS, "show", show, "cells", cells, "includeEdges", includeEdges));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph.prototype.cellsToggled = function(cells, show) {
  if (null != cells && 0 < cells.length) {
    this.model.beginUpdate();
    try {
      for (var i = 0;i < cells.length;i++) {
        this.model.setVisible(cells[i], show);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.foldCells = function(collapse, recurse, cells, checkFoldable, evt) {
  recurse = null != recurse ? recurse : false;
  if (null == cells) {
    cells = this.getFoldableCells(this.getSelectionCells(), collapse);
  }
  this.stopEditing(false);
  this.model.beginUpdate();
  try {
    this.cellsFolded(cells, collapse, recurse, checkFoldable);
    this.fireEvent(new mxEventObject(mxEvent.FOLD_CELLS, "collapse", collapse, "recurse", recurse, "cells", cells));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph.prototype.cellsFolded = function(cells, collapse, recurse, checkFoldable) {
  if (null != cells && 0 < cells.length) {
    this.model.beginUpdate();
    try {
      for (var i = 0;i < cells.length;i++) {
        if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) && collapse != this.isCellCollapsed(cells[i])) {
          this.model.setCollapsed(cells[i], collapse);
          this.swapBounds(cells[i], collapse);
          if (this.isExtendParent(cells[i])) {
            this.extendParent(cells[i]);
          }
          if (recurse) {
            var children = this.model.getChildren(cells[i]);
            this.cellsFolded(children, collapse, recurse);
          }
          this.constrainChild(cells[i]);
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_FOLDED, "cells", cells, "collapse", collapse, "recurse", recurse));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.swapBounds = function(cell, willCollapse) {
  if (null != cell) {
    var geo = this.model.getGeometry(cell);
    if (null != geo) {
      geo = geo.clone();
      this.updateAlternateBounds(cell, geo, willCollapse);
      geo.swap();
      this.model.setGeometry(cell, geo);
    }
  }
};
mxGraph.prototype.updateAlternateBounds = function(cell, geo, style) {
  if (null != cell && null != geo) {
    style = this.getCurrentCellStyle(cell);
    if (null == geo.alternateBounds) {
      var bounds = geo;
      if (this.collapseToPreferredSize) {
        cell = this.getPreferredSizeForCell(cell);
        if (null != cell) {
          bounds = cell;
          cell = mxUtils.getValue(style, mxConstants.STYLE_STARTSIZE);
          if (0 < cell) {
            bounds.height = Math.max(bounds.height, cell);
          }
        }
      }
      geo.alternateBounds = new mxRectangle(0, 0, bounds.width, bounds.height);
    }
    if (null != geo.alternateBounds) {
      geo.alternateBounds.x = geo.x;
      geo.alternateBounds.y = geo.y;
      var rad = mxUtils.toRadians(style[mxConstants.STYLE_ROTATION] || 0);
      if (0 != rad) {
        style = geo.alternateBounds.getCenterX() - geo.getCenterX();
        bounds = geo.alternateBounds.getCenterY() - geo.getCenterY();
        cell = Math.cos(rad);
        rad = Math.sin(rad);
        geo.alternateBounds.x += cell * style - rad * bounds - style;
        geo.alternateBounds.y += rad * style + cell * bounds - bounds;
      }
    }
  }
};
mxGraph.prototype.addAllEdges = function(cells) {
  var allCells = cells.slice();
  return mxUtils.removeDuplicates(allCells.concat(this.getAllEdges(cells)));
};
mxGraph.prototype.getAllEdges = function(cells) {
  var edges = [];
  if (null != cells) {
    for (var i = 0;i < cells.length;i++) {
      var children = this.model.getEdgeCount(cells[i]);
      for (var j = 0;j < children;j++) {
        edges.push(this.model.getEdgeAt(cells[i], j));
      }
      children = this.model.getChildren(cells[i]);
      edges = edges.concat(this.getAllEdges(children));
    }
  }
  return edges;
};
mxGraph.prototype.updateCellSize = function(cell, ignoreChildren) {
  ignoreChildren = null != ignoreChildren ? ignoreChildren : false;
  this.model.beginUpdate();
  try {
    this.cellSizeUpdated(cell, ignoreChildren);
    this.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE, "cell", cell, "ignoreChildren", ignoreChildren));
  } finally {
    this.model.endUpdate();
  }
  return cell;
};
mxGraph.prototype.cellSizeUpdated = function(cell, ignoreChildren) {
  if (null != cell) {
    this.model.beginUpdate();
    try {
      var terminal = this.getCellStyle(cell);
      var geo = this.model.getGeometry(cell);
      if (null != geo) {
        var fontSize = null;
        var tstate = mxUtils.getValue(terminal, mxConstants.STYLE_FIXED_WIDTH, false);
        if (tstate) {
          fontSize = geo.width - 2 * parseFloat(mxUtils.getValue(terminal, mxConstants.STYLE_SPACING, 2)) - parseFloat(mxUtils.getValue(terminal, mxConstants.STYLE_SPACING_LEFT, 0)) - parseFloat(mxUtils.getValue(terminal, mxConstants.STYLE_SPACING_RIGHT, 0));
        }
        var size = this.getPreferredSizeForCell(cell, fontSize);
        if (null != size) {
          var collapsed = this.isCellCollapsed(cell);
          geo = geo.clone();
          if (this.isSwimlane(cell)) {
            var style = this.model.getStyle(cell);
            if (null == style) {
              style = "";
            }
            if (mxUtils.getValue(terminal, mxConstants.STYLE_HORIZONTAL, true)) {
              style = mxUtils.setStyle(style, mxConstants.STYLE_STARTSIZE, size.height + 8);
              if (collapsed) {
                geo.height = size.height + 8;
              }
              if (!tstate) {
                geo.width = size.width;
              }
            } else {
              style = mxUtils.setStyle(style, mxConstants.STYLE_STARTSIZE, size.width + 8);
              if (collapsed) {
                if (!tstate) {
                  geo.width = size.width + 8;
                }
              }
              geo.height = size.height;
            }
            this.model.setStyle(cell, style);
          } else {
            var state = this.view.createState(cell);
            var align = state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER;
            var valign = this.getVerticalAlign(state);
            if ("fixed" == state.style[mxConstants.STYLE_ASPECT]) {
              size.height = Math.round(geo.height * size.width * 100 / geo.width) / 100;
            }
            if (valign == mxConstants.ALIGN_BOTTOM) {
              geo.y += geo.height - size.height;
            } else {
              if (valign == mxConstants.ALIGN_MIDDLE) {
                geo.y += Math.round((geo.height - size.height) / 2);
              }
            }
            geo.height = size.height;
            if (!tstate) {
              if (align == mxConstants.ALIGN_RIGHT) {
                geo.x += geo.width - size.width;
              } else {
                if (align == mxConstants.ALIGN_CENTER) {
                  geo.x += Math.round((geo.width - size.width) / 2);
                }
              }
              geo.width = size.width;
            }
          }
          if (!ignoreChildren && !collapsed) {
            var bounds = this.view.getBounds(this.model.getChildren(cell));
            if (null != bounds) {
              var tr = this.view.translate;
              var scale = this.view.scale;
              var width = (bounds.x + bounds.width) / scale - geo.x - tr.x;
              geo.height = Math.max(geo.height, (bounds.y + bounds.height) / scale - geo.y - tr.y);
              if (!tstate) {
                geo.width = Math.max(geo.width, width);
              }
            }
          }
          this.cellsResized([cell], [geo], false);
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.getPreferredSizeForCell = function(cell, width) {
  var result = null;
  if (null != cell) {
    var state = this.view.createState(cell);
    var style = state.style;
    if (!this.model.isEdge(cell)) {
      var fontSize = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;
      cell = result = 0;
      if (!(null == this.getImage(state) && null == style[mxConstants.STYLE_IMAGE])) {
        if (!(style[mxConstants.STYLE_SHAPE] != mxConstants.SHAPE_LABEL)) {
          if (style[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE) {
            result += parseFloat(mxUtils.getValue(style, mxConstants.STYLE_IMAGE_WIDTH, mxLabel.prototype.imageSize));
          }
          if (style[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER) {
            cell += parseFloat(mxUtils.getValue(style, mxConstants.STYLE_IMAGE_HEIGHT, mxLabel.prototype.imageSize));
          }
        }
      }
      result += 2 * parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING, 2));
      result += parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_LEFT, 2));
      result += parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_RIGHT, 2));
      cell += 2 * parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING, 2));
      cell += parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_TOP, 2));
      cell += parseFloat(mxUtils.getValue(style, mxConstants.STYLE_SPACING_BOTTOM, 2));
      var value = this.getFoldingImage(state);
      if (null != value) {
        result += value.width + 8;
      }
      value = this.cellRenderer.getLabelValue(state);
      if (null != value && 0 < value.length) {
        if (this.isHtmlLabel(state.cell)) {
          if (null != width) {
            width += mxSvgCanvas2D.prototype.foreignObjectPadding;
          }
        } else {
          value = mxUtils.htmlEntities(value, false);
        }
        value = value.replace(/\n/g, "<br>");
        state = mxUtils.getSizeForString(value, fontSize, style[mxConstants.STYLE_FONTFAMILY], width, style[mxConstants.STYLE_FONTSTYLE]);
        width = state.width + result;
        state = state.height + cell;
        if (!mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true)) {
          style = state;
          state = width;
          width = style;
        }
        if (this.gridEnabled) {
          width = this.snap(width + this.gridSize / 2);
          state = this.snap(state + this.gridSize / 2);
        }
        result = new mxRectangle(0, 0, width, state);
      } else {
        style = 4 * this.gridSize;
        result = new mxRectangle(0, 0, style, style);
      }
    }
  }
  return result;
};
mxGraph.prototype.resizeCell = function(cell, bounds, recurse) {
  return this.resizeCells([cell], [bounds], recurse)[0];
};
mxGraph.prototype.resizeCells = function(cells, bounds, recurse) {
  recurse = null != recurse ? recurse : this.isRecursiveResize();
  this.model.beginUpdate();
  try {
    var prev = this.cellsResized(cells, bounds, recurse);
    this.fireEvent(new mxEventObject(mxEvent.RESIZE_CELLS, "cells", cells, "bounds", bounds, "previous", prev));
  } finally {
    this.model.endUpdate();
  }
  return cells;
};
mxGraph.prototype.cellsResized = function(cells, bounds, recurse) {
  recurse = null != recurse ? recurse : false;
  var prev = [];
  if (null != cells && (null != bounds && cells.length == bounds.length)) {
    this.model.beginUpdate();
    try {
      for (var i = 0;i < cells.length;i++) {
        prev.push(this.cellResized(cells[i], bounds[i], false, recurse));
        if (this.isExtendParent(cells[i])) {
          this.extendParent(cells[i]);
        }
        this.constrainChild(cells[i]);
      }
      if (this.resetEdgesOnResize) {
        this.resetEdges(cells);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_RESIZED, "cells", cells, "bounds", bounds, "previous", prev));
    } finally {
      this.model.endUpdate();
    }
  }
  return prev;
};
mxGraph.prototype.cellResized = function(cell, bounds, ignoreRelative, recurse) {
  var prev = this.model.getGeometry(cell);
  if (null != prev && (prev.x != bounds.x || (prev.y != bounds.y || (prev.width != bounds.width || prev.height != bounds.height)))) {
    var geo = prev.clone();
    if (!ignoreRelative && geo.relative) {
      ignoreRelative = geo.offset;
      if (null != ignoreRelative) {
        ignoreRelative.x += bounds.x - geo.x;
        ignoreRelative.y += bounds.y - geo.y;
      }
    } else {
      geo.x = bounds.x;
      geo.y = bounds.y;
    }
    geo.width = bounds.width;
    geo.height = bounds.height;
    if (!geo.relative) {
      if (!!this.model.isVertex(cell)) {
        if (!this.isAllowNegativeCoordinates()) {
          geo.x = Math.max(0, geo.x);
          geo.y = Math.max(0, geo.y);
        }
      }
    }
    this.model.beginUpdate();
    try {
      if (recurse) {
        this.resizeChildCells(cell, geo);
      }
      this.model.setGeometry(cell, geo);
      this.constrainChildCells(cell);
    } finally {
      this.model.endUpdate();
    }
  }
  return prev;
};
mxGraph.prototype.resizeChildCells = function(cell, newGeo) {
  var geo = this.model.getGeometry(cell);
  var dx = 0 != geo.width ? newGeo.width / geo.width : 1;
  newGeo = 0 != geo.height ? newGeo.height / geo.height : 1;
  geo = this.model.getChildCount(cell);
  for (var i = 0;i < geo;i++) {
    this.scaleCell(this.model.getChildAt(cell, i), dx, newGeo, true);
  }
};
mxGraph.prototype.constrainChildCells = function(cell) {
  var childCount = this.model.getChildCount(cell);
  for (var i = 0;i < childCount;i++) {
    this.constrainChild(this.model.getChildAt(cell, i));
  }
};
mxGraph.prototype.scaleCell = function(cell, dx, dy, recurse) {
  var geo = this.model.getGeometry(cell);
  if (null != geo) {
    var style = this.getCurrentCellStyle(cell);
    geo = geo.clone();
    var x = geo.x;
    var y = geo.y;
    var w = geo.width;
    var h = geo.height;
    geo.scale(dx, dy, "fixed" == style[mxConstants.STYLE_ASPECT]);
    if ("1" == style[mxConstants.STYLE_RESIZE_WIDTH]) {
      geo.width = w * dx;
    } else {
      if ("0" == style[mxConstants.STYLE_RESIZE_WIDTH]) {
        geo.width = w;
      }
    }
    if ("1" == style[mxConstants.STYLE_RESIZE_HEIGHT]) {
      geo.height = h * dy;
    } else {
      if ("0" == style[mxConstants.STYLE_RESIZE_HEIGHT]) {
        geo.height = h;
      }
    }
    if (!this.isCellMovable(cell)) {
      geo.x = x;
      geo.y = y;
    }
    if (!this.isCellResizable(cell)) {
      geo.width = w;
      geo.height = h;
    }
    if (this.model.isVertex(cell)) {
      this.cellResized(cell, geo, true, recurse);
    } else {
      this.model.setGeometry(cell, geo);
    }
  }
};
mxGraph.prototype.extendParent = function(tmp) {
  if (null != tmp) {
    var cell = this.model.getParent(tmp);
    var p = this.getCellGeometry(cell);
    if (!(null == cell)) {
      if (!(null == p)) {
        if (!this.isCellCollapsed(cell)) {
          tmp = this.getCellGeometry(tmp);
          if (null != tmp) {
            if (!tmp.relative) {
              if (p.width < tmp.x + tmp.width || p.height < tmp.y + tmp.height) {
                p = p.clone();
                p.width = Math.max(p.width, tmp.x + tmp.width);
                p.height = Math.max(p.height, tmp.y + tmp.height);
                this.cellsResized([cell], [p], false);
              }
            }
          }
        }
      }
    }
  }
};
mxGraph.prototype.importCells = function(cells, dx, dy, target, evt, mapping) {
  return this.moveCells(cells, dx, dy, true, target, evt, mapping);
};
mxGraph.prototype.moveCells = function(cells, dx, dy, clone, target, evt, mapping) {
  dx = null != dx ? dx : 0;
  dy = null != dy ? dy : 0;
  clone = null != clone ? clone : false;
  if (null != cells && (0 != dx || (0 != dy || (clone || null != target)))) {
    var origCells = cells = this.model.getTopmostCells(cells);
    this.model.beginUpdate();
    try {
      var dict = new mxDictionary;
      for (var i = 0;i < cells.length;i++) {
        dict.put(cells[i], true);
      }
      var isSelected = mxUtils.bind(this, function(cell) {
        for (;null != cell;) {
          if (dict.get(cell)) {
            return true;
          }
          cell = this.model.getParent(cell);
        }
        return false;
      });
      var checked = [];
      for (i = 0;i < cells.length;i++) {
        var geo = this.getCellGeometry(cells[i]);
        var parent = this.model.getParent(cells[i]);
        if (!(null != geo && (geo.relative && (this.model.isEdge(parent) && (isSelected(this.model.getTerminal(parent, true)) || isSelected(this.model.getTerminal(parent, false))))))) {
          checked.push(cells[i]);
        }
      }
      cells = checked;
      if (clone) {
        cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);
        if (null == target) {
          target = this.getDefaultParent();
        }
      }
      var sx = this.isAllowNegativeCoordinates();
      if (null != target) {
        this.setAllowNegativeCoordinates(true);
      }
      this.cellsMoved(cells, dx, dy, !clone && (this.isDisconnectOnMove() && this.isAllowDanglingEdges()), null == target, this.isExtendParentsOnMove() && null == target);
      this.setAllowNegativeCoordinates(sx);
      if (null != target) {
        var index = this.model.getChildCount(target);
        this.cellsAdded(cells, target, index, null, null, true);
        if (clone) {
          for (i = 0;i < cells.length;i++) {
            geo = this.getCellGeometry(cells[i]);
            parent = this.model.getParent(origCells[i]);
            if (null != geo) {
              if (geo.relative) {
                if (this.model.isEdge(parent)) {
                  if (this.model.contains(parent)) {
                    this.model.add(parent, cells[i]);
                  }
                }
              }
            }
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.MOVE_CELLS, "cells", cells, "dx", dx, "dy", dy, "clone", clone, "target", target, "event", evt));
    } finally {
      this.model.endUpdate();
    }
  }
  return cells;
};
mxGraph.prototype.cellsMoved = function(cells, dx, dy, disconnect, layer, extend) {
  if (null != cells && (0 != dx || 0 != dy)) {
    extend = null != extend ? extend : false;
    this.model.beginUpdate();
    try {
      if (disconnect) {
        this.disconnectGraph(cells);
      }
      for (var i = 0;i < cells.length;i++) {
        this.translateCell(cells[i], dx, dy);
        if (extend && this.isExtendParent(cells[i])) {
          this.extendParent(cells[i]);
        } else {
          if (layer) {
            this.constrainChild(cells[i]);
          }
        }
      }
      if (this.resetEdgesOnMove) {
        this.resetEdges(cells);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_MOVED, "cells", cells, "dx", dx, "dy", dy, "disconnect", disconnect));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.translateCell = function(cell, x, y) {
  var geo = this.model.getGeometry(cell);
  if (null != geo) {
    x = parseFloat(x);
    y = parseFloat(y);
    geo = geo.clone();
    geo.translate(x, y);
    if (!geo.relative) {
      if (!!this.model.isVertex(cell)) {
        if (!this.isAllowNegativeCoordinates()) {
          geo.x = Math.max(0, parseFloat(geo.x));
          geo.y = Math.max(0, parseFloat(geo.y));
        }
      }
    }
    if (geo.relative && !this.model.isEdge(cell)) {
      var parent = this.model.getParent(cell);
      var rad = 0;
      if (this.model.isVertex(parent)) {
        parent = this.getCurrentCellStyle(parent);
        rad = mxUtils.getValue(parent, mxConstants.STYLE_ROTATION, 0);
      }
      if (0 != rad) {
        rad = mxUtils.toRadians(-rad);
        parent = Math.cos(rad);
        rad = Math.sin(rad);
        y = mxUtils.getRotatedPoint(new mxPoint(x, y), parent, rad, new mxPoint(0, 0));
        x = y.x;
        y = y.y;
      }
      if (null == geo.offset) {
        geo.offset = new mxPoint(Math.round(x), Math.round(y));
      } else {
        geo.offset.x = Math.round(parseFloat(geo.offset.x + x));
        geo.offset.y = Math.round(parseFloat(geo.offset.y + y));
      }
    }
    this.model.setGeometry(cell, geo);
  }
};
mxGraph.prototype.getCellContainmentArea = function(tmp) {
  if (null != tmp && !this.model.isEdge(tmp)) {
    var cell = this.model.getParent(tmp);
    if (null != cell && cell != this.getDefaultParent()) {
      var geo = this.model.getGeometry(cell);
      if (null != geo) {
        var y = tmp = 0;
        var w = geo.width;
        geo = geo.height;
        if (this.isSwimlane(cell)) {
          var size = this.getStartSize(cell);
          var style = this.getCurrentCellStyle(cell);
          cell = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
          var k = 1 == mxUtils.getValue(style, mxConstants.STYLE_FLIPH, 0);
          style = 1 == mxUtils.getValue(style, mxConstants.STYLE_FLIPV, 0);
          if (cell == mxConstants.DIRECTION_SOUTH || cell == mxConstants.DIRECTION_NORTH) {
            var height = size.width;
            size.width = size.height;
            size.height = height;
          }
          if (cell == mxConstants.DIRECTION_EAST && !style || (cell == mxConstants.DIRECTION_NORTH && !k || (cell == mxConstants.DIRECTION_WEST && style || cell == mxConstants.DIRECTION_SOUTH && k))) {
            tmp = size.width;
            y = size.height;
          }
          w -= size.width;
          geo -= size.height;
        }
        return new mxRectangle(tmp, y, w, geo);
      }
    }
  }
  return null;
};
mxGraph.prototype.getMaximumGraphBounds = function() {
  return this.maximumGraphBounds;
};
mxGraph.prototype.constrainChild = function(cell, geo) {
  if (null != cell && (geo = this.getCellGeometry(cell), null != geo && (this.isConstrainRelativeChildren() || !geo.relative))) {
    var tmp = this.model.getParent(cell);
    this.getCellGeometry(tmp);
    var max = this.getMaximumGraphBounds();
    if (null != max) {
      tmp = this.getBoundingBoxFromGeometry([tmp], false);
      if (null != tmp) {
        max = mxRectangle.fromRectangle(max);
        max.x -= tmp.x;
        max.y -= tmp.y;
      }
    }
    if (this.isConstrainChild(cell) && (tmp = this.getCellContainmentArea(cell), null != tmp)) {
      var overlap = this.getOverlap(cell);
      if (0 < overlap) {
        tmp = mxRectangle.fromRectangle(tmp);
        tmp.x -= tmp.width * overlap;
        tmp.y -= tmp.height * overlap;
        tmp.width += 2 * tmp.width * overlap;
        tmp.height += 2 * tmp.height * overlap;
      }
      if (null == max) {
        max = tmp;
      } else {
        max = mxRectangle.fromRectangle(max);
        max.intersect(tmp);
      }
    }
    if (null != max) {
      tmp = [cell];
      if (!this.isCellCollapsed(cell)) {
        overlap = this.model.getDescendants(cell);
        for (var i = 0;i < overlap.length;i++) {
          if (this.isCellVisible(overlap[i])) {
            tmp.push(overlap[i]);
          }
        }
      }
      tmp = this.getBoundingBoxFromGeometry(tmp, false);
      if (null != tmp) {
        geo = geo.clone();
        overlap = 0;
        if (geo.width > max.width) {
          overlap = geo.width - max.width;
          geo.width -= overlap;
        }
        if (tmp.x + tmp.width > max.x + max.width) {
          overlap -= tmp.x + tmp.width - max.x - max.width - overlap;
        }
        i = 0;
        if (geo.height > max.height) {
          i = geo.height - max.height;
          geo.height -= i;
        }
        if (tmp.y + tmp.height > max.y + max.height) {
          i -= tmp.y + tmp.height - max.y - max.height - i;
        }
        if (tmp.x < max.x) {
          overlap -= tmp.x - max.x;
        }
        if (tmp.y < max.y) {
          i -= tmp.y - max.y;
        }
        if (0 != overlap || 0 != i) {
          if (geo.relative) {
            if (null == geo.offset) {
              geo.offset = new mxPoint;
            }
            geo.offset.x += overlap;
            geo.offset.y += i;
          } else {
            geo.x += overlap;
            geo.y += i;
          }
        }
        this.model.setGeometry(cell, geo);
      }
    }
  }
};
mxGraph.prototype.resetEdges = function(cells) {
  if (null != cells) {
    var dict = new mxDictionary;
    for (var i = 0;i < cells.length;i++) {
      dict.put(cells[i], true);
    }
    this.model.beginUpdate();
    try {
      for (i = 0;i < cells.length;i++) {
        var edges = this.model.getEdges(cells[i]);
        if (null != edges) {
          for (var j = 0;j < edges.length;j++) {
            var state = this.view.getState(edges[j]);
            var cell = null != state ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[j], true);
            var source = null != state ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[j], false);
            if (!(dict.get(cell) && dict.get(source))) {
              this.resetEdge(edges[j]);
            }
          }
        }
        this.resetEdges(this.model.getChildren(cells[i]));
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.resetEdge = function(edge) {
  var geo = this.model.getGeometry(edge);
  if (null != geo) {
    if (null != geo.points) {
      if (0 < geo.points.length) {
        geo = geo.clone();
        geo.points = [];
        this.model.setGeometry(edge, geo);
      }
    }
  }
  return edge;
};
mxGraph.prototype.getOutlineConstraint = function(point, terminalState, bounds) {
  if (null != terminalState.shape) {
    bounds = this.view.getPerimeterBounds(terminalState);
    var direction = terminalState.style[mxConstants.STYLE_DIRECTION];
    if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) {
      bounds.x += bounds.width / 2 - bounds.height / 2;
      bounds.y += bounds.height / 2 - bounds.width / 2;
      var cos = bounds.width;
      bounds.width = bounds.height;
      bounds.height = cos;
    }
    var sin = mxUtils.toRadians(terminalState.shape.getShapeRotation());
    if (0 != sin) {
      cos = Math.cos(-sin);
      sin = Math.sin(-sin);
      var cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());
      point = mxUtils.getRotatedPoint(point, cos, sin, cx);
    }
    cx = sin = 1;
    var dx = 0;
    var dy = 0;
    if (this.getModel().isVertex(terminalState.cell)) {
      var flipH = terminalState.style[mxConstants.STYLE_FLIPH];
      var flipV = terminalState.style[mxConstants.STYLE_FLIPV];
      if (null != terminalState.shape) {
        if (null != terminalState.shape.stencil) {
          flipH = 1 == mxUtils.getValue(terminalState.style, "stencilFlipH", 0) || flipH;
          flipV = 1 == mxUtils.getValue(terminalState.style, "stencilFlipV", 0) || flipV;
        }
      }
      if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) {
        cos = flipH;
        flipH = flipV;
        flipV = cos;
      }
      if (flipH) {
        sin = -1;
        dx = -bounds.width;
      }
      if (flipV) {
        cx = -1;
        dy = -bounds.height;
      }
    }
    point = new mxPoint((point.x - bounds.x) * sin - dx + bounds.x, (point.y - bounds.y) * cx - dy + bounds.y);
    return new mxConnectionConstraint(new mxPoint(0 == bounds.width ? 0 : Math.round(1E3 * (point.x - bounds.x) / bounds.width) / 1E3, 0 == bounds.height ? 0 : Math.round(1E3 * (point.y - bounds.y) / bounds.height) / 1E3), false);
  }
  return null;
};
mxGraph.prototype.getAllConnectionConstraints = function(state, mainLoopIteration) {
  return null != state && (null != state.shape && null != state.shape.stencil) ? state.shape.stencil.constraints : null;
};
mxGraph.prototype.getConnectionConstraint = function(edge, cell, source) {
  cell = null;
  var x = edge.style[source ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
  if (null != x) {
    var dx = edge.style[source ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
    if (null != dx) {
      cell = new mxPoint(parseFloat(x), parseFloat(dx));
    }
  }
  x = false;
  var dy = dx = 0;
  if (null != cell) {
    x = mxUtils.getValue(edge.style, source ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, true);
    dx = parseFloat(edge.style[source ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX]);
    dy = parseFloat(edge.style[source ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY]);
    dx = isFinite(dx) ? dx : 0;
    dy = isFinite(dy) ? dy : 0;
  }
  return new mxConnectionConstraint(cell, x, null, dx, dy);
};
mxGraph.prototype.setConnectionConstraint = function(edge, terminal, source, constraint) {
  if (null != constraint) {
    this.model.beginUpdate();
    try {
      if (null == constraint || null == constraint.point) {
        this.setCellStyles(source ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, null, [edge]);
        this.setCellStyles(source ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, null, [edge]);
        this.setCellStyles(source ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, null, [edge]);
        this.setCellStyles(source ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, null, [edge]);
        this.setCellStyles(source ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);
      } else {
        if (null != constraint.point) {
          this.setCellStyles(source ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, constraint.point.x, [edge]);
          this.setCellStyles(source ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, constraint.point.y, [edge]);
          this.setCellStyles(source ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, constraint.dx, [edge]);
          this.setCellStyles(source ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, constraint.dy, [edge]);
          if (constraint.perimeter) {
            this.setCellStyles(source ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);
          } else {
            this.setCellStyles(source ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, "0", [edge]);
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.getConnectionPoint = function(terminal, constraint, round) {
  round = null != round ? round : true;
  var point = null;
  if (null != terminal && null != constraint.point) {
    var bounds = this.view.getPerimeterBounds(terminal);
    var cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());
    var sin = terminal.style[mxConstants.STYLE_DIRECTION];
    var target = 0;
    if (null != sin) {
      if (1 == mxUtils.getValue(terminal.style, mxConstants.STYLE_ANCHOR_POINT_DIRECTION, 1)) {
        if (sin == mxConstants.DIRECTION_NORTH) {
          target += 270;
        } else {
          if (sin == mxConstants.DIRECTION_WEST) {
            target += 180;
          } else {
            if (sin == mxConstants.DIRECTION_SOUTH) {
              target += 90;
            }
          }
        }
        if (!(sin != mxConstants.DIRECTION_NORTH && sin != mxConstants.DIRECTION_SOUTH)) {
          bounds.rotate90();
        }
      }
    }
    point = this.view.scale;
    point = new mxPoint(bounds.x + constraint.point.x * bounds.width + constraint.dx * point, bounds.y + constraint.point.y * bounds.height + constraint.dy * point);
    var rotation = terminal.style[mxConstants.STYLE_ROTATION] || 0;
    if (constraint.perimeter) {
      if (0 != target) {
        sin = bounds = 0;
        if (90 == target) {
          sin = 1;
        } else {
          if (180 == target) {
            bounds = -1;
          } else {
            if (270 == target) {
              sin = -1;
            }
          }
        }
        point = mxUtils.getRotatedPoint(point, bounds, sin, cx);
      }
      point = this.view.getPerimeterPoint(terminal, point, false);
    } else {
      if (rotation += target, this.getModel().isVertex(terminal.cell)) {
        target = 1 == terminal.style[mxConstants.STYLE_FLIPH];
        constraint = 1 == terminal.style[mxConstants.STYLE_FLIPV];
        if (null != terminal.shape) {
          if (null != terminal.shape.stencil) {
            target = 1 == mxUtils.getValue(terminal.style, "stencilFlipH", 0) || target;
            constraint = 1 == mxUtils.getValue(terminal.style, "stencilFlipV", 0) || constraint;
          }
        }
        if (sin == mxConstants.DIRECTION_NORTH || sin == mxConstants.DIRECTION_SOUTH) {
          terminal = target;
          target = constraint;
          constraint = terminal;
        }
        if (target) {
          point.x = 2 * bounds.getCenterX() - point.x;
        }
        if (constraint) {
          point.y = 2 * bounds.getCenterY() - point.y;
        }
      }
    }
    if (0 != rotation) {
      if (null != point) {
        terminal = mxUtils.toRadians(rotation);
        bounds = Math.cos(terminal);
        sin = Math.sin(terminal);
        point = mxUtils.getRotatedPoint(point, bounds, sin, cx);
      }
    }
  }
  if (round) {
    if (null != point) {
      point.x = Math.round(point.x);
      point.y = Math.round(point.y);
    }
  }
  return point;
};
mxGraph.prototype.connectCell = function(edge, terminal, source, constraint) {
  this.model.beginUpdate();
  try {
    var previous = this.model.getTerminal(edge, source);
    this.cellConnected(edge, terminal, source, constraint);
    this.fireEvent(new mxEventObject(mxEvent.CONNECT_CELL, "edge", edge, "terminal", terminal, "source", source, "previous", previous));
  } finally {
    this.model.endUpdate();
  }
  return edge;
};
mxGraph.prototype.cellConnected = function(edge, terminal, source, constraint) {
  if (null != edge) {
    this.model.beginUpdate();
    try {
      var previous = this.model.getTerminal(edge, source);
      this.setConnectionConstraint(edge, terminal, source, constraint);
      if (this.isPortsEnabled()) {
        constraint = null;
        if (this.isPort(terminal)) {
          constraint = terminal.getId();
          terminal = this.getTerminalForPort(terminal, source);
        }
        this.setCellStyles(source ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT, constraint, [edge]);
      }
      this.model.setTerminal(edge, terminal, source);
      if (this.resetEdgesOnConnect) {
        this.resetEdge(edge);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELL_CONNECTED, "edge", edge, "terminal", terminal, "source", source, "previous", previous));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.disconnectGraph = function(cells) {
  if (null != cells) {
    this.model.beginUpdate();
    try {
      var scale = this.view.scale;
      var tr = this.view.translate;
      var dict = new mxDictionary;
      for (var i = 0;i < cells.length;i++) {
        dict.put(cells[i], true);
      }
      for (i = 0;i < cells.length;i++) {
        if (this.model.isEdge(cells[i])) {
          var geo = this.model.getGeometry(cells[i]);
          if (null != geo) {
            var state = this.view.getState(cells[i]);
            var pstate = this.view.getState(this.model.getParent(cells[i]));
            if (null != state && null != pstate) {
              geo = geo.clone();
              var dx = -pstate.origin.x;
              var dy = -pstate.origin.y;
              var pts = state.absolutePoints;
              var cell = this.model.getTerminal(cells[i], true);
              if (null != cell && this.isCellDisconnectable(cells[i], cell, true)) {
                for (;null != cell && !dict.get(cell);) {
                  cell = this.model.getParent(cell);
                }
                if (null == cell) {
                  geo.setTerminalPoint(new mxPoint(pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);
                  this.model.setTerminal(cells[i], null, true);
                }
              }
              var terminal = this.model.getTerminal(cells[i], false);
              if (null != terminal && this.isCellDisconnectable(cells[i], terminal, false)) {
                for (;null != terminal && !dict.get(terminal);) {
                  terminal = this.model.getParent(terminal);
                }
                if (null == terminal) {
                  var n = pts.length - 1;
                  geo.setTerminalPoint(new mxPoint(pts[n].x / scale - tr.x + dx, pts[n].y / scale - tr.y + dy), false);
                  this.model.setTerminal(cells[i], null, false);
                }
              }
              this.model.setGeometry(cells[i], geo);
            }
          }
        }
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.getCurrentRoot = function() {
  return this.view.currentRoot;
};
mxGraph.prototype.getTranslateForRoot = function(cell) {
  return null;
};
mxGraph.prototype.isPort = function(cell) {
  return false;
};
mxGraph.prototype.getTerminalForPort = function(cell, source) {
  return this.model.getParent(cell);
};
mxGraph.prototype.getChildOffsetForCell = function(cell) {
  return null;
};
mxGraph.prototype.enterGroup = function(cell) {
  cell = cell || this.getSelectionCell();
  if (null != cell) {
    if (this.isValidRoot(cell)) {
      this.view.setCurrentRoot(cell);
      this.clearSelection();
    }
  }
};
mxGraph.prototype.exitGroup = function() {
  var root = this.model.getRoot();
  var current = this.getCurrentRoot();
  if (null != current) {
    for (var next = this.model.getParent(current);next != root && (!this.isValidRoot(next) && this.model.getParent(next) != root);) {
      next = this.model.getParent(next);
    }
    if (next == root || this.model.getParent(next) == root) {
      this.view.setCurrentRoot(null);
    } else {
      this.view.setCurrentRoot(next);
    }
    if (null != this.view.getState(current)) {
      this.setSelectionCell(current);
    }
  }
};
mxGraph.prototype.home = function() {
  var current = this.getCurrentRoot();
  if (null != current) {
    this.view.setCurrentRoot(null);
    if (null != this.view.getState(current)) {
      this.setSelectionCell(current);
    }
  }
};
mxGraph.prototype.isValidRoot = function(cell) {
  return null != cell;
};
mxGraph.prototype.getGraphBounds = function() {
  return this.view.getGraphBounds();
};
mxGraph.prototype.getCellBounds = function(cell, includeEdges, includeDescendants) {
  var cells = [cell];
  if (includeEdges) {
    cells = cells.concat(this.model.getEdges(cell));
  }
  cells = this.view.getBounds(cells);
  if (includeDescendants) {
    includeDescendants = this.model.getChildCount(cell);
    for (var i = 0;i < includeDescendants;i++) {
      var parent = this.getCellBounds(this.model.getChildAt(cell, i), includeEdges, true);
      if (null != cells) {
        cells.add(parent);
      } else {
        cells = parent;
      }
    }
  }
  return cells;
};
mxGraph.prototype.getBoundingBoxFromGeometry = function(cells, isConnect) {
  isConnect = null != isConnect ? isConnect : false;
  var result = null;
  if (null != cells) {
    for (var i = 0;i < cells.length;i++) {
      if (isConnect || this.model.isVertex(cells[i])) {
        var geo = this.getCellGeometry(cells[i]);
        if (null != geo) {
          var bbox = null;
          if (this.model.isEdge(cells[i])) {
            bbox = function(b) {
              if (null != b) {
                if (null == tmp) {
                  tmp = new mxRectangle(b.x, b.y, 0, 0);
                } else {
                  tmp.add(new mxRectangle(b.x, b.y, 0, 0));
                }
              }
            };
            if (null == this.model.getTerminal(cells[i], true)) {
              bbox(geo.getTerminalPoint(true));
            }
            if (null == this.model.getTerminal(cells[i], false)) {
              bbox(geo.getTerminalPoint(false));
            }
            geo = geo.points;
            if (null != geo && 0 < geo.length) {
              var tmp = new mxRectangle(geo[0].x, geo[0].y, 0, 0);
              for (var parent = 1;parent < geo.length;parent++) {
                bbox(geo[parent]);
              }
            }
            bbox = tmp;
          } else {
            parent = this.model.getParent(cells[i]);
            if (geo.relative) {
              if (this.model.isVertex(parent)) {
                if (parent != this.view.currentRoot) {
                  tmp = this.getBoundingBoxFromGeometry([parent], false);
                  if (null != tmp) {
                    bbox = new mxRectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);
                    if (0 <= mxUtils.indexOf(cells, parent)) {
                      bbox.x += tmp.x;
                      bbox.y += tmp.y;
                    }
                  }
                }
              }
            } else {
              bbox = mxRectangle.fromRectangle(geo);
              if (this.model.isVertex(parent)) {
                if (0 <= mxUtils.indexOf(cells, parent)) {
                  tmp = this.getBoundingBoxFromGeometry([parent], false);
                  if (null != tmp) {
                    bbox.x += tmp.x;
                    bbox.y += tmp.y;
                  }
                }
              }
            }
            if (null != bbox) {
              if (null != geo.offset) {
                bbox.x += geo.offset.x;
                bbox.y += geo.offset.y;
              }
            }
            geo = this.getCurrentCellStyle(cells[i]);
            if (null != bbox) {
              geo = mxUtils.getValue(geo, mxConstants.STYLE_ROTATION, 0);
              if (0 != geo) {
                bbox = mxUtils.getBoundingBox(bbox, geo);
              }
            }
          }
          if (null != bbox) {
            if (null == result) {
              result = mxRectangle.fromRectangle(bbox);
            } else {
              result.add(bbox);
            }
          }
        }
      }
    }
  }
  return result;
};
mxGraph.prototype.refresh = function(cell) {
  this.view.clear(cell, null == cell);
  this.view.validate();
  this.sizeDidChange();
  this.fireEvent(new mxEventObject(mxEvent.REFRESH));
};
mxGraph.prototype.snap = function(value) {
  if (this.gridEnabled) {
    value = Math.round(value / this.gridSize) * this.gridSize;
  }
  return value;
};
mxGraph.prototype.snapDelta = function(delta, bounds, ignoreGrid, tx, layer) {
  var t = this.view.translate;
  var s = this.view.scale;
  if (!ignoreGrid && this.gridEnabled) {
    ignoreGrid = this.gridSize * s * 0.5;
    if (!tx) {
      tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;
      delta.x = Math.abs(delta.x - tx) < ignoreGrid ? 0 : this.snap(delta.x / s) * s - tx;
    }
    if (!layer) {
      bounds = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;
      delta.y = Math.abs(delta.y - bounds) < ignoreGrid ? 0 : this.snap(delta.y / s) * s - bounds;
    }
  } else {
    ignoreGrid = 0.5 * s;
    if (!tx) {
      tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;
      delta.x = Math.abs(delta.x - tx) < ignoreGrid ? 0 : Math.round(delta.x / s) * s - tx;
    }
    if (!layer) {
      bounds = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;
      delta.y = Math.abs(delta.y - bounds) < ignoreGrid ? 0 : Math.round(delta.y / s) * s - bounds;
    }
  }
  return delta;
};
mxGraph.prototype.panGraph = function(dx, dy) {
  if (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container)) {
    this.container.scrollLeft = -dx;
    this.container.scrollTop = -dy;
  } else {
    var canvas = this.view.getCanvas();
    if (this.dialect == mxConstants.DIALECT_SVG) {
      if (0 == dx && 0 == dy) {
        if (mxClient.IS_IE ? canvas.setAttribute("transform", "translate(" + dx + "," + dy + ")") : canvas.removeAttribute("transform"), null != this.shiftPreview1) {
          for (var child = this.shiftPreview1.firstChild;null != child;) {
            var next = child.nextSibling;
            this.container.appendChild(child);
            child = next;
          }
          if (null != this.shiftPreview1.parentNode) {
            this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
          }
          this.shiftPreview1 = null;
          this.container.appendChild(canvas.parentNode);
          for (child = this.shiftPreview2.firstChild;null != child;) {
            next = child.nextSibling;
            this.container.appendChild(child);
            child = next;
          }
          if (null != this.shiftPreview2.parentNode) {
            this.shiftPreview2.parentNode.removeChild(this.shiftPreview2);
          }
          this.shiftPreview2 = null;
        }
      } else {
        canvas.setAttribute("transform", "translate(" + dx + "," + dy + ")");
        if (null == this.shiftPreview1) {
          this.shiftPreview1 = document.createElement("div");
          this.shiftPreview1.style.position = "absolute";
          this.shiftPreview1.style.overflow = "visible";
          this.shiftPreview2 = document.createElement("div");
          this.shiftPreview2.style.position = "absolute";
          this.shiftPreview2.style.overflow = "visible";
          var current = this.shiftPreview1;
          for (child = this.container.firstChild;null != child;) {
            next = child.nextSibling;
            if (child != canvas.parentNode) {
              current.appendChild(child);
            } else {
              current = this.shiftPreview2;
            }
            child = next;
          }
          if (null != this.shiftPreview1.firstChild) {
            this.container.insertBefore(this.shiftPreview1, canvas.parentNode);
          }
          if (null != this.shiftPreview2.firstChild) {
            this.container.appendChild(this.shiftPreview2);
          }
        }
        this.shiftPreview1.style.left = dx + "px";
        this.shiftPreview1.style.top = dy + "px";
        this.shiftPreview2.style.left = dx + "px";
        this.shiftPreview2.style.top = dy + "px";
      }
    } else {
      canvas.style.left = dx + "px";
      canvas.style.top = dy + "px";
    }
    this.panDx = dx;
    this.panDy = dy;
    this.fireEvent(new mxEventObject(mxEvent.PAN));
  }
};
mxGraph.prototype.zoomIn = function() {
  this.zoom(this.zoomFactor);
};
mxGraph.prototype.zoomOut = function() {
  this.zoom(1 / this.zoomFactor);
};
mxGraph.prototype.zoomActual = function() {
  if (1 == this.view.scale) {
    this.view.setTranslate(0, 0);
  } else {
    this.view.translate.x = 0;
    this.view.translate.y = 0;
    this.view.setScale(1);
  }
};
mxGraph.prototype.zoomTo = function(scale, y) {
  this.zoom(scale / this.view.scale, y);
};
mxGraph.prototype.center = function(horizontal, vertical, cx, cy) {
  horizontal = null != horizontal ? horizontal : true;
  vertical = null != vertical ? vertical : true;
  cx = null != cx ? cx : 0.5;
  cy = null != cy ? cy : 0.5;
  var hasScrollbars = mxUtils.hasScrollbars(this.container);
  var padding = 2 * this.getBorder();
  var cw = this.container.clientWidth - padding;
  padding = this.container.clientHeight - padding;
  var bounds = this.getGraphBounds();
  var t = this.view.translate;
  var s = this.view.scale;
  var dx = horizontal ? cw - bounds.width : 0;
  var dy = vertical ? padding - bounds.height : 0;
  if (hasScrollbars) {
    bounds.x -= t.x;
    bounds.y -= t.y;
    horizontal = this.container.scrollWidth;
    vertical = this.container.scrollHeight;
    if (horizontal > cw) {
      dx = 0;
    }
    if (vertical > padding) {
      dy = 0;
    }
    this.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));
    this.container.scrollLeft = (horizontal - cw) / 2;
    this.container.scrollTop = (vertical - padding) / 2;
  } else {
    this.view.setTranslate(horizontal ? Math.floor(t.x - bounds.x / s + dx * cx / s) : t.x, vertical ? Math.floor(t.y - bounds.y / s + dy * cy / s) : t.y);
  }
};
mxGraph.prototype.zoom = function(x, y, dx) {
  y = null != y ? y : this.centerZoom;
  var scale = Math.round(this.view.scale * x * 100) / 100;
  if (null != dx) {
    scale = Math.round(scale * dx) / dx;
  }
  dx = this.view.getState(this.getSelectionCell());
  x = scale / this.view.scale;
  if (this.keepSelectionVisibleOnZoom && null != dx) {
    x = new mxRectangle(dx.x * x, dx.y * x, dx.width * x, dx.height * x);
    this.view.scale = scale;
    if (!this.scrollRectToVisible(x)) {
      this.view.revalidate();
      this.view.setScale(scale);
    }
  } else {
    if (dx = mxUtils.hasScrollbars(this.container), y && !dx) {
      dx = this.container.offsetWidth;
      var dy = this.container.offsetHeight;
      if (1 < x) {
        x = (x - 1) / (2 * scale);
        dx *= -x;
        dy *= -x;
      } else {
        x = (1 / x - 1) / (2 * this.view.scale);
        dx *= x;
        dy *= x;
      }
      this.view.scaleAndTranslate(scale, this.view.translate.x + dx, this.view.translate.y + dy);
    } else {
      var tx = this.view.translate.x;
      var ty = this.view.translate.y;
      var sl = this.container.scrollLeft;
      var st = this.container.scrollTop;
      this.view.setScale(scale);
      if (dx) {
        dy = dx = 0;
        if (y) {
          dx = this.container.offsetWidth * (x - 1) / 2;
          dy = this.container.offsetHeight * (x - 1) / 2;
        }
        this.container.scrollLeft = (this.view.translate.x - tx) * this.view.scale + Math.round(sl * x + dx);
        this.container.scrollTop = (this.view.translate.y - ty) * this.view.scale + Math.round(st * x + dy);
      }
    }
  }
};
mxGraph.prototype.zoomToRect = function(rect) {
  var scale = this.container.clientWidth / rect.width / (this.container.clientHeight / rect.height);
  rect.x = Math.max(0, rect.x);
  rect.y = Math.max(0, rect.y);
  var s2 = Math.min(this.container.scrollWidth, rect.x + rect.width);
  var rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);
  rect.width = s2 - rect.x;
  rect.height = rectBottom - rect.y;
  if (1 > scale) {
    scale = rect.height / scale;
    s2 = (scale - rect.height) / 2;
    rect.height = scale;
    rect.y -= Math.min(rect.y, s2);
    rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);
    rect.height = rectBottom - rect.y;
  } else {
    scale *= rect.width;
    s2 = (scale - rect.width) / 2;
    rect.width = scale;
    rect.x -= Math.min(rect.x, s2);
    s2 = Math.min(this.container.scrollWidth, rect.x + rect.width);
    rect.width = s2 - rect.x;
  }
  scale = this.container.clientWidth / rect.width;
  s2 = this.view.scale * scale;
  if (mxUtils.hasScrollbars(this.container)) {
    this.view.setScale(s2);
    this.container.scrollLeft = Math.round(rect.x * scale);
    this.container.scrollTop = Math.round(rect.y * scale);
  } else {
    this.view.scaleAndTranslate(s2, this.view.translate.x - rect.x / this.view.scale, this.view.translate.y - rect.y / this.view.scale);
  }
};
mxGraph.prototype.scrollCellToVisible = function(cell, tmp) {
  var bounds = -this.view.translate.x;
  var h = -this.view.translate.y;
  cell = this.view.getState(cell);
  if (null != cell) {
    bounds = new mxRectangle(bounds + cell.x, h + cell.y, cell.width, cell.height);
    if (tmp) {
      if (null != this.container) {
        tmp = this.container.clientWidth;
        h = this.container.clientHeight;
        bounds.x = bounds.getCenterX() - tmp / 2;
        bounds.width = tmp;
        bounds.y = bounds.getCenterY() - h / 2;
        bounds.height = h;
      }
    }
    tmp = new mxPoint(this.view.translate.x, this.view.translate.y);
    if (this.scrollRectToVisible(bounds)) {
      bounds = new mxPoint(this.view.translate.x, this.view.translate.y);
      this.view.translate.x = tmp.x;
      this.view.translate.y = tmp.y;
      this.view.setTranslate(bounds.x, bounds.y);
    }
  }
};
mxGraph.prototype.scrollRectToVisible = function(rect) {
  var isChanged = false;
  if (null != rect) {
    var w = this.container.offsetWidth;
    var h = this.container.offsetHeight;
    var widthLimit = Math.min(w, rect.width);
    var heightLimit = Math.min(h, rect.height);
    if (mxUtils.hasScrollbars(this.container)) {
      w = this.container;
      rect.x += this.view.translate.x;
      rect.y += this.view.translate.y;
      var x = w.scrollLeft - rect.x;
      h = Math.max(x - w.scrollLeft, 0);
      if (0 < x) {
        w.scrollLeft -= x + 2;
      } else {
        x = rect.x + widthLimit - w.scrollLeft - w.clientWidth;
        if (0 < x) {
          w.scrollLeft += x + 2;
        }
      }
      widthLimit = w.scrollTop - rect.y;
      x = Math.max(0, widthLimit - w.scrollTop);
      if (0 < widthLimit) {
        w.scrollTop -= widthLimit + 2;
      } else {
        widthLimit = rect.y + heightLimit - w.scrollTop - w.clientHeight;
        if (0 < widthLimit) {
          w.scrollTop += widthLimit + 2;
        }
      }
      if (!this.useScrollbarsForPanning) {
        if (!(0 == h && 0 == x)) {
          this.view.setTranslate(h, x);
        }
      }
    } else {
      x = -this.view.translate.x;
      var y = -this.view.translate.y;
      var s = this.view.scale;
      if (rect.x + widthLimit > x + w) {
        this.view.translate.x -= (rect.x + widthLimit - w - x) / s;
        isChanged = true;
      }
      if (rect.y + heightLimit > y + h) {
        this.view.translate.y -= (rect.y + heightLimit - h - y) / s;
        isChanged = true;
      }
      if (rect.x < x) {
        this.view.translate.x += (x - rect.x) / s;
        isChanged = true;
      }
      if (rect.y < y) {
        this.view.translate.y += (y - rect.y) / s;
        isChanged = true;
      }
      if (isChanged) {
        this.view.refresh();
        if (null != this.selectionCellsHandler) {
          this.selectionCellsHandler.refresh();
        }
      }
    }
  }
  return isChanged;
};
mxGraph.prototype.getCellGeometry = function(cell) {
  return this.model.getGeometry(cell);
};
mxGraph.prototype.isCellVisible = function(cell) {
  return this.model.isVisible(cell);
};
mxGraph.prototype.isCellCollapsed = function(cell) {
  return this.model.isCollapsed(cell);
};
mxGraph.prototype.isCellConnectable = function(cell) {
  return this.model.isConnectable(cell);
};
mxGraph.prototype.isOrthogonal = function(edge) {
  var orthogonal = edge.style[mxConstants.STYLE_ORTHOGONAL];
  if (null != orthogonal) {
    return orthogonal;
  }
  edge = this.view.getEdgeStyle(edge);
  return edge == mxEdgeStyle.SegmentConnector || (edge == mxEdgeStyle.ElbowConnector || (edge == mxEdgeStyle.SideToSide || (edge == mxEdgeStyle.TopToBottom || (edge == mxEdgeStyle.EntityRelation || edge == mxEdgeStyle.OrthConnector))));
};
mxGraph.prototype.isLoop = function(state) {
  var b = state.getVisibleTerminalState(true);
  state = state.getVisibleTerminalState(false);
  return null != b && b == state;
};
mxGraph.prototype.isCloneEvent = function(evt) {
  return mxEvent.isControlDown(evt);
};
mxGraph.prototype.isTransparentClickEvent = function(evt) {
  return false;
};
mxGraph.prototype.isToggleEvent = function(evt) {
  return mxClient.IS_MAC ? mxEvent.isMetaDown(evt) : mxEvent.isControlDown(evt);
};
mxGraph.prototype.isGridEnabledEvent = function(evt) {
  return null != evt && !mxEvent.isAltDown(evt);
};
mxGraph.prototype.isConstrainedEvent = function(me) {
  return mxEvent.isShiftDown(me);
};
mxGraph.prototype.isIgnoreTerminalEvent = function(evt) {
  return false;
};
mxGraph.prototype.validationAlert = function(message) {
  mxUtils.alert(message);
};
mxGraph.prototype.isEdgeValid = function(edge, source, target) {
  return null == this.getEdgeValidationError(edge, source, target);
};
mxGraph.prototype.getEdgeValidationError = function(edge, source, target) {
  if (null != edge && (!this.isAllowDanglingEdges() && (null == source || null == target))) {
    return "";
  }
  if (null != edge && (null == this.model.getTerminal(edge, true) && null == this.model.getTerminal(edge, false))) {
    return null;
  }
  if (!this.allowLoops && (source == target && null != source) || !this.isValidConnection(source, target)) {
    return "";
  }
  if (null != source && null != target) {
    var error = "";
    if (!this.multigraph) {
      var tmp = this.model.getEdgesBetween(source, target, true);
      if (1 < tmp.length || 1 == tmp.length && tmp[0] != edge) {
        error += (mxResources.get(this.alreadyConnectedResource) || this.alreadyConnectedResource) + "\n";
      }
    }
    tmp = this.model.getDirectedEdgeCount(source, true, edge);
    var targetIn = this.model.getDirectedEdgeCount(target, false, edge);
    if (null != this.multiplicities) {
      for (var i = 0;i < this.multiplicities.length;i++) {
        var err = this.multiplicities[i].check(this, edge, source, target, tmp, targetIn);
        if (null != err) {
          error += err;
        }
      }
    }
    err = this.validateEdge(edge, source, target);
    if (null != err) {
      error += err;
    }
    return 0 < error.length ? error : null;
  }
  return this.allowDanglingEdges ? null : "";
};
mxGraph.prototype.validateEdge = function(edge, source, target) {
  return null;
};
mxGraph.prototype.validateGraph = function(cell, state) {
  cell = null != cell ? cell : this.model.getRoot();
  state = null != state ? state : {};
  var clone = true;
  var lab = this.model.getChildCount(cell);
  for (var i = 0;i < lab;i++) {
    var tmp = this.model.getChildAt(cell, i);
    var s = state;
    if (this.isValidRoot(tmp)) {
      s = {};
    }
    s = this.validateGraph(tmp, s);
    if (null != s) {
      this.setCellWarning(tmp, s.replace(/\n/g, "<br>"));
    } else {
      this.setCellWarning(tmp, null);
    }
    clone = clone && null == s;
  }
  lab = "";
  if (this.isCellCollapsed(cell)) {
    if (!clone) {
      lab += (mxResources.get(this.containsValidationErrorsResource) || this.containsValidationErrorsResource) + "\n";
    }
  }
  lab = this.model.isEdge(cell) ? lab + (this.getEdgeValidationError(cell, this.model.getTerminal(cell, true), this.model.getTerminal(cell, false)) || "") : lab + (this.getCellValidationError(cell) || "");
  state = this.validateCell(cell, state);
  if (null != state) {
    lab += state;
  }
  if (null == this.model.getParent(cell)) {
    this.view.validate();
  }
  return 0 < lab.length || !clone ? lab : null;
};
mxGraph.prototype.getCellValidationError = function(cell) {
  var outCount = this.model.getDirectedEdgeCount(cell, true);
  var inCount = this.model.getDirectedEdgeCount(cell, false);
  cell = this.model.getValue(cell);
  var error = "";
  if (null != this.multiplicities) {
    for (var i = 0;i < this.multiplicities.length;i++) {
      var rule = this.multiplicities[i];
      if (rule.source && (mxUtils.isNode(cell, rule.type, rule.attr, rule.value) && (outCount > rule.max || outCount < rule.min))) {
        error += rule.countError + "\n";
      } else {
        if (!rule.source) {
          if (mxUtils.isNode(cell, rule.type, rule.attr, rule.value)) {
            if (inCount > rule.max || inCount < rule.min) {
              error += rule.countError + "\n";
            }
          }
        }
      }
    }
  }
  return 0 < error.length ? error : null;
};
mxGraph.prototype.validateCell = function(cell, state) {
  return null;
};
mxGraph.prototype.getBackgroundImage = function() {
  return this.backgroundImage;
};
mxGraph.prototype.setBackgroundImage = function(image) {
  this.backgroundImage = image;
};
mxGraph.prototype.getFoldingImage = function(state) {
  if (null != state && (this.foldingEnabled && !this.getModel().isEdge(state.cell))) {
    var tmp = this.isCellCollapsed(state.cell);
    if (this.isCellFoldable(state.cell, !tmp)) {
      return tmp ? this.collapsedImage : this.expandedImage;
    }
  }
  return null;
};
mxGraph.prototype.convertValueToString = function(cell) {
  cell = this.model.getValue(cell);
  if (null != cell) {
    if (mxUtils.isNode(cell)) {
      return cell.nodeName;
    }
    if ("function" == typeof cell.toString) {
      return cell.toString();
    }
  }
  return "";
};
mxGraph.prototype.getLabel = function(cell) {
  var result = "";
  if (this.labelsVisible && null != cell) {
    var style = this.getCurrentCellStyle(cell);
    if (!mxUtils.getValue(style, mxConstants.STYLE_NOLABEL, false)) {
      result = this.convertValueToString(cell);
    }
  }
  return result;
};
mxGraph.prototype.isHtmlLabel = function(cell) {
  return this.isHtmlLabels();
};
mxGraph.prototype.isHtmlLabels = function() {
  return this.htmlLabels;
};
mxGraph.prototype.setHtmlLabels = function(value) {
  this.htmlLabels = value;
};
mxGraph.prototype.isWrapping = function(cell) {
  return "wrap" == this.getCurrentCellStyle(cell)[mxConstants.STYLE_WHITE_SPACE];
};
mxGraph.prototype.isLabelClipped = function(cell) {
  return "hidden" == this.getCurrentCellStyle(cell)[mxConstants.STYLE_OVERFLOW];
};
mxGraph.prototype.getTooltip = function(state, source, x, y) {
  var cell = null;
  if (null != state) {
    if (!(null == state.control)) {
      if (!(source != state.control.node && source.parentNode != state.control.node)) {
        cell = this.collapseExpandResource;
        cell = mxUtils.htmlEntities(mxResources.get(cell) || cell).replace(/\\n/g, "<br>");
      }
    }
    if (null == cell) {
      if (null != state.overlays) {
        state.overlays.visit(function(flex, shape) {
          if (!(null != cell)) {
            if (!(source != shape.node && source.parentNode != shape.node)) {
              cell = shape.overlay.toString();
            }
          }
        });
      }
    }
    if (null == cell) {
      x = this.selectionCellsHandler.getHandler(state.cell);
      if (null != x) {
        if ("function" == typeof x.getTooltipForNode) {
          cell = x.getTooltipForNode(source);
        }
      }
    }
    if (null == cell) {
      cell = this.getTooltipForCell(state.cell);
    }
  }
  return cell;
};
mxGraph.prototype.getTooltipForCell = function(cell) {
  return null != cell && null != cell.getTooltip ? cell.getTooltip() : this.convertValueToString(cell);
};
mxGraph.prototype.getLinkForCell = function(cell) {
  return null;
};
mxGraph.prototype.getLinkTargetForCell = function(flex) {
  return null;
};
mxGraph.prototype.getCursorForMouseEvent = function(me) {
  return this.getCursorForCell(me.getCell());
};
mxGraph.prototype.getCursorForCell = function(cell) {
  return null;
};
mxGraph.prototype.getStartSize = function(cell, ignoreState) {
  var result = new mxRectangle;
  cell = this.getCurrentCellStyle(cell, ignoreState);
  ignoreState = parseInt(mxUtils.getValue(cell, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
  if (mxUtils.getValue(cell, mxConstants.STYLE_HORIZONTAL, true)) {
    result.height = ignoreState;
  } else {
    result.width = ignoreState;
  }
  return result;
};
mxGraph.prototype.getSwimlaneDirection = function(style) {
  var dir = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
  var c = 1 == mxUtils.getValue(style, mxConstants.STYLE_FLIPH, 0);
  var d = 1 == mxUtils.getValue(style, mxConstants.STYLE_FLIPV, 0);
  style = mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true) ? 0 : 3;
  if (dir == mxConstants.DIRECTION_NORTH) {
    style--;
  } else {
    if (dir == mxConstants.DIRECTION_WEST) {
      style += 2;
    } else {
      if (dir == mxConstants.DIRECTION_SOUTH) {
        style += 1;
      }
    }
  }
  dir = mxUtils.mod(style, 2);
  if (c) {
    if (1 == dir) {
      style += 2;
    }
  }
  if (d) {
    if (0 == dir) {
      style += 2;
    }
  }
  return[mxConstants.DIRECTION_NORTH, mxConstants.DIRECTION_EAST, mxConstants.DIRECTION_SOUTH, mxConstants.DIRECTION_WEST][mxUtils.mod(style, 4)];
};
mxGraph.prototype.getActualStartSize = function(swimlane, style) {
  var result = new mxRectangle;
  if (this.isSwimlane(swimlane, style)) {
    style = this.getCurrentCellStyle(swimlane, style);
    swimlane = parseInt(mxUtils.getValue(style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
    style = this.getSwimlaneDirection(style);
    if (style == mxConstants.DIRECTION_NORTH) {
      result.y = swimlane;
    } else {
      if (style == mxConstants.DIRECTION_WEST) {
        result.x = swimlane;
      } else {
        if (style == mxConstants.DIRECTION_SOUTH) {
          result.height = swimlane;
        } else {
          result.width = swimlane;
        }
      }
    }
  }
  return result;
};
mxGraph.prototype.getImage = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_IMAGE] : null;
};
mxGraph.prototype.isTransparentState = function(state) {
  var fill = false;
  if (null != state) {
    fill = mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);
    var stroke = mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);
    fill = fill == mxConstants.NONE && (stroke == mxConstants.NONE && null == this.getImage(state));
  }
  return fill;
};
mxGraph.prototype.getVerticalAlign = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_VERTICAL_ALIGN] || mxConstants.ALIGN_MIDDLE : null;
};
mxGraph.prototype.getIndicatorColor = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_COLOR] : null;
};
mxGraph.prototype.getIndicatorGradientColor = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] : null;
};
mxGraph.prototype.getIndicatorShape = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_SHAPE] : null;
};
mxGraph.prototype.getIndicatorImage = function(state) {
  return null != state && null != state.style ? state.style[mxConstants.STYLE_INDICATOR_IMAGE] : null;
};
mxGraph.prototype.getBorder = function() {
  return this.border;
};
mxGraph.prototype.setBorder = function(value) {
  this.border = value;
};
mxGraph.prototype.isSwimlane = function(cell, ignoreState) {
  return null == cell || (this.model.getParent(cell) == this.model.getRoot() || this.model.isEdge(cell)) ? false : this.getCurrentCellStyle(cell, ignoreState)[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;
};
mxGraph.prototype.isResizeContainer = function() {
  return this.resizeContainer;
};
mxGraph.prototype.setResizeContainer = function(value) {
  this.resizeContainer = value;
};
mxGraph.prototype.isEnabled = function() {
  return this.enabled;
};
mxGraph.prototype.setEnabled = function(value) {
  this.enabled = value;
  this.fireEvent(new mxEventObject("enabledChanged", "enabled", value));
};
mxGraph.prototype.isEscapeEnabled = function() {
  return this.escapeEnabled;
};
mxGraph.prototype.setEscapeEnabled = function(value) {
  this.escapeEnabled = value;
};
mxGraph.prototype.isInvokesStopCellEditing = function() {
  return this.invokesStopCellEditing;
};
mxGraph.prototype.setInvokesStopCellEditing = function(value) {
  this.invokesStopCellEditing = value;
};
mxGraph.prototype.isEnterStopsCellEditing = function() {
  return this.enterStopsCellEditing;
};
mxGraph.prototype.setEnterStopsCellEditing = function(value) {
  this.enterStopsCellEditing = value;
};
mxGraph.prototype.isCellLocked = function(cell) {
  var geometry = this.model.getGeometry(cell);
  return this.isCellsLocked() || null != geometry && (this.model.isVertex(cell) && geometry.relative);
};
mxGraph.prototype.isCellsLocked = function() {
  return this.cellsLocked;
};
mxGraph.prototype.setCellsLocked = function(value) {
  this.cellsLocked = value;
};
mxGraph.prototype.getCloneableCells = function(cells) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.isCellCloneable(cell);
  }));
};
mxGraph.prototype.isCellCloneable = function(cell) {
  cell = this.getCurrentCellStyle(cell);
  return this.isCellsCloneable() && 0 != cell[mxConstants.STYLE_CLONEABLE];
};
mxGraph.prototype.isCellsCloneable = function() {
  return this.cellsCloneable;
};
mxGraph.prototype.setCellsCloneable = function(value) {
  this.cellsCloneable = value;
};
mxGraph.prototype.getExportableCells = function(cells) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.canExportCell(cell);
  }));
};
mxGraph.prototype.canExportCell = function(cell) {
  return this.exportEnabled;
};
mxGraph.prototype.getImportableCells = function(cells) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.canImportCell(cell);
  }));
};
mxGraph.prototype.canImportCell = function(cell) {
  return this.importEnabled;
};
mxGraph.prototype.isCellSelectable = function(cell) {
  return this.isCellsSelectable();
};
mxGraph.prototype.isCellsSelectable = function() {
  return this.cellsSelectable;
};
mxGraph.prototype.setCellsSelectable = function(value) {
  this.cellsSelectable = value;
};
mxGraph.prototype.getDeletableCells = function(cells) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.isCellDeletable(cell);
  }));
};
mxGraph.prototype.isCellDeletable = function(cell) {
  cell = this.getCurrentCellStyle(cell);
  return this.isCellsDeletable() && 0 != cell[mxConstants.STYLE_DELETABLE];
};
mxGraph.prototype.isCellsDeletable = function() {
  return this.cellsDeletable;
};
mxGraph.prototype.setCellsDeletable = function(value) {
  this.cellsDeletable = value;
};
mxGraph.prototype.isLabelMovable = function(cell) {
  return!this.isCellLocked(cell) && (this.model.isEdge(cell) && this.edgeLabelsMovable || this.model.isVertex(cell) && this.vertexLabelsMovable);
};
mxGraph.prototype.getRotatableCells = function(cells) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.isCellRotatable(cell);
  }));
};
mxGraph.prototype.isCellRotatable = function(cell) {
  return 0 != this.getCurrentCellStyle(cell)[mxConstants.STYLE_ROTATABLE];
};
mxGraph.prototype.getMovableCells = function(cells) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.isCellMovable(cell);
  }));
};
mxGraph.prototype.isCellMovable = function(cell) {
  var style = this.getCurrentCellStyle(cell);
  return this.isCellsMovable() && (!this.isCellLocked(cell) && 0 != style[mxConstants.STYLE_MOVABLE]);
};
mxGraph.prototype.isCellsMovable = function() {
  return this.cellsMovable;
};
mxGraph.prototype.setCellsMovable = function(value) {
  this.cellsMovable = value;
};
mxGraph.prototype.isGridEnabled = function() {
  return this.gridEnabled;
};
mxGraph.prototype.setGridEnabled = function(value) {
  this.gridEnabled = value;
};
mxGraph.prototype.isPortsEnabled = function() {
  return this.portsEnabled;
};
mxGraph.prototype.setPortsEnabled = function(value) {
  this.portsEnabled = value;
};
mxGraph.prototype.getGridSize = function() {
  return this.gridSize;
};
mxGraph.prototype.setGridSize = function(value) {
  this.gridSize = value;
};
mxGraph.prototype.getTolerance = function() {
  return this.tolerance;
};
mxGraph.prototype.setTolerance = function(value) {
  this.tolerance = value;
};
mxGraph.prototype.isVertexLabelsMovable = function() {
  return this.vertexLabelsMovable;
};
mxGraph.prototype.setVertexLabelsMovable = function(value) {
  this.vertexLabelsMovable = value;
};
mxGraph.prototype.isEdgeLabelsMovable = function() {
  return this.edgeLabelsMovable;
};
mxGraph.prototype.setEdgeLabelsMovable = function(value) {
  this.edgeLabelsMovable = value;
};
mxGraph.prototype.isSwimlaneNesting = function() {
  return this.swimlaneNesting;
};
mxGraph.prototype.setSwimlaneNesting = function(value) {
  this.swimlaneNesting = value;
};
mxGraph.prototype.isSwimlaneSelectionEnabled = function() {
  return this.swimlaneSelectionEnabled;
};
mxGraph.prototype.setSwimlaneSelectionEnabled = function(value) {
  this.swimlaneSelectionEnabled = value;
};
mxGraph.prototype.isMultigraph = function() {
  return this.multigraph;
};
mxGraph.prototype.setMultigraph = function(value) {
  this.multigraph = value;
};
mxGraph.prototype.isAllowLoops = function() {
  return this.allowLoops;
};
mxGraph.prototype.setAllowDanglingEdges = function(value) {
  this.allowDanglingEdges = value;
};
mxGraph.prototype.isAllowDanglingEdges = function() {
  return this.allowDanglingEdges;
};
mxGraph.prototype.setConnectableEdges = function(value) {
  this.connectableEdges = value;
};
mxGraph.prototype.isConnectableEdges = function() {
  return this.connectableEdges;
};
mxGraph.prototype.setCloneInvalidEdges = function(value) {
  this.cloneInvalidEdges = value;
};
mxGraph.prototype.isCloneInvalidEdges = function() {
  return this.cloneInvalidEdges;
};
mxGraph.prototype.setAllowLoops = function(value) {
  this.allowLoops = value;
};
mxGraph.prototype.isDisconnectOnMove = function() {
  return this.disconnectOnMove;
};
mxGraph.prototype.setDisconnectOnMove = function(value) {
  this.disconnectOnMove = value;
};
mxGraph.prototype.isDropEnabled = function() {
  return this.dropEnabled;
};
mxGraph.prototype.setDropEnabled = function(value) {
  this.dropEnabled = value;
};
mxGraph.prototype.isSplitEnabled = function() {
  return this.splitEnabled;
};
mxGraph.prototype.setSplitEnabled = function(value) {
  this.splitEnabled = value;
};
mxGraph.prototype.getResizableCells = function(cells) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.isCellResizable(cell);
  }));
};
mxGraph.prototype.isCellResizable = function(cell) {
  var style = this.getCurrentCellStyle(cell);
  return this.isCellsResizable() && (!this.isCellLocked(cell) && "0" != mxUtils.getValue(style, mxConstants.STYLE_RESIZABLE, "1"));
};
mxGraph.prototype.isCellsResizable = function() {
  return this.cellsResizable;
};
mxGraph.prototype.setCellsResizable = function(value) {
  this.cellsResizable = value;
};
mxGraph.prototype.isTerminalPointMovable = function(cell, source) {
  return true;
};
mxGraph.prototype.isCellBendable = function(cell) {
  var style = this.getCurrentCellStyle(cell);
  return this.isCellsBendable() && (!this.isCellLocked(cell) && 0 != style[mxConstants.STYLE_BENDABLE]);
};
mxGraph.prototype.isCellsBendable = function() {
  return this.cellsBendable;
};
mxGraph.prototype.setCellsBendable = function(value) {
  this.cellsBendable = value;
};
mxGraph.prototype.getEditableCells = function(cells) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.isCellEditable(cell);
  }));
};
mxGraph.prototype.isCellEditable = function(cell) {
  var style = this.getCurrentCellStyle(cell);
  return this.isCellsEditable() && (!this.isCellLocked(cell) && 0 != style[mxConstants.STYLE_EDITABLE]);
};
mxGraph.prototype.isCellsEditable = function() {
  return this.cellsEditable;
};
mxGraph.prototype.setCellsEditable = function(value) {
  this.cellsEditable = value;
};
mxGraph.prototype.isCellDisconnectable = function(cell, terminal, source) {
  return this.isCellsDisconnectable() && !this.isCellLocked(cell);
};
mxGraph.prototype.isCellsDisconnectable = function() {
  return this.cellsDisconnectable;
};
mxGraph.prototype.setCellsDisconnectable = function(value) {
  this.cellsDisconnectable = value;
};
mxGraph.prototype.isValidSource = function(cell) {
  return null == cell && this.allowDanglingEdges || null != cell && ((!this.model.isEdge(cell) || this.connectableEdges) && this.isCellConnectable(cell));
};
mxGraph.prototype.isValidTarget = function(cell) {
  return this.isValidSource(cell);
};
mxGraph.prototype.isValidConnection = function(source, target) {
  return this.isValidSource(source) && this.isValidTarget(target);
};
mxGraph.prototype.setConnectable = function(value) {
  this.connectionHandler.setEnabled(value);
};
mxGraph.prototype.isConnectable = function() {
  return this.connectionHandler.isEnabled();
};
mxGraph.prototype.setTooltips = function(value) {
  this.tooltipHandler.setEnabled(value);
};
mxGraph.prototype.setPanning = function(enabled) {
  this.panningHandler.panningEnabled = enabled;
};
mxGraph.prototype.isEditing = function(cell) {
  if (null != this.cellEditor) {
    var editingCell = this.cellEditor.getEditingCell();
    return null == cell ? null != editingCell : cell == editingCell;
  }
  return false;
};
mxGraph.prototype.isAutoSizeCell = function(cell) {
  cell = this.getCurrentCellStyle(cell);
  return this.isAutoSizeCells() || 1 == cell[mxConstants.STYLE_AUTOSIZE];
};
mxGraph.prototype.isAutoSizeCells = function() {
  return this.autoSizeCells;
};
mxGraph.prototype.setAutoSizeCells = function(value) {
  this.autoSizeCells = value;
};
mxGraph.prototype.isExtendParent = function(cell) {
  return!this.getModel().isEdge(cell) && this.isExtendParents();
};
mxGraph.prototype.isExtendParents = function() {
  return this.extendParents;
};
mxGraph.prototype.setExtendParents = function(value) {
  this.extendParents = value;
};
mxGraph.prototype.isExtendParentsOnAdd = function(cell) {
  return this.extendParentsOnAdd;
};
mxGraph.prototype.setExtendParentsOnAdd = function(value) {
  this.extendParentsOnAdd = value;
};
mxGraph.prototype.isExtendParentsOnMove = function() {
  return this.extendParentsOnMove;
};
mxGraph.prototype.setExtendParentsOnMove = function(value) {
  this.extendParentsOnMove = value;
};
mxGraph.prototype.isRecursiveResize = function(state) {
  return this.recursiveResize;
};
mxGraph.prototype.setRecursiveResize = function(value) {
  this.recursiveResize = value;
};
mxGraph.prototype.isConstrainChild = function(cell) {
  return this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(cell));
};
mxGraph.prototype.isConstrainChildren = function() {
  return this.constrainChildren;
};
mxGraph.prototype.setConstrainChildren = function(value) {
  this.constrainChildren = value;
};
mxGraph.prototype.isConstrainRelativeChildren = function() {
  return this.constrainRelativeChildren;
};
mxGraph.prototype.setConstrainRelativeChildren = function(value) {
  this.constrainRelativeChildren = value;
};
mxGraph.prototype.isAllowNegativeCoordinates = function() {
  return this.allowNegativeCoordinates;
};
mxGraph.prototype.setAllowNegativeCoordinates = function(value) {
  this.allowNegativeCoordinates = value;
};
mxGraph.prototype.getOverlap = function(cell) {
  return this.isAllowOverlapParent(cell) ? this.defaultOverlap : 0;
};
mxGraph.prototype.isAllowOverlapParent = function(cell) {
  return false;
};
mxGraph.prototype.getFoldableCells = function(cells, collapse) {
  return this.model.filterCells(cells, mxUtils.bind(this, function(cell) {
    return this.isCellFoldable(cell, collapse);
  }));
};
mxGraph.prototype.isCellFoldable = function(cell, collapse) {
  collapse = this.getCurrentCellStyle(cell);
  return 0 < this.model.getChildCount(cell) && 0 != collapse[mxConstants.STYLE_FOLDABLE];
};
mxGraph.prototype.isValidDropTarget = function(cell, cells, evt) {
  return null != cell && (this.isSplitEnabled() && this.isSplitTarget(cell, cells, evt) || !this.model.isEdge(cell) && (this.isSwimlane(cell) || 0 < this.model.getChildCount(cell) && !this.isCellCollapsed(cell)));
};
mxGraph.prototype.isSplitTarget = function(cell, cells, terminal) {
  return this.model.isEdge(cell) && (null != cells && (1 == cells.length && (this.isCellConnectable(cells[0]) && null == this.getEdgeValidationError(cell, this.model.getTerminal(cell, true), cells[0])))) ? (terminal = this.model.getTerminal(cell, true), cell = this.model.getTerminal(cell, false), !this.model.isAncestor(cells[0], terminal) && !this.model.isAncestor(cells[0], cell)) : false;
};
mxGraph.prototype.getDropTarget = function(cells, evt, cell, clone) {
  if (!this.isSwimlaneNesting()) {
    for (var pt = 0;pt < cells.length;pt++) {
      if (this.isSwimlane(cells[pt])) {
        return null;
      }
    }
  }
  pt = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  pt.x -= this.panDx;
  pt.y -= this.panDy;
  pt = this.getSwimlaneAt(pt.x, pt.y);
  if (null == cell) {
    cell = pt;
  } else {
    if (null != pt) {
      for (var tmp = this.model.getParent(pt);null != tmp && (this.isSwimlane(tmp) && tmp != cell);) {
        tmp = this.model.getParent(tmp);
      }
      if (tmp == cell) {
        cell = pt;
      }
    }
  }
  for (;null != cell && (!this.isValidDropTarget(cell, cells, evt) && !this.model.isLayer(cell));) {
    cell = this.model.getParent(cell);
  }
  if (null == clone || !clone) {
    for (var parent = cell;null != parent && 0 > mxUtils.indexOf(cells, parent);) {
      parent = this.model.getParent(parent);
    }
  }
  return this.model.isLayer(cell) || null != parent ? null : cell;
};
mxGraph.prototype.getDefaultParent = function() {
  var parent = this.getCurrentRoot();
  if (null == parent) {
    parent = this.defaultParent;
    if (null == parent) {
      parent = this.model.getRoot();
      parent = this.model.getChildAt(parent, 0);
    }
  }
  return parent;
};
mxGraph.prototype.setDefaultParent = function(cell) {
  this.defaultParent = cell;
};
mxGraph.prototype.getSwimlane = function(cell) {
  for (;null != cell && !this.isSwimlane(cell);) {
    cell = this.model.getParent(cell);
  }
  return cell;
};
mxGraph.prototype.getSwimlaneAt = function(x, y, cell) {
  if (null == cell) {
    cell = this.getCurrentRoot();
    if (null == cell) {
      cell = this.model.getRoot();
    }
  }
  if (null != cell) {
    var childCount = this.model.getChildCount(cell);
    for (var i = 0;i < childCount;i++) {
      var child = this.model.getChildAt(cell, i);
      if (null != child) {
        var state = this.getSwimlaneAt(x, y, child);
        if (null != state) {
          return state;
        }
        if (this.isCellVisible(child) && (this.isSwimlane(child) && (state = this.view.getState(child), this.intersects(state, x, y)))) {
          return child;
        }
      }
    }
  }
  return null;
};
mxGraph.prototype.getCellAt = function(x, y, parent, vertices, edges, ignoreFn) {
  vertices = null != vertices ? vertices : true;
  edges = null != edges ? edges : true;
  if (null == parent) {
    parent = this.getCurrentRoot();
    if (null == parent) {
      parent = this.getModel().getRoot();
    }
  }
  if (null != parent) {
    for (var i = this.model.getChildCount(parent) - 1;0 <= i;i--) {
      var cell = this.model.getChildAt(parent, i);
      var state = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);
      if (null != state) {
        return state;
      }
      if (this.isCellVisible(cell) && ((edges && this.model.isEdge(cell) || vertices && this.model.isVertex(cell)) && (state = this.view.getState(cell), null != state && ((null == ignoreFn || !ignoreFn(state, x, y)) && this.intersects(state, x, y))))) {
        return cell;
      }
    }
  }
  return null;
};
mxGraph.prototype.intersects = function(state, x, y) {
  if (null != state) {
    var cos = state.absolutePoints;
    if (null != cos) {
      state = this.tolerance * this.tolerance;
      var pt = cos[0];
      for (var cx = 1;cx < cos.length;cx++) {
        var next = cos[cx];
        if (mxUtils.ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y) <= state) {
          return true;
        }
        pt = next;
      }
    } else {
      if (pt = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0), 0 != pt && (cos = Math.cos(-pt), pt = Math.sin(-pt), cx = new mxPoint(state.getCenterX(), state.getCenterY()), pt = mxUtils.getRotatedPoint(new mxPoint(x, y), cos, pt, cx), x = pt.x, y = pt.y), mxUtils.contains(state, x, y)) {
        return true;
      }
    }
  }
  return false;
};
mxGraph.prototype.hitsSwimlaneContent = function(cell, x, y) {
  var state = this.getView().getState(cell);
  cell = this.getStartSize(cell);
  if (null != state) {
    var scale = this.getView().getScale();
    x -= state.x;
    y -= state.y;
    if (0 < cell.width && (0 < x && x > cell.width * scale) || 0 < cell.height && (0 < y && y > cell.height * scale)) {
      return true;
    }
  }
  return false;
};
mxGraph.prototype.getChildVertices = function(parent) {
  return this.getChildCells(parent, true, false);
};
mxGraph.prototype.getChildEdges = function(parent) {
  return this.getChildCells(parent, false, true);
};
mxGraph.prototype.getChildCells = function(parent, vertices, edges) {
  parent = null != parent ? parent : this.getDefaultParent();
  parent = this.model.getChildCells(parent, null != vertices ? vertices : false, null != edges ? edges : false);
  vertices = [];
  for (edges = 0;edges < parent.length;edges++) {
    if (this.isCellVisible(parent[edges])) {
      vertices.push(parent[edges]);
    }
  }
  return vertices;
};
mxGraph.prototype.getConnections = function(cell, parent) {
  return this.getEdges(cell, parent, true, true, false);
};
mxGraph.prototype.getIncomingEdges = function(cell, parent) {
  return this.getEdges(cell, parent, true, false, false);
};
mxGraph.prototype.getOutgoingEdges = function(cell, parent) {
  return this.getEdges(cell, parent, false, true, false);
};
mxGraph.prototype.getEdges = function(cell, parent, incoming, outgoing, includeLoops, recurse) {
  incoming = null != incoming ? incoming : true;
  outgoing = null != outgoing ? outgoing : true;
  includeLoops = null != includeLoops ? includeLoops : true;
  recurse = null != recurse ? recurse : false;
  var edges = [];
  var result = this.isCellCollapsed(cell);
  var source = this.model.getChildCount(cell);
  for (var i = 0;i < source;i++) {
    var child = this.model.getChildAt(cell, i);
    if (result || !this.isCellVisible(child)) {
      edges = edges.concat(this.model.getEdges(child, incoming, outgoing));
    }
  }
  edges = edges.concat(this.model.getEdges(cell, incoming, outgoing));
  result = [];
  for (i = 0;i < edges.length;i++) {
    child = this.view.getState(edges[i]);
    source = null != child ? child.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
    child = null != child ? child.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
    if (includeLoops && source == child || source != child && (incoming && (child == cell && (null == parent || this.isValidAncestor(source, parent, recurse))) || outgoing && (source == cell && (null == parent || this.isValidAncestor(child, parent, recurse))))) {
      result.push(edges[i]);
    }
  }
  return result;
};
mxGraph.prototype.isValidAncestor = function(cell, parent, recurse) {
  return recurse ? this.model.isAncestor(parent, cell) : this.model.getParent(cell) == parent;
};
mxGraph.prototype.getOpposites = function(edges, terminal, sources, targets) {
  sources = null != sources ? sources : true;
  targets = null != targets ? targets : true;
  var terminals = [];
  var dict = new mxDictionary;
  if (null != edges) {
    for (var i = 0;i < edges.length;i++) {
      var cell = this.view.getState(edges[i]);
      var source = null != cell ? cell.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
      cell = null != cell ? cell.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
      if (source == terminal && (null != cell && (cell != terminal && targets))) {
        if (!dict.get(cell)) {
          dict.put(cell, true);
          terminals.push(cell);
        }
      } else {
        if (cell == terminal) {
          if (null != source) {
            if (source != terminal) {
              if (sources) {
                if (!dict.get(source)) {
                  dict.put(source, true);
                  terminals.push(source);
                }
              }
            }
          }
        }
      }
    }
  }
  return terminals;
};
mxGraph.prototype.getEdgesBetween = function(source, target, isConnect) {
  isConnect = null != isConnect ? isConnect : false;
  var edges = this.getEdges(source);
  var result = [];
  for (var i = 0;i < edges.length;i++) {
    var trg = this.view.getState(edges[i]);
    var src = null != trg ? trg.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
    trg = null != trg ? trg.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
    if (src == source && trg == target || !isConnect && (src == target && trg == source)) {
      result.push(edges[i]);
    }
  }
  return result;
};
mxGraph.prototype.getPointForEvent = function(evt, addOffset) {
  evt = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  var scale = this.view.scale;
  var tr = this.view.translate;
  addOffset = 0 != addOffset ? this.gridSize / 2 : 0;
  evt.x = this.snap(evt.x / scale - tr.x - addOffset);
  evt.y = this.snap(evt.y / scale - tr.y - addOffset);
  return evt;
};
mxGraph.prototype.getCells = function(x, y, width, height, parent, result, intersection, ignoreFn, includeDescendants) {
  result = null != result ? result : [];
  if (0 < width || (0 < height || null != intersection)) {
    var model = this.getModel();
    var right = x + width;
    var bottom = y + height;
    if (null == parent) {
      parent = this.getCurrentRoot();
      if (null == parent) {
        parent = model.getRoot();
      }
    }
    if (null != parent) {
      var childCount = model.getChildCount(parent);
      for (var i = 0;i < childCount;i++) {
        var cell = model.getChildAt(parent, i);
        var box = this.view.getState(cell);
        if (null != box && (this.isCellVisible(cell) && (null == ignoreFn || !ignoreFn(box)))) {
          var deg = mxUtils.getValue(box.style, mxConstants.STYLE_ROTATION) || 0;
          if (0 != deg) {
            box = mxUtils.getBoundingBox(box, deg);
          }
          if (deg = null != intersection && (model.isVertex(cell) && mxUtils.intersects(intersection, box)) || (null != intersection && (model.isEdge(cell) && mxUtils.intersects(intersection, box)) || null == intersection && ((model.isEdge(cell) || model.isVertex(cell)) && (box.x >= x && (box.y + box.height <= bottom && (box.y >= y && box.x + box.width <= right)))))) {
            result.push(cell);
          }
          if (!(deg && !includeDescendants)) {
            this.getCells(x, y, width, height, cell, result, intersection, ignoreFn, includeDescendants);
          }
        }
      }
    }
  }
  return result;
};
mxGraph.prototype.getCellsBeyond = function(x0, y0, cell, rightHalfpane, bottomHalfpane) {
  var result = [];
  if (rightHalfpane || bottomHalfpane) {
    if (null == cell && (cell = this.getDefaultParent()), null != cell) {
      var childCount = this.model.getChildCount(cell);
      for (var i = 0;i < childCount;i++) {
        var child = this.model.getChildAt(cell, i);
        var state = this.view.getState(child);
        if (this.isCellVisible(child)) {
          if (null != state) {
            if (!rightHalfpane || state.x >= x0) {
              if (!bottomHalfpane || state.y >= y0) {
                result.push(child);
              }
            }
          }
        }
      }
    }
  }
  return result;
};
mxGraph.prototype.findTreeRoots = function(parent, isolate, invert) {
  isolate = null != isolate ? isolate : false;
  invert = null != invert ? invert : false;
  var roots = [];
  if (null != parent) {
    var model = this.getModel();
    var childCount = model.getChildCount(parent);
    var best = null;
    var k = 0;
    for (var i = 0;i < childCount;i++) {
      var cell = model.getChildAt(parent, i);
      if (this.model.isVertex(cell) && this.isCellVisible(cell)) {
        var conns = this.getConnections(cell, isolate ? parent : null);
        var fanOut = 0;
        var fanIn = 0;
        for (var j = 0;j < conns.length;j++) {
          if (this.view.getVisibleTerminal(conns[j], true) == cell) {
            fanOut++;
          } else {
            fanIn++;
          }
        }
        if (invert && (0 == fanOut && 0 < fanIn) || !invert && (0 == fanIn && 0 < fanOut)) {
          roots.push(cell);
        }
        conns = invert ? fanIn - fanOut : fanOut - fanIn;
        if (conns > k) {
          k = conns;
          best = cell;
        }
      }
    }
    if (0 == roots.length) {
      if (null != best) {
        roots.push(best);
      }
    }
  }
  return roots;
};
mxGraph.prototype.traverse = function(vertex, directed, y2, cell, currentComp, hierarchyVertices) {
  if (null != y2 && (null != vertex && ((directed = null != directed ? directed : true, hierarchyVertices = null != hierarchyVertices ? hierarchyVertices : false, currentComp = currentComp || new mxDictionary, null == cell || !currentComp.get(cell)) && ((currentComp.put(cell, true), cell = y2(vertex, cell), null == cell || cell) && (cell = this.model.getEdgeCount(vertex), 0 < cell))))) {
    for (var i = 0;i < cell;i++) {
      var e = this.model.getEdgeAt(vertex, i);
      var next = this.model.getTerminal(e, true) == vertex;
      if (!(directed && !hierarchyVertices != next)) {
        next = this.model.getTerminal(e, !next);
        this.traverse(next, directed, y2, e, currentComp, hierarchyVertices);
      }
    }
  }
};
mxGraph.prototype.isCellSelected = function(cell) {
  return this.getSelectionModel().isSelected(cell);
};
mxGraph.prototype.isSelectionEmpty = function() {
  return this.getSelectionModel().isEmpty();
};
mxGraph.prototype.clearSelection = function() {
  return this.getSelectionModel().clear();
};
mxGraph.prototype.getSelectionCount = function() {
  return this.getSelectionModel().cells.length;
};
mxGraph.prototype.getSelectionCell = function() {
  return this.getSelectionModel().cells[0];
};
mxGraph.prototype.getSelectionCells = function() {
  return this.getSelectionModel().cells.slice();
};
mxGraph.prototype.setSelectionCell = function(cell) {
  this.getSelectionModel().setCell(cell);
};
mxGraph.prototype.setSelectionCells = function(cells) {
  this.getSelectionModel().setCells(cells);
};
mxGraph.prototype.addSelectionCell = function(cell) {
  this.getSelectionModel().addCell(cell);
};
mxGraph.prototype.addSelectionCells = function(cells) {
  this.getSelectionModel().addCells(cells);
};
mxGraph.prototype.removeSelectionCell = function(cell) {
  this.getSelectionModel().removeCell(cell);
};
mxGraph.prototype.removeSelectionCells = function(cells) {
  this.getSelectionModel().removeCells(cells);
};
mxGraph.prototype.selectRegion = function(rect, evt) {
  rect = this.getCells(rect.x, rect.y, rect.width, rect.height);
  this.selectCellsForEvent(rect, evt);
  return rect;
};
mxGraph.prototype.selectNextCell = function() {
  this.selectCell(true);
};
mxGraph.prototype.selectPreviousCell = function() {
  this.selectCell();
};
mxGraph.prototype.selectParentCell = function() {
  this.selectCell(false, true);
};
mxGraph.prototype.selectChildCell = function() {
  this.selectCell(false, false, true);
};
mxGraph.prototype.selectCell = function(parent, isNext, isChild) {
  var cell = this.selectionModel;
  var source = 0 < cell.cells.length ? cell.cells[0] : null;
  if (1 < cell.cells.length) {
    cell.clear();
  }
  cell = null != source ? this.model.getParent(source) : this.getDefaultParent();
  var childCount = this.model.getChildCount(cell);
  if (null == source && 0 < childCount) {
    parent = this.model.getChildAt(cell, 0);
    this.setSelectionCell(parent);
  } else {
    if (null != source && !isNext || (null == this.view.getState(cell) || null == this.model.getGeometry(cell))) {
      if (null != source && isChild) {
        if (0 < this.model.getChildCount(source)) {
          parent = this.model.getChildAt(source, 0);
          this.setSelectionCell(parent);
        }
      } else {
        if (0 < childCount) {
          isNext = cell.getIndex(source);
          if (parent) {
            isNext++;
            parent = this.model.getChildAt(cell, isNext % childCount);
          } else {
            isNext--;
            parent = this.model.getChildAt(cell, 0 > isNext ? childCount - 1 : isNext);
          }
          this.setSelectionCell(parent);
        }
      }
    } else {
      if (this.getCurrentRoot() != cell) {
        this.setSelectionCell(cell);
      }
    }
  }
};
mxGraph.prototype.selectAll = function(parent, cells) {
  parent = parent || this.getDefaultParent();
  cells = cells ? this.model.filterDescendants(mxUtils.bind(this, function(cell) {
    return cell != parent && null != this.view.getState(cell);
  }), parent) : this.model.getChildren(parent);
  if (null != cells) {
    this.setSelectionCells(cells);
  }
};
mxGraph.prototype.selectVertices = function(parent, selectGroups) {
  this.selectCells(true, false, parent, selectGroups);
};
mxGraph.prototype.selectEdges = function(parent) {
  this.selectCells(false, true, parent);
};
mxGraph.prototype.selectCells = function(vertices, edges, parent, selectGroups) {
  parent = parent || this.getDefaultParent();
  var filter = mxUtils.bind(this, function(cell) {
    return null != this.view.getState(cell) && ((selectGroups || 0 == this.model.getChildCount(cell)) && (this.model.isVertex(cell) && (vertices && !this.model.isEdge(this.model.getParent(cell)))) || this.model.isEdge(cell) && edges);
  });
  parent = this.model.filterDescendants(filter, parent);
  if (null != parent) {
    this.setSelectionCells(parent);
  }
};
mxGraph.prototype.selectCellForEvent = function(cell, evt) {
  var isSelected = this.isCellSelected(cell);
  if (this.isToggleEvent(evt)) {
    if (isSelected) {
      this.removeSelectionCell(cell);
    } else {
      this.addSelectionCell(cell);
    }
  } else {
    if (!(isSelected && 1 == this.getSelectionCount())) {
      this.setSelectionCell(cell);
    }
  }
};
mxGraph.prototype.selectCellsForEvent = function(cells, evt) {
  if (this.isToggleEvent(evt)) {
    this.addSelectionCells(cells);
  } else {
    this.setSelectionCells(cells);
  }
};
mxGraph.prototype.createHandler = function(state) {
  var source = null;
  if (null != state) {
    if (this.model.isEdge(state.cell)) {
      source = state.getVisibleTerminalState(true);
      var target = state.getVisibleTerminalState(false);
      var geo = this.getCellGeometry(state.cell);
      source = this.view.getEdgeStyle(state, null != geo ? geo.points : null, source, target);
      source = this.createEdgeHandler(state, source);
    } else {
      source = this.createVertexHandler(state);
    }
  }
  return source;
};
mxGraph.prototype.createVertexHandler = function(state) {
  return new mxVertexHandler(state);
};
mxGraph.prototype.createEdgeHandler = function(state, edgeStyle) {
  return edgeStyle == mxEdgeStyle.Loop || (edgeStyle == mxEdgeStyle.ElbowConnector || (edgeStyle == mxEdgeStyle.SideToSide || edgeStyle == mxEdgeStyle.TopToBottom)) ? this.createElbowEdgeHandler(state) : edgeStyle == mxEdgeStyle.SegmentConnector || edgeStyle == mxEdgeStyle.OrthConnector ? this.createEdgeSegmentHandler(state) : new mxEdgeHandler(state);
};
mxGraph.prototype.createEdgeSegmentHandler = function(state) {
  return new mxEdgeSegmentHandler(state);
};
mxGraph.prototype.createElbowEdgeHandler = function(state) {
  return new mxElbowEdgeHandler(state);
};
mxGraph.prototype.addMouseListener = function(listener) {
  if (null == this.mouseListeners) {
    this.mouseListeners = [];
  }
  this.mouseListeners.push(listener);
};
mxGraph.prototype.removeMouseListener = function(listener) {
  if (null != this.mouseListeners) {
    for (var i = 0;i < this.mouseListeners.length;i++) {
      if (this.mouseListeners[i] == listener) {
        this.mouseListeners.splice(i, 1);
        break;
      }
    }
  }
};
mxGraph.prototype.updateMouseEvent = function(me, evtName) {
  if (null == me.graphX || null == me.graphY) {
    var pt = mxUtils.convertPoint(this.container, me.getX(), me.getY());
    me.graphX = pt.x - this.panDx;
    me.graphY = pt.y - this.panDy;
    if (null == me.getCell()) {
      if (this.isMouseDown) {
        if (evtName == mxEvent.MOUSE_MOVE) {
          me.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function(state) {
            return null == state.shape || (state.shape.paintBackground != mxRectangleShape.prototype.paintBackground || ("1" == mxUtils.getValue(state.style, mxConstants.STYLE_POINTER_EVENTS, "1") || null != state.shape.fill && state.shape.fill != mxConstants.NONE));
          }));
        }
      }
    }
  }
  return me;
};
mxGraph.prototype.getStateForTouchEvent = function(evt) {
  var gridEnabled = mxEvent.getClientX(evt);
  evt = mxEvent.getClientY(evt);
  gridEnabled = mxUtils.convertPoint(this.container, gridEnabled, evt);
  return this.view.getState(this.getCellAt(gridEnabled.x, gridEnabled.y));
};
mxGraph.prototype.isEventIgnored = function(evtName, me, sender) {
  var mouseEvent = mxEvent.isMouseEvent(me.getEvent());
  var result = false;
  if (me.getEvent() == this.lastEvent) {
    result = true;
  } else {
    this.lastEvent = me.getEvent();
  }
  if (null != this.eventSource && evtName != mxEvent.MOUSE_MOVE) {
    mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
    this.eventSource = this.mouseUpRedirect = this.mouseMoveRedirect = null;
  } else {
    if (!mxClient.IS_GC && (null != this.eventSource && me.getSource() != this.eventSource)) {
      result = true;
    } else {
      if (mxClient.IS_TOUCH && (evtName == mxEvent.MOUSE_DOWN && (!mouseEvent && !mxEvent.isPenEvent(me.getEvent())))) {
        this.eventSource = me.getSource();
        var pointerId = null;
        if (!(!mxClient.IS_ANDROID && (mxClient.IS_LINUX && mxClient.IS_GC))) {
          pointerId = me.getEvent().pointerId;
        }
        this.mouseMoveRedirect = mxUtils.bind(this, function(evt) {
          if (!(null != pointerId && evt.pointerId != pointerId)) {
            this.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));
          }
        });
        this.mouseUpRedirect = mxUtils.bind(this, function(evt) {
          this.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));
          pointerId = null;
        });
        mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
      }
    }
  }
  if (this.isSyntheticEventIgnored(evtName, me, sender)) {
    result = true;
  }
  if (!mxEvent.isPopupTrigger(this.lastEvent) && (evtName != mxEvent.MOUSE_MOVE && 2 == this.lastEvent.detail)) {
    return true;
  }
  if (evtName == mxEvent.MOUSE_UP && this.isMouseDown) {
    this.isMouseDown = false;
  } else {
    if (evtName != mxEvent.MOUSE_DOWN || this.isMouseDown) {
      if (!result) {
        if ((!mxClient.IS_FF || evtName != mxEvent.MOUSE_MOVE) && (this.isMouseDown && this.isMouseTrigger != mouseEvent) || (evtName == mxEvent.MOUSE_DOWN && this.isMouseDown || evtName == mxEvent.MOUSE_UP && !this.isMouseDown)) {
          result = true;
        }
      }
    } else {
      this.isMouseDown = true;
      this.isMouseTrigger = mouseEvent;
    }
  }
  if (!result) {
    if (!(evtName != mxEvent.MOUSE_DOWN)) {
      this.lastMouseX = me.getX();
      this.lastMouseY = me.getY();
    }
  }
  return result;
};
mxGraph.prototype.isSyntheticEventIgnored = function(evtName, me, sender) {
  sender = false;
  me = mxEvent.isMouseEvent(me.getEvent());
  if (this.ignoreMouseEvents && (me && evtName != mxEvent.MOUSE_MOVE)) {
    this.ignoreMouseEvents = evtName != mxEvent.MOUSE_UP;
    sender = true;
  } else {
    if (mxClient.IS_FF) {
      if (!me) {
        if (evtName == mxEvent.MOUSE_UP) {
          this.ignoreMouseEvents = true;
        }
      }
    }
  }
  return sender;
};
mxGraph.prototype.isEventSourceIgnored = function(evtName, me) {
  var source = me.getSource();
  var tr = null != source.nodeName ? source.nodeName.toLowerCase() : "";
  me = !mxEvent.isMouseEvent(me.getEvent()) || mxEvent.isLeftMouseButton(me.getEvent());
  return evtName == mxEvent.MOUSE_DOWN && (me && ("select" == tr || ("option" == tr || "input" == tr && ("checkbox" != source.type && ("radio" != source.type && ("button" != source.type && ("submit" != source.type && "file" != source.type)))))));
};
mxGraph.prototype.getEventState = function(state) {
  return state;
};
mxGraph.prototype.isPointerEventIgnored = function(evtName, me) {
  var isPointerEventIgnored = false;
  if (mxClient.IS_ANDROID || (!mxClient.IS_LINUX || !mxClient.IS_GC)) {
    var currentPointerId = me.getEvent().pointerId;
    if (evtName == mxEvent.MOUSE_DOWN) {
      if (null != this.currentPointerId && this.currentPointerId != currentPointerId) {
        isPointerEventIgnored = true;
      } else {
        if (null == this.currentPointerId) {
          this.currentPointerId = me.getEvent().pointerId;
        }
      }
    } else {
      if (evtName == mxEvent.MOUSE_MOVE) {
        if (null != this.currentPointerId) {
          if (this.currentPointerId != currentPointerId) {
            isPointerEventIgnored = true;
          }
        }
      } else {
        if (evtName == mxEvent.MOUSE_UP) {
          this.currentPointerId = null;
        }
      }
    }
  }
  return isPointerEventIgnored;
};
mxGraph.prototype.fireMouseEvent = function(evtName, me, sender) {
  if (this.isEventSourceIgnored(evtName, me)) {
    if (null != this.tooltipHandler) {
      this.tooltipHandler.hide();
    }
  } else {
    if (this.isPointerEventIgnored(evtName, me)) {
      this.tapAndHoldValid = false;
    } else {
      if (null == sender) {
        sender = this;
      }
      me = this.updateMouseEvent(me, evtName);
      if (!this.nativeDblClickEnabled && !mxEvent.isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && (mxClient.IS_TOUCH && (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())))) {
        var s = (new Date).getTime();
        if (evtName == mxEvent.MOUSE_DOWN) {
          if (null != this.lastTouchEvent && (this.lastTouchEvent != me.getEvent() && (s - this.lastTouchTime < this.doubleTapTimeout && (Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && (Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && 2 > this.doubleClickCounter))))) {
            if (this.doubleClickCounter++, s = false, evtName == mxEvent.MOUSE_UP ? me.getCell() == this.lastTouchCell && (null != this.lastTouchCell && (this.lastTouchTime = 0, s = this.lastTouchCell, this.lastTouchCell = null, this.dblClick(me.getEvent(), s), s = true)) : (this.fireDoubleClick = true, this.lastTouchTime = 0), s) {
              mxEvent.consume(me.getEvent());
              return;
            }
          } else {
            if (null == this.lastTouchEvent || this.lastTouchEvent != me.getEvent()) {
              this.lastTouchCell = me.getCell();
              this.lastTouchX = me.getX();
              this.lastTouchY = me.getY();
              this.lastTouchTime = s;
              this.lastTouchEvent = me.getEvent();
              this.doubleClickCounter = 0;
            }
          }
        } else {
          if ((this.isMouseDown || evtName == mxEvent.MOUSE_UP) && this.fireDoubleClick) {
            this.fireDoubleClick = false;
            s = this.lastTouchCell;
            this.lastTouchCell = null;
            this.isMouseDown = false;
            if ((null != s || (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) && (mxClient.IS_GC || mxClient.IS_SF)) && (Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance)) {
              this.dblClick(me.getEvent(), s);
            } else {
              mxEvent.consume(me.getEvent());
            }
            return;
          }
        }
      }
      if (!this.isEventIgnored(evtName, me, sender)) {
        me.state = this.getEventState(me.getState());
        this.fireEvent(new mxEventObject(mxEvent.FIRE_MOUSE_EVENT, "eventName", evtName, "event", me));
        if (mxClient.IS_OP || (mxClient.IS_SF || (mxClient.IS_GC || (mxClient.IS_IE11 || (mxClient.IS_IE && mxClient.IS_SVG || me.getEvent().target != this.container))))) {
          if (evtName == mxEvent.MOUSE_MOVE && (this.isMouseDown && (this.autoScroll && !mxEvent.isMultiTouchEvent(me.getEvent)))) {
            this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);
          } else {
            if (evtName == mxEvent.MOUSE_UP && (this.ignoreScrollbars && (this.translateToScrollPosition && (0 != this.container.scrollLeft || 0 != this.container.scrollTop)))) {
              s = this.view.scale;
              var tr = this.view.translate;
              this.view.setTranslate(tr.x - this.container.scrollLeft / s, tr.y - this.container.scrollTop / s);
              this.container.scrollLeft = 0;
              this.container.scrollTop = 0;
            }
          }
          if (null != this.mouseListeners) {
            s = [sender, me];
            if (!me.getEvent().preventDefault) {
              me.getEvent().returnValue = true;
            }
            for (tr = 0;tr < this.mouseListeners.length;tr++) {
              var state = this.mouseListeners[tr];
              if (evtName == mxEvent.MOUSE_DOWN) {
                state.mouseDown.apply(state, s);
              } else {
                if (evtName == mxEvent.MOUSE_MOVE) {
                  state.mouseMove.apply(state, s);
                } else {
                  if (evtName == mxEvent.MOUSE_UP) {
                    state.mouseUp.apply(state, s);
                  }
                }
              }
            }
          }
          if (evtName == mxEvent.MOUSE_UP) {
            this.click(me);
          }
        }
        if ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) && (evtName == mxEvent.MOUSE_DOWN && (this.tapAndHoldEnabled && !this.tapAndHoldInProgress))) {
          this.tapAndHoldInProgress = true;
          this.initialTouchX = me.getGraphX();
          this.initialTouchY = me.getGraphY();
          if (this.tapAndHoldThread) {
            window.clearTimeout(this.tapAndHoldThread);
          }
          this.tapAndHoldThread = window.setTimeout(mxUtils.bind(this, function() {
            if (this.tapAndHoldValid) {
              this.tapAndHold(me);
            }
            this.tapAndHoldValid = this.tapAndHoldInProgress = false;
          }), this.tapAndHoldDelay);
          this.tapAndHoldValid = true;
        } else {
          if (evtName == mxEvent.MOUSE_UP) {
            this.tapAndHoldValid = this.tapAndHoldInProgress = false;
          } else {
            if (this.tapAndHoldValid) {
              this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;
            }
          }
        }
        if (evtName == mxEvent.MOUSE_DOWN) {
          if (this.isEditing()) {
            if (!this.cellEditor.isEventSource(me.getEvent())) {
              this.stopEditing(!this.isInvokesStopCellEditing());
            }
          }
        }
        this.consumeMouseEvent(evtName, me, sender);
      }
    }
  }
};
mxGraph.prototype.consumeMouseEvent = function(evtName, me, sender) {
  if (evtName == mxEvent.MOUSE_DOWN) {
    if (mxEvent.isTouchEvent(me.getEvent())) {
      me.consume(false);
    }
  }
};
mxGraph.prototype.fireGestureEvent = function(evt, cell) {
  this.lastTouchTime = 0;
  this.fireEvent(new mxEventObject(mxEvent.GESTURE, "event", evt, "cell", cell));
};
mxGraph.prototype.destroy = function() {
  if (!this.destroyed) {
    this.destroyed = true;
    if (null != this.tooltipHandler) {
      this.tooltipHandler.destroy();
    }
    if (null != this.selectionCellsHandler) {
      this.selectionCellsHandler.destroy();
    }
    if (null != this.panningHandler) {
      this.panningHandler.destroy();
    }
    if (null != this.popupMenuHandler) {
      this.popupMenuHandler.destroy();
    }
    if (null != this.connectionHandler) {
      this.connectionHandler.destroy();
    }
    if (null != this.graphHandler) {
      this.graphHandler.destroy();
    }
    if (null != this.cellEditor) {
      this.cellEditor.destroy();
    }
    if (null != this.view) {
      this.view.destroy();
    }
    if (null != this.model) {
      if (null != this.graphModelChangeListener) {
        this.model.removeListener(this.graphModelChangeListener);
        this.graphModelChangeListener = null;
      }
    }
    this.container = null;
  }
};
function mxCellOverlay(image, tooltip, align, verticalAlign, offset, cursor) {
  this.image = image;
  this.tooltip = tooltip;
  this.align = null != align ? align : this.align;
  this.verticalAlign = null != verticalAlign ? verticalAlign : this.verticalAlign;
  this.offset = null != offset ? offset : new mxPoint;
  this.cursor = null != cursor ? cursor : "help";
}
mxCellOverlay.prototype = new mxEventSource;
mxCellOverlay.prototype.constructor = mxCellOverlay;
mxCellOverlay.prototype.image = null;
mxCellOverlay.prototype.tooltip = null;
mxCellOverlay.prototype.align = mxConstants.ALIGN_RIGHT;
mxCellOverlay.prototype.verticalAlign = mxConstants.ALIGN_BOTTOM;
mxCellOverlay.prototype.offset = null;
mxCellOverlay.prototype.cursor = null;
mxCellOverlay.prototype.defaultOverlap = 0.5;
mxCellOverlay.prototype.getBounds = function(state) {
  var b = state.view.graph.getModel().isEdge(state.cell);
  var s = state.view.scale;
  var w = this.image.width;
  var h = this.image.height;
  if (b) {
    if (b = state.absolutePoints, 1 == b.length % 2) {
      b = b[Math.floor(b.length / 2)];
    } else {
      var i = b.length / 2;
      state = b[i - 1];
      b = b[i];
      b = new mxPoint(state.x + (b.x - state.x) / 2, state.y + (b.y - state.y) / 2);
    }
  } else {
    b = new mxPoint;
    b.x = this.align == mxConstants.ALIGN_LEFT ? state.x : this.align == mxConstants.ALIGN_CENTER ? state.x + state.width / 2 : state.x + state.width;
    b.y = this.verticalAlign == mxConstants.ALIGN_TOP ? state.y : this.verticalAlign == mxConstants.ALIGN_MIDDLE ? state.y + state.height / 2 : state.y + state.height;
  }
  return new mxRectangle(Math.round(b.x - (w * this.defaultOverlap - this.offset.x) * s), Math.round(b.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);
};
mxCellOverlay.prototype.toString = function() {
  return this.tooltip;
};
function mxOutline(source, container) {
  this.source = source;
  if (null != container) {
    this.init(container);
  }
}
mxOutline.prototype.source = null;
mxOutline.prototype.container = null;
mxOutline.prototype.enabled = true;
mxOutline.prototype.suspended = false;
mxOutline.prototype.border = 14;
mxOutline.prototype.opacity = mxClient.IS_IE11 ? 0.9 : 0.7;
mxOutline.prototype.init = function(container) {
  this.container = container;
  this.updateHandler = mxUtils.bind(this, function(flex, editor) {
    this.update(true);
  });
  this.source.getModel().addListener(mxEvent.CHANGE, this.updateHandler);
  this.source.addListener(mxEvent.REFRESH, this.updateHandler);
  container = this.source.getView();
  container.addListener(mxEvent.UP, this.updateHandler);
  container.addListener(mxEvent.DOWN, this.updateHandler);
  container.addListener(mxEvent.SCALE, this.updateHandler);
  container.addListener(mxEvent.TRANSLATE, this.updateHandler);
  container.addListener(mxEvent.SCALE_AND_TRANSLATE, this.updateHandler);
  this.scrollHandler = mxUtils.bind(this, function(flex, editor) {
    this.update(false);
  });
  mxEvent.addListener(this.source.container, "scroll", this.scrollHandler);
  this.source.addListener(mxEvent.PAN, this.scrollHandler);
  this.update(true);
};
mxOutline.prototype.isEnabled = function() {
  return this.enabled;
};
mxOutline.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxOutline.prototype.isSuspended = function() {
  return this.suspended;
};
mxOutline.prototype.setSuspended = function(flex) {
  this.suspended = flex;
  this.update(true);
};
mxOutline.prototype.isScrolling = function() {
  return this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container);
};
mxOutline.prototype.createSvg = function() {
  var node = document.createElementNS(mxConstants.NS_SVG, "svg");
  node.style.position = "absolute";
  node.style.left = "0px";
  node.style.top = "0px";
  node.style.width = "100%";
  node.style.height = "100%";
  node.style.display = "block";
  node.style.padding = this.border + "px";
  node.style.boxSizing = "border-box";
  node.style.overflow = "visible";
  node.style.cursor = "default";
  node.setAttribute("shape-rendering", "optimizeSpeed");
  node.setAttribute("image-rendering", "optimizeSpeed");
  return node;
};
mxOutline.prototype.addGestureListeners = function(node) {
  var offset = null;
  var top = 0;
  var left = 0;
  var scale = 1;
  var funct = mxUtils.bind(this, function(evt) {
    if (this.isEnabled()) {
      offset = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
      var dx = node.clientWidth - 2 * this.border;
      var y = node.clientHeight - 2 * this.border;
      var bounds = this.getViewBox();
      scale = Math.max(bounds.width / dx, bounds.height / y);
      if (mxEvent.getSource(evt) != this.viewport) {
        if (this.isScrolling()) {
          dx -= bounds.width / scale;
          y -= bounds.height / scale;
          var r = this.svg.getBoundingClientRect();
          this.source.container.scrollLeft = bounds.x - dx * scale / 2 + (offset.x - this.border - r.left) * scale;
          this.source.container.scrollTop = bounds.y - y * scale / 2 + (offset.y - this.border - r.top) * scale;
        } else {
          bounds = this.source.view.translate;
          y = this.viewport.getBoundingClientRect();
          dx = (mxEvent.getClientX(evt) - y.left) * scale / this.source.view.scale;
          y = (mxEvent.getClientY(evt) - y.top) * scale / this.source.view.scale;
          this.source.getView().setTranslate(bounds.x - dx, bounds.y - y);
          this.source.panGraph(0, 0);
        }
      }
      mxEvent.addGestureListeners(document, null, dragHandler, dropHandler);
      top = this.source.container.scrollLeft;
      left = this.source.container.scrollTop;
      mxEvent.consume(evt);
    }
  });
  var dragHandler = mxUtils.bind(this, function(evt) {
    if (this.isEnabled()) {
      if (null != offset) {
        if (this.isScrolling()) {
          this.source.container.scrollLeft = top + (mxEvent.getClientX(evt) - offset.x) * scale;
          this.source.container.scrollTop = left + (mxEvent.getClientY(evt) - offset.y) * scale;
        } else {
          this.source.panGraph((offset.x - mxEvent.getClientX(evt)) * scale, (offset.y - mxEvent.getClientY(evt)) * scale);
        }
        mxEvent.consume(evt);
      }
    }
  });
  var dropHandler = mxUtils.bind(this, function(evt) {
    if (this.isEnabled() && null != offset) {
      if (!this.isScrolling()) {
        var dx = (mxEvent.getClientX(evt) - offset.x) * scale / this.source.view.scale;
        var dy = (mxEvent.getClientY(evt) - offset.y) * scale / this.source.view.scale;
        var t = this.source.view.translate;
        this.source.getView().setTranslate(t.x - dx, t.y - dy);
        this.source.panGraph(0, 0);
      }
      mxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);
      mxEvent.consume(evt);
      offset = null;
    }
  });
  mxEvent.addGestureListeners(node, funct, dragHandler, dropHandler);
};
mxOutline.prototype.getViewBox = function() {
  return this.source.getGraphBounds();
};
mxOutline.prototype.updateSvg = function() {
  if (null == this.svg) {
    this.svg = this.createSvg();
    this.addGestureListeners(this.svg);
    this.container.appendChild(this.svg);
  }
  var bounds = this.getViewBox();
  this.svg.setAttribute("viewBox", Math.round(bounds.x) + " " + Math.round(bounds.y) + " " + Math.round(bounds.width) + " " + Math.round(bounds.height));
  bounds = this.source.background;
  this.svg.style.backgroundColor = bounds == mxConstants.NONE ? "" : bounds;
  this.updateDrawPane();
};
mxOutline.prototype.updateDrawPane = function() {
  if (null != this.drawPane) {
    this.drawPane.parentNode.removeChild(this.drawPane);
  }
  this.drawPane = this.source.view.getDrawPane().cloneNode(true);
  this.drawPane.style.opacity = this.opacity;
  this.processSvg(this.drawPane);
  if (null != this.viewport) {
    this.svg.insertBefore(this.drawPane, this.viewport);
  } else {
    this.svg.appendChild(this.drawPane);
  }
};
mxOutline.prototype.processSvg = function(doc) {
  var b = mxClient.IS_IE11 ? Math.max(1, this.source.view.scale) : this.source.view.scale;
  Array.prototype.slice.call(doc.getElementsByTagName("*")).forEach(mxUtils.bind(this, function(node) {
    if ("text" != node.nodeName && ("foreignObject" != node.nodeName && ("hidden" != node.getAttribute("visibility") && node instanceof SVGElement))) {
      var t = parseInt(node.getAttribute("stroke-width") || 1);
      if (!isNaN(t)) {
        node.setAttribute("stroke-width", Math.max(mxClient.IS_IE11 ? 4 : 1, t / (5 * b)));
      }
      node.setAttribute("vector-effect", "non-scaling-stroke");
      node.style.cursor = "";
    } else {
      node.parentNode.removeChild(node);
    }
  }));
};
mxOutline.prototype.updateViewport = function() {
  if (null != this.svg) {
    if (null == this.viewport) {
      this.viewport = this.createViewport();
      this.svg.appendChild(this.viewport);
    }
    var s = this.source.container;
    s = new mxRectangle(s.scrollLeft, s.scrollTop, s.clientWidth, s.clientHeight);
    if (!this.isScrolling()) {
      s.x = -this.source.panDx;
      s.y = -this.source.panDy;
    }
    this.viewport.setAttribute("x", s.x);
    this.viewport.setAttribute("y", s.y);
    this.viewport.setAttribute("width", s.width);
    this.viewport.setAttribute("height", s.height);
  }
};
mxOutline.prototype.createViewport = function() {
  var node = this.svg.ownerDocument.createElementNS(mxConstants.NS_SVG, "rect");
  node.setAttribute("stroke-width", mxClient.IS_IE11 ? "12" : "3");
  node.setAttribute("stroke", HoverIcons.prototype.arrowFill);
  node.setAttribute("fill", HoverIcons.prototype.arrowFill);
  node.setAttribute("vector-effect", "non-scaling-stroke");
  node.setAttribute("fill-opacity", 0.2);
  node.style.cursor = "move";
  return node;
};
mxOutline.prototype.update = function(revalidate) {
  if (null != this.source) {
    if (null != this.source.container) {
      if (null != this.thread) {
        window.clearTimeout(this.thread);
        this.thread = null;
      }
      this.fullUpdate = this.fullUpdate || revalidate;
      this.thread = window.setTimeout(mxUtils.bind(this, function() {
        if (!this.isSuspended()) {
          if (this.fullUpdate) {
            this.updateSvg();
          }
          this.updateViewport();
        }
        this.thread = this.fullUpdate = null;
      }), this.isScrolling() ? 10 : 0);
    }
  }
};
mxOutline.prototype.destroy = function() {
  if (null != this.svg) {
    this.svg.parentNode.removeChild(this.svg);
    this.svg = null;
  }
  if (null != this.source) {
    this.source.removeListener(this.updateHandler);
    this.source.getView().removeListener(this.updateHandler);
    this.source.getModel().removeListener(this.updateHandler);
    this.source.removeListener(mxEvent.PAN, this.scrollHandler);
    mxEvent.removeListener(this.source.container, "scroll", this.scrollHandler);
    this.source = null;
  }
};
function mxMultiplicity(source, type, attr, value, min, max, validNeighbors, cell, typeError, validNeighborsAllowed) {
  this.source = source;
  this.type = type;
  this.attr = attr;
  this.value = value;
  this.min = null != min ? min : 0;
  this.max = null != max ? max : "n";
  this.validNeighbors = validNeighbors;
  this.countError = mxResources.get(cell) || cell;
  this.typeError = mxResources.get(typeError) || typeError;
  this.validNeighborsAllowed = null != validNeighborsAllowed ? validNeighborsAllowed : true;
}
mxMultiplicity.prototype.type = null;
mxMultiplicity.prototype.attr = null;
mxMultiplicity.prototype.value = null;
mxMultiplicity.prototype.source = null;
mxMultiplicity.prototype.min = null;
mxMultiplicity.prototype.max = null;
mxMultiplicity.prototype.validNeighbors = null;
mxMultiplicity.prototype.validNeighborsAllowed = true;
mxMultiplicity.prototype.countError = null;
mxMultiplicity.prototype.typeError = null;
mxMultiplicity.prototype.check = function(graph, edge, source, target, sourceOut, targetIn) {
  var error = "";
  if (this.source && this.checkTerminal(graph, source, edge) || !this.source && this.checkTerminal(graph, target, edge)) {
    if (null != this.countError) {
      if (this.source && (0 == this.max || sourceOut >= this.max) || !this.source && (0 == this.max || targetIn >= this.max)) {
        error += this.countError + "\n";
      }
    }
    if (null != this.validNeighbors) {
      if (null != this.typeError) {
        if (0 < this.validNeighbors.length) {
          if (!this.checkNeighbors(graph, edge, source, target)) {
            error += this.typeError + "\n";
          }
        }
      }
    }
  }
  return 0 < error.length ? error : null;
};
mxMultiplicity.prototype.checkNeighbors = function(graph, child, cell, source) {
  child = graph.model.getValue(cell);
  source = graph.model.getValue(source);
  cell = !this.validNeighborsAllowed;
  var valid = this.validNeighbors;
  for (var j = 0;j < valid.length;j++) {
    if (this.source && this.checkType(graph, source, valid[j])) {
      cell = this.validNeighborsAllowed;
      break;
    } else {
      if (!this.source && this.checkType(graph, child, valid[j])) {
        cell = this.validNeighborsAllowed;
        break;
      }
    }
  }
  return cell;
};
mxMultiplicity.prototype.checkTerminal = function(graph, cell, edge) {
  cell = graph.model.getValue(cell);
  return this.checkType(graph, cell, this.type, this.attr, this.value);
};
mxMultiplicity.prototype.checkType = function(graph, value, type, attr, attrValue) {
  return null != value ? isNaN(value.nodeType) ? value == type : mxUtils.isNode(value, type, attr, attrValue) : false;
};
function mxLayoutManager(graph) {
  this.undoHandler = mxUtils.bind(this, function(flex, evt) {
    if (this.isEnabled()) {
      this.beforeUndo(evt.getProperty("edit"));
    }
  });
  this.moveHandler = mxUtils.bind(this, function(flex, evt) {
    if (this.isEnabled()) {
      this.cellsMoved(evt.getProperty("cells"), evt.getProperty("event"));
    }
  });
  this.resizeHandler = mxUtils.bind(this, function(flex, evt) {
    if (this.isEnabled()) {
      this.cellsResized(evt.getProperty("cells"), evt.getProperty("bounds"), evt.getProperty("previous"));
    }
  });
  this.setGraph(graph);
}
mxLayoutManager.prototype = new mxEventSource;
mxLayoutManager.prototype.constructor = mxLayoutManager;
mxLayoutManager.prototype.graph = null;
mxLayoutManager.prototype.bubbling = true;
mxLayoutManager.prototype.enabled = true;
mxLayoutManager.prototype.undoHandler = null;
mxLayoutManager.prototype.moveHandler = null;
mxLayoutManager.prototype.resizeHandler = null;
mxLayoutManager.prototype.isEnabled = function() {
  return this.enabled;
};
mxLayoutManager.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxLayoutManager.prototype.isBubbling = function() {
  return this.bubbling;
};
mxLayoutManager.prototype.setBubbling = function(value) {
  this.bubbling = value;
};
mxLayoutManager.prototype.getGraph = function() {
  return this.graph;
};
mxLayoutManager.prototype.setGraph = function(graph) {
  if (null != this.graph) {
    var model = this.graph.getModel();
    model.removeListener(this.undoHandler);
    this.graph.removeListener(this.moveHandler);
    this.graph.removeListener(this.resizeHandler);
  }
  this.graph = graph;
  if (null != this.graph) {
    model = this.graph.getModel();
    model.addListener(mxEvent.BEFORE_UNDO, this.undoHandler);
    this.graph.addListener(mxEvent.MOVE_CELLS, this.moveHandler);
    this.graph.addListener(mxEvent.RESIZE_CELLS, this.resizeHandler);
  }
};
mxLayoutManager.prototype.hasLayout = function(cell) {
  return null != this.getLayout(cell, mxEvent.LAYOUT_CELLS);
};
mxLayoutManager.prototype.getLayout = function(cell, eventName) {
  return null;
};
mxLayoutManager.prototype.beforeUndo = function(undoableEdit) {
  this.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));
};
mxLayoutManager.prototype.cellsMoved = function(cells, evt) {
  if (null != cells && null != evt) {
    evt = mxUtils.convertPoint(this.getGraph().container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
    var model = this.getGraph().getModel();
    for (var i = 0;i < cells.length;i++) {
      var layout = this.getLayout(model.getParent(cells[i]), mxEvent.MOVE_CELLS);
      if (null != layout) {
        layout.moveCell(cells[i], evt.x, evt.y);
      }
    }
  }
};
mxLayoutManager.prototype.cellsResized = function(cells, bounds, recurse) {
  if (null != cells && null != bounds) {
    var model = this.getGraph().getModel();
    for (var i = 0;i < cells.length;i++) {
      var layout = this.getLayout(model.getParent(cells[i]), mxEvent.RESIZE_CELLS);
      if (null != layout) {
        layout.resizeCell(cells[i], bounds[i], recurse[i]);
      }
    }
  }
};
mxLayoutManager.prototype.getCellsForChanges = function(changes) {
  var result = [];
  for (var i = 0;i < changes.length;i++) {
    var change = changes[i];
    if (change instanceof mxRootChange) {
      return[];
    }
    result = result.concat(this.getCellsForChange(change));
  }
  return result;
};
mxLayoutManager.prototype.getCellsForChange = function(change) {
  return change instanceof mxChildChange ? this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous)) : change instanceof mxValueChange || (change instanceof mxTerminalChange || (change instanceof mxGeometryChange || (change instanceof mxVisibleChange || change instanceof mxStyleChange))) ? this.addCellsWithLayout(change.cell) : [];
};
mxLayoutManager.prototype.addCellsWithLayout = function(cell, result) {
  return this.addDescendantsWithLayout(cell, this.addAncestorsWithLayout(cell, result));
};
mxLayoutManager.prototype.addAncestorsWithLayout = function(cell, result) {
  result = null != result ? result : [];
  if (null != cell && (this.hasLayout(cell) && result.push(cell), this.isBubbling())) {
    var model = this.getGraph().getModel();
    this.addAncestorsWithLayout(model.getParent(cell), result);
  }
  return result;
};
mxLayoutManager.prototype.addDescendantsWithLayout = function(cell, result) {
  result = null != result ? result : [];
  if (null != cell && this.hasLayout(cell)) {
    var model = this.getGraph().getModel();
    for (var i = 0;i < model.getChildCount(cell);i++) {
      var child = model.getChildAt(cell, i);
      if (this.hasLayout(child)) {
        result.push(child);
        this.addDescendantsWithLayout(child, result);
      }
    }
  }
  return result;
};
mxLayoutManager.prototype.executeLayoutForCells = function(cells) {
  var model = this.getGraph().getModel();
  model.beginUpdate();
  try {
    var sorted = mxUtils.sortCells(cells, false);
    this.layoutCells(sorted, true);
    this.layoutCells(sorted.reverse(), false);
  } finally {
    model.endUpdate();
  }
};
mxLayoutManager.prototype.layoutCells = function(cells, bubble) {
  if (0 < cells.length) {
    var model = this.getGraph().getModel();
    model.beginUpdate();
    try {
      var last = null;
      for (var i = 0;i < cells.length;i++) {
        if (cells[i] != model.getRoot()) {
          if (cells[i] != last) {
            this.executeLayout(cells[i], bubble);
            last = cells[i];
          }
        }
      }
      this.fireEvent(new mxEventObject(mxEvent.LAYOUT_CELLS, "cells", cells));
    } finally {
      model.endUpdate();
    }
  }
};
mxLayoutManager.prototype.executeLayout = function(parent, bubble) {
  bubble = this.getLayout(parent, bubble ? mxEvent.BEGIN_UPDATE : mxEvent.END_UPDATE);
  if (null != bubble) {
    bubble.execute(parent);
  }
};
mxLayoutManager.prototype.destroy = function() {
  this.setGraph(null);
};
function mxSwimlaneManager(graph, horizontal, addEnabled, resizeEnabled) {
  this.horizontal = null != horizontal ? horizontal : true;
  this.addEnabled = null != addEnabled ? addEnabled : true;
  this.resizeEnabled = null != resizeEnabled ? resizeEnabled : true;
  this.addHandler = mxUtils.bind(this, function(flex, evt) {
    if (this.isEnabled()) {
      if (this.isAddEnabled()) {
        this.cellsAdded(evt.getProperty("cells"));
      }
    }
  });
  this.resizeHandler = mxUtils.bind(this, function(flex, evt) {
    if (this.isEnabled()) {
      if (this.isResizeEnabled()) {
        this.cellsResized(evt.getProperty("cells"));
      }
    }
  });
  this.setGraph(graph);
}
mxSwimlaneManager.prototype = new mxEventSource;
mxSwimlaneManager.prototype.constructor = mxSwimlaneManager;
mxSwimlaneManager.prototype.graph = null;
mxSwimlaneManager.prototype.enabled = true;
mxSwimlaneManager.prototype.horizontal = true;
mxSwimlaneManager.prototype.addEnabled = true;
mxSwimlaneManager.prototype.resizeEnabled = true;
mxSwimlaneManager.prototype.addHandler = null;
mxSwimlaneManager.prototype.resizeHandler = null;
mxSwimlaneManager.prototype.isEnabled = function() {
  return this.enabled;
};
mxSwimlaneManager.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxSwimlaneManager.prototype.isHorizontal = function() {
  return this.horizontal;
};
mxSwimlaneManager.prototype.setHorizontal = function(value) {
  this.horizontal = value;
};
mxSwimlaneManager.prototype.isAddEnabled = function() {
  return this.addEnabled;
};
mxSwimlaneManager.prototype.setAddEnabled = function(value) {
  this.addEnabled = value;
};
mxSwimlaneManager.prototype.isResizeEnabled = function() {
  return this.resizeEnabled;
};
mxSwimlaneManager.prototype.setResizeEnabled = function(value) {
  this.resizeEnabled = value;
};
mxSwimlaneManager.prototype.getGraph = function() {
  return this.graph;
};
mxSwimlaneManager.prototype.setGraph = function(graph) {
  if (null != this.graph) {
    this.graph.removeListener(this.addHandler);
    this.graph.removeListener(this.resizeHandler);
  }
  this.graph = graph;
  if (null != this.graph) {
    this.graph.addListener(mxEvent.ADD_CELLS, this.addHandler);
    this.graph.addListener(mxEvent.CELLS_RESIZED, this.resizeHandler);
  }
};
mxSwimlaneManager.prototype.isSwimlaneIgnored = function(cell) {
  return!this.getGraph().isSwimlane(cell);
};
mxSwimlaneManager.prototype.isCellHorizontal = function(cell) {
  return this.graph.isSwimlane(cell) ? (cell = this.graph.getCellStyle(cell), 1 == mxUtils.getValue(cell, mxConstants.STYLE_HORIZONTAL, 1)) : !this.isHorizontal();
};
mxSwimlaneManager.prototype.cellsAdded = function(cells) {
  if (null != cells) {
    var model = this.getGraph().getModel();
    model.beginUpdate();
    try {
      for (var i = 0;i < cells.length;i++) {
        if (!this.isSwimlaneIgnored(cells[i])) {
          this.swimlaneAdded(cells[i]);
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
mxSwimlaneManager.prototype.swimlaneAdded = function(swimlane) {
  var model = this.getGraph().getModel();
  var parent = model.getParent(swimlane);
  var childCount = model.getChildCount(parent);
  var geo = null;
  for (var i = 0;i < childCount;i++) {
    var child = model.getChildAt(parent, i);
    if (child != swimlane && (!this.isSwimlaneIgnored(child) && (geo = model.getGeometry(child), null != geo))) {
      break;
    }
  }
  if (null != geo) {
    model = null != parent ? this.isCellHorizontal(parent) : this.horizontal;
    this.resizeSwimlane(swimlane, geo.width, geo.height, model);
  }
};
mxSwimlaneManager.prototype.cellsResized = function(cells) {
  if (null != cells) {
    var model = this.getGraph().getModel();
    model.beginUpdate();
    try {
      for (var i = 0;i < cells.length;i++) {
        if (!this.isSwimlaneIgnored(cells[i])) {
          var geo = model.getGeometry(cells[i]);
          if (null != geo) {
            var size = new mxRectangle(0, 0, geo.width, geo.height);
            var top = cells[i];
            for (var current = top;null != current;) {
              top = current;
              current = model.getParent(current);
              var tmp = this.graph.isSwimlane(current) ? this.graph.getStartSize(current) : new mxRectangle;
              size.width += tmp.width;
              size.height += tmp.height;
            }
            var parentHorizontal = null != current ? this.isCellHorizontal(current) : this.horizontal;
            this.resizeSwimlane(top, size.width, size.height, parentHorizontal);
          }
        }
      }
    } finally {
      model.endUpdate();
    }
  }
};
mxSwimlaneManager.prototype.resizeSwimlane = function(cell, w, h, i) {
  var model = this.getGraph().getModel();
  model.beginUpdate();
  try {
    var horizontal = this.isCellHorizontal(cell);
    if (!this.isSwimlaneIgnored(cell)) {
      var geo = model.getGeometry(cell);
      if (null != geo) {
        if (i && geo.height != h || !i && geo.width != w) {
          geo = geo.clone();
          if (i) {
            geo.height = h;
          } else {
            geo.width = w;
          }
          model.setGeometry(cell, geo);
        }
      }
    }
    var tmp = this.graph.isSwimlane(cell) ? this.graph.getStartSize(cell) : new mxRectangle;
    w -= tmp.width;
    h -= tmp.height;
    var childCount = model.getChildCount(cell);
    for (i = 0;i < childCount;i++) {
      var child = model.getChildAt(cell, i);
      this.resizeSwimlane(child, w, h, horizontal);
    }
  } finally {
    model.endUpdate();
  }
};
mxSwimlaneManager.prototype.destroy = function() {
  this.setGraph(null);
};
function mxTemporaryCellStates(view, scale, cells, isCellVisibleFn, getLinkForCellState, ignoreFn) {
  scale = null != scale ? scale : 1;
  this.view = view;
  this.oldValidateCellState = view.validateCellState;
  this.oldBounds = view.getGraphBounds();
  this.oldStates = view.getStates();
  this.oldScale = view.getScale();
  this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;
  var self = this;
  if (null != getLinkForCellState) {
    view.graph.cellRenderer.doRedrawShape = function(state) {
      var oldPaint = state.shape.paint;
      state.shape.paint = function(c) {
        var link = getLinkForCellState(state);
        if (null != link) {
          c.setLink(link, null != ignoreFn ? ignoreFn(state) : null);
        }
        oldPaint.apply(this, arguments);
        if (null != link) {
          c.setLink(null);
        }
      };
      self.oldDoRedrawShape.apply(view.graph.cellRenderer, arguments);
      state.shape.paint = oldPaint;
    };
  }
  view.validateCellState = function(cell, layer) {
    return null == cell || (null == isCellVisibleFn || isCellVisibleFn(cell)) ? self.oldValidateCellState.apply(view, arguments) : null;
  };
  view.setStates(new mxDictionary);
  view.setScale(scale);
  if (null != cells) {
    view.resetValidationState();
    scale = null;
    for (var i = 0;i < cells.length;i++) {
      var parent = view.getBoundingBox(view.validateCellState(view.validateCell(cells[i])));
      if (null == scale) {
        scale = parent;
      } else {
        scale.add(parent);
      }
    }
    view.setGraphBounds(scale || new mxRectangle);
  }
}
mxTemporaryCellStates.prototype.view = null;
mxTemporaryCellStates.prototype.oldStates = null;
mxTemporaryCellStates.prototype.oldBounds = null;
mxTemporaryCellStates.prototype.oldScale = null;
mxTemporaryCellStates.prototype.destroy = function() {
  this.view.setScale(this.oldScale);
  this.view.setStates(this.oldStates);
  this.view.setGraphBounds(this.oldBounds);
  this.view.validateCellState = this.oldValidateCellState;
  this.view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;
};
function mxCellStatePreview(graph) {
  this.deltas = new mxDictionary;
  this.graph = graph;
}
mxCellStatePreview.prototype.graph = null;
mxCellStatePreview.prototype.deltas = null;
mxCellStatePreview.prototype.count = 0;
mxCellStatePreview.prototype.isEmpty = function() {
  return 0 == this.count;
};
mxCellStatePreview.prototype.moveState = function(state, dx, dy, add, includeEdges) {
  add = null != add ? add : true;
  includeEdges = null != includeEdges ? includeEdges : true;
  var delta = this.deltas.get(state.cell);
  if (null == delta) {
    delta = {
      point : new mxPoint(dx, dy),
      state : state
    };
    this.deltas.put(state.cell, delta);
    this.count++;
  } else {
    if (add) {
      delta.point.x += dx;
      delta.point.y += dy;
    } else {
      delta.point.x = dx;
      delta.point.y = dy;
    }
  }
  if (includeEdges) {
    this.addEdges(state);
  }
  return delta.point;
};
mxCellStatePreview.prototype.show = function(visitor) {
  this.deltas.visit(mxUtils.bind(this, function(flex, delta) {
    this.translateState(delta.state, delta.point.x, delta.point.y);
  }));
  this.deltas.visit(mxUtils.bind(this, function(flex, delta) {
    this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);
  }));
};
mxCellStatePreview.prototype.translateState = function(state, dx, dy) {
  if (null != state) {
    var model = this.graph.getModel();
    if (model.isVertex(state.cell)) {
      state.view.updateCellState(state);
      var geo = model.getGeometry(state.cell);
      if (!(0 == dx && 0 == dy)) {
        if (!(null == geo)) {
          if (!(geo.relative && null == this.deltas.get(state.cell))) {
            state.x += dx;
            state.y += dy;
          }
        }
      }
    }
    geo = model.getChildCount(state.cell);
    for (var i = 0;i < geo;i++) {
      this.translateState(state.view.getState(model.getChildAt(state.cell, i)), dx, dy);
    }
  }
};
mxCellStatePreview.prototype.revalidateState = function(state, dx, dy, visitor) {
  if (null != state) {
    var model = this.graph.getModel();
    if (model.isEdge(state.cell)) {
      state.view.updateCellState(state);
    }
    var geo = this.graph.getCellGeometry(state.cell);
    var i = state.view.getState(model.getParent(state.cell));
    if (!(0 == dx && 0 == dy)) {
      if (!(null == geo)) {
        if (!!geo.relative) {
          if (!!model.isVertex(state.cell)) {
            if (!(null != i && (!model.isVertex(i.cell) && null == this.deltas.get(state.cell)))) {
              state.x += dx;
              state.y += dy;
            }
          }
        }
      }
    }
    this.graph.cellRenderer.redraw(state);
    if (null != visitor) {
      visitor(state);
    }
    geo = model.getChildCount(state.cell);
    for (i = 0;i < geo;i++) {
      this.revalidateState(this.graph.view.getState(model.getChildAt(state.cell, i)), dx, dy, visitor);
    }
  }
};
mxCellStatePreview.prototype.addEdges = function(state) {
  var model = this.graph.getModel();
  var childCount = model.getEdgeCount(state.cell);
  for (var i = 0;i < childCount;i++) {
    var s = state.view.getState(model.getEdgeAt(state.cell, i));
    if (null != s) {
      this.moveState(s, 0, 0);
    }
  }
};
function mxConnectionConstraint(point, perimeter, name, dx, dy) {
  this.point = point;
  this.perimeter = null != perimeter ? perimeter : true;
  this.name = name;
  this.dx = dx ? dx : 0;
  this.dy = dy ? dy : 0;
}
mxConnectionConstraint.prototype.point = null;
mxConnectionConstraint.prototype.perimeter = null;
mxConnectionConstraint.prototype.name = null;
mxConnectionConstraint.prototype.dx = null;
mxConnectionConstraint.prototype.dy = null;
function mxGraphHandler(graph) {
  this.graph = graph;
  this.graph.addMouseListener(this);
  this.panHandler = mxUtils.bind(this, function() {
    if (!this.suspended) {
      this.updatePreview();
      this.updateHint();
    }
  });
  this.graph.addListener(mxEvent.PAN, this.panHandler);
  this.escapeHandler = mxUtils.bind(this, function(flex, editor) {
    this.reset();
  });
  this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  this.refreshHandler = mxUtils.bind(this, function(flex, editor) {
    if (this.refreshThread) {
      window.clearTimeout(this.refreshThread);
    }
    this.refreshThread = window.setTimeout(mxUtils.bind(this, function() {
      this.refreshThread = null;
      if (null != this.first && !this.suspended) {
        var dx = this.currentDx;
        var dy = this.currentDy;
        this.currentDy = this.currentDx = 0;
        this.updatePreview();
        this.bounds = this.graph.getView().getBounds(this.cells);
        this.pBounds = this.getPreviewBounds(this.cells);
        if (null != this.pBounds || this.livePreviewUsed) {
          this.currentDx = dx;
          this.currentDy = dy;
          this.updatePreview();
          this.updateHint();
          if (this.livePreviewUsed) {
            this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), false, true);
            this.updatePreview();
          }
        } else {
          this.reset();
        }
      }
    }), 0);
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.addListener(mxEvent.REFRESH, this.refreshHandler);
  this.keyHandler = mxUtils.bind(this, function(clone) {
    if (!(null == this.graph.container)) {
      if (!("hidden" == this.graph.container.style.visibility)) {
        if (!(null == this.first)) {
          if (!this.suspended) {
            clone = this.graph.isCloneEvent(clone) && (this.graph.isCellsCloneable() && this.isCloneEnabled());
            if (clone != this.cloning) {
              this.cloning = clone;
              this.checkPreview();
              this.updatePreview();
            }
          }
        }
      }
    }
  });
  mxEvent.addListener(document, "keydown", this.keyHandler);
  mxEvent.addListener(document, "keyup", this.keyHandler);
}
mxGraphHandler.prototype.graph = null;
mxGraphHandler.prototype.maxCells = mxClient.IS_IE ? 20 : 50;
mxGraphHandler.prototype.enabled = true;
mxGraphHandler.prototype.highlightEnabled = true;
mxGraphHandler.prototype.cloneEnabled = true;
mxGraphHandler.prototype.moveEnabled = true;
mxGraphHandler.prototype.guidesEnabled = false;
mxGraphHandler.prototype.handlesVisible = true;
mxGraphHandler.prototype.guide = null;
mxGraphHandler.prototype.currentDx = null;
mxGraphHandler.prototype.currentDy = null;
mxGraphHandler.prototype.updateCursor = true;
mxGraphHandler.prototype.selectEnabled = true;
mxGraphHandler.prototype.removeCellsFromParent = true;
mxGraphHandler.prototype.removeEmptyParents = false;
mxGraphHandler.prototype.connectOnDrop = false;
mxGraphHandler.prototype.scrollOnMove = true;
mxGraphHandler.prototype.minimumSize = 6;
mxGraphHandler.prototype.previewColor = "black";
mxGraphHandler.prototype.htmlPreview = false;
mxGraphHandler.prototype.shape = null;
mxGraphHandler.prototype.scaleGrid = false;
mxGraphHandler.prototype.rotationEnabled = true;
mxGraphHandler.prototype.maxLivePreview = 0;
mxGraphHandler.prototype.allowLivePreview = mxClient.IS_SVG;
mxGraphHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxGraphHandler.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxGraphHandler.prototype.isCloneEnabled = function() {
  return this.cloneEnabled;
};
mxGraphHandler.prototype.setCloneEnabled = function(value) {
  this.cloneEnabled = value;
};
mxGraphHandler.prototype.isMoveEnabled = function() {
  return this.moveEnabled;
};
mxGraphHandler.prototype.setMoveEnabled = function(value) {
  this.moveEnabled = value;
};
mxGraphHandler.prototype.isSelectEnabled = function() {
  return this.selectEnabled;
};
mxGraphHandler.prototype.setSelectEnabled = function(value) {
  this.selectEnabled = value;
};
mxGraphHandler.prototype.isRemoveCellsFromParent = function() {
  return this.removeCellsFromParent;
};
mxGraphHandler.prototype.setRemoveCellsFromParent = function(value) {
  this.removeCellsFromParent = value;
};
mxGraphHandler.prototype.isPropagateSelectionCell = function(cell, immediate, me) {
  var parent = this.graph.model.getParent(cell);
  return immediate ? (immediate = this.graph.model.isEdge(cell) ? null : this.graph.getCellGeometry(cell), !this.graph.isSiblingSelected(cell) && (null != immediate && immediate.relative || !this.graph.isSwimlane(parent))) : (!this.graph.isToggleEvent(me.getEvent()) || (!this.graph.isSiblingSelected(cell) && (!this.graph.isCellSelected(cell) && !this.graph.isSwimlane(parent)) || this.graph.isCellSelected(parent))) && (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent));
};
mxGraphHandler.prototype.getInitialCellForEvent = function(me) {
  var state = me.getState();
  if (!(this.graph.isToggleEvent(me.getEvent()) && mxEvent.isAltDown(me.getEvent()) || (null == state || this.graph.isCellSelected(state.cell)))) {
    var model = this.graph.model;
    for (var next = this.graph.view.getState(model.getParent(state.cell));null != next && (!this.graph.isCellSelected(next.cell) && ((model.isVertex(next.cell) || model.isEdge(next.cell)) && this.isPropagateSelectionCell(state.cell, true, me)));) {
      state = next;
      next = this.graph.view.getState(this.graph.getModel().getParent(state.cell));
    }
  }
  return null != state ? state.cell : null;
};
mxGraphHandler.prototype.isDelayedSelection = function(cell, me) {
  if (!this.graph.isToggleEvent(me.getEvent()) || !mxEvent.isAltDown(me.getEvent())) {
    for (;null != cell;) {
      if (this.graph.selectionCellsHandler.isHandled(cell)) {
        return this.graph.cellEditor.getEditingCell() != cell;
      }
      cell = this.graph.model.getParent(cell);
    }
  }
  return this.graph.isToggleEvent(me.getEvent()) && !mxEvent.isAltDown(me.getEvent());
};
mxGraphHandler.prototype.selectDelayed = function(me) {
  if (!this.graph.popupMenuHandler.isPopupTrigger(me)) {
    var cell = me.getCell();
    if (null == cell) {
      cell = this.cell;
    }
    this.selectCellForEvent(cell, me);
  }
};
mxGraphHandler.prototype.selectCellForEvent = function(cell, me) {
  var model = this.graph.view.getState(cell);
  if (null != model) {
    if (!(me.isSource(model.control) || this.graph.isToggleEvent(me.getEvent()) && mxEvent.isAltDown(me.getEvent()))) {
      model = this.graph.getModel();
      for (var parent = model.getParent(cell);null != this.graph.view.getState(parent) && ((model.isVertex(parent) || model.isEdge(parent) && !this.graph.isToggleEvent(me.getEvent())) && this.isPropagateSelectionCell(cell, false, me));) {
        cell = parent;
        parent = model.getParent(cell);
      }
    }
    this.graph.selectCellForEvent(cell, me.getEvent());
  }
  return cell;
};
mxGraphHandler.prototype.consumeMouseEvent = function(evtName, me) {
  me.consume();
};
mxGraphHandler.prototype.mouseDown = function(cell, me) {
  if (!me.isConsumed() && (this.isEnabled() && (this.graph.isEnabled() && (null != me.getState() && (!mxEvent.isMultiTouchEvent(me.getEvent()) && (cell = this.getInitialCellForEvent(me), this.delayedSelection = this.isDelayedSelection(cell, me), this.cell = null, this.isSelectEnabled() && (!this.delayedSelection && this.graph.selectCellForEvent(cell, me.getEvent())), this.isMoveEnabled())))))) {
    var model = this.graph.model;
    var geo = model.getGeometry(cell);
    if (this.graph.isCellMovable(cell) && (!model.isEdge(cell) || (1 < this.graph.getSelectionCount() || (null != geo.points && 0 < geo.points.length || (null == model.getTerminal(cell, true) || (null == model.getTerminal(cell, false) || (this.graph.allowDanglingEdges || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable()))))))) {
      this.start(cell, me.getX(), me.getY());
    } else {
      if (this.delayedSelection) {
        this.cell = cell;
      }
    }
    this.cellWasClicked = true;
    this.consumeMouseEvent(mxEvent.MOUSE_DOWN, me);
  }
};
mxGraphHandler.prototype.getGuideStates = function() {
  var parent = this.graph.getDefaultParent();
  var model = this.graph.getModel();
  var filter = mxUtils.bind(this, function(cell) {
    return null != this.graph.view.getState(cell) && (model.isVertex(cell) && (null != model.getGeometry(cell) && !model.getGeometry(cell).relative));
  });
  return this.graph.view.getCellStates(model.filterDescendants(filter, parent));
};
mxGraphHandler.prototype.getCells = function(x) {
  return!this.delayedSelection && this.graph.isCellMovable(x) ? [x] : this.graph.getMovableCells(this.graph.getSelectionCells());
};
mxGraphHandler.prototype.getPreviewBounds = function(bounds) {
  bounds = this.getBoundingBox(bounds);
  if (null != bounds) {
    bounds.width = Math.max(0, bounds.width - 1);
    bounds.height = Math.max(0, bounds.height - 1);
    if (bounds.width < this.minimumSize) {
      bounds.x -= (this.minimumSize - bounds.width) / 2;
      bounds.width = this.minimumSize;
    } else {
      bounds.x = Math.round(bounds.x);
      bounds.width = Math.ceil(bounds.width);
    }
    if (bounds.height < this.minimumSize) {
      bounds.y -= (this.minimumSize - bounds.height) / 2;
      bounds.height = this.minimumSize;
    } else {
      bounds.y = Math.round(bounds.y);
      bounds.height = Math.ceil(bounds.height);
    }
  }
  return bounds;
};
mxGraphHandler.prototype.getBoundingBox = function(cells) {
  var result = null;
  if (null != cells && 0 < cells.length) {
    var model = this.graph.getModel();
    for (var i = 0;i < cells.length;i++) {
      if (model.isVertex(cells[i]) || model.isEdge(cells[i])) {
        var state = this.graph.view.getState(cells[i]);
        if (null != state) {
          var parent = state;
          if (model.isVertex(cells[i])) {
            if (null != state.shape) {
              if (null != state.shape.boundingBox) {
                parent = state.shape.boundingBox;
              }
            }
          }
          if (null == result) {
            result = mxRectangle.fromRectangle(parent);
          } else {
            result.add(parent);
          }
        }
      }
    }
  }
  return result;
};
mxGraphHandler.prototype.createPreviewShape = function(shape) {
  shape = new mxRectangleShape(shape, null, this.previewColor);
  shape.isDashed = true;
  if (this.htmlPreview) {
    shape.dialect = mxConstants.DIALECT_STRICTHTML;
    shape.init(this.graph.container);
  } else {
    shape.dialect = mxConstants.DIALECT_SVG;
    shape.init(this.graph.getView().getOverlayPane());
    shape.pointerEvents = false;
    if (mxClient.IS_IOS) {
      shape.getSvgScreenOffset = function() {
        return 0;
      };
    }
  }
  return shape;
};
mxGraphHandler.prototype.start = function(cell, x, index, cells) {
  this.cell = cell;
  this.first = mxUtils.convertPoint(this.graph.container, x, index);
  this.cells = null != cells ? cells : this.getCells(this.cell);
  this.bounds = this.graph.getView().getBounds(this.cells);
  this.pBounds = this.getPreviewBounds(this.cells);
  this.allCells = new mxDictionary;
  this.cloning = false;
  for (x = this.cellCount = 0;x < this.cells.length;x++) {
    this.cellCount += this.addStates(this.cells[x], this.allCells);
  }
  if (this.guidesEnabled) {
    this.guide = new mxGuide(this.graph, this.getGuideStates());
    var parent = this.graph.model.getParent(cell);
    var f = 2 > this.graph.model.getChildCount(parent);
    var dict = new mxDictionary;
    cell = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
    for (x = 0;x < cell.length;x++) {
      index = this.graph.view.getState(cell[x]);
      if (!(null == index)) {
        if (!dict.get(index)) {
          dict.put(index, true);
        }
      }
    }
    this.guide.isStateIgnored = mxUtils.bind(this, function(cell) {
      var p = this.graph.model.getParent(cell.cell);
      return null != cell.cell && (!this.cloning && this.isCellMoving(cell.cell) || cell.cell != (this.target || parent) && (!f && (!dict.get(cell) && ((null == this.target || 2 <= this.graph.model.getChildCount(this.target)) && p != (this.target || parent)))));
    });
  }
};
mxGraphHandler.prototype.addStates = function(cell, dict) {
  var state = this.graph.view.getState(cell);
  var count = 0;
  if (null != state && null == dict.get(cell)) {
    dict.put(cell, state);
    count++;
    state = this.graph.model.getChildCount(cell);
    for (var i = 0;i < state;i++) {
      count += this.addStates(this.graph.model.getChildAt(cell, i), dict);
    }
  }
  return count;
};
mxGraphHandler.prototype.isCellMoving = function(cell) {
  return null != this.allCells.get(cell);
};
mxGraphHandler.prototype.useGuidesForEvent = function(me) {
  return null != this.guide ? this.guide.isEnabledForEvent(me.getEvent()) && !this.isConstrainedEvent(me) : true;
};
mxGraphHandler.prototype.snap = function(vector) {
  var scale = this.scaleGrid ? this.graph.view.scale : 1;
  vector.x = this.graph.snap(vector.x / scale) * scale;
  vector.y = this.graph.snap(vector.y / scale) * scale;
  return vector;
};
mxGraphHandler.prototype.getDelta = function(state) {
  state = mxUtils.convertPoint(this.graph.container, state.getX(), state.getY());
  return new mxPoint(state.x - this.first.x - this.graph.panDx, state.y - this.first.y - this.graph.panDy);
};
mxGraphHandler.prototype.updateHint = function(me) {
};
mxGraphHandler.prototype.removeHint = function() {
};
mxGraphHandler.prototype.roundLength = function(length) {
  return Math.round(100 * length) / 100;
};
mxGraphHandler.prototype.isValidDropTarget = function(target, me) {
  return this.graph.model.getParent(this.cell) != target;
};
mxGraphHandler.prototype.checkPreview = function() {
  if (this.livePreviewActive && this.cloning) {
    this.resetLivePreview();
    this.livePreviewActive = false;
  } else {
    if (this.maxLivePreview >= this.cellCount && (!this.livePreviewActive && this.allowLivePreview)) {
      if (!(this.cloning && this.livePreviewActive)) {
        this.livePreviewUsed = this.livePreviewActive = true;
      }
    } else {
      if (!this.livePreviewUsed) {
        if (!(null != this.shape)) {
          this.shape = this.createPreviewShape(this.bounds);
        }
      }
    }
  }
};
mxGraphHandler.prototype.mouseMove = function(graph, me) {
  graph = this.graph;
  if (me.isConsumed() || (!graph.isMouseDown || (null == this.cell || (null == this.first || (null == this.bounds || this.suspended))))) {
    if (!(!this.isMoveEnabled() && !this.isCloneEnabled())) {
      if (!!this.updateCursor) {
        if (!me.isConsumed()) {
          if (!(null == me.getState() && null == me.sourceState)) {
            if (!graph.isMouseDown) {
              delta = graph.getCursorForMouseEvent(me);
              if (null == delta) {
                if (graph.isEnabled()) {
                  if (graph.isCellMovable(me.getCell())) {
                    delta = graph.getModel().isEdge(me.getCell()) ? mxConstants.CURSOR_MOVABLE_EDGE : mxConstants.CURSOR_MOVABLE_VERTEX;
                  }
                }
              }
              if (null != delta) {
                if (null != me.sourceState) {
                  me.sourceState.setCursor(delta);
                }
              }
            }
          }
        }
      }
    }
  } else {
    if (mxEvent.isMultiTouchEvent(me.getEvent())) {
      this.reset();
    } else {
      var delta = this.getDelta(me);
      var clone = graph.tolerance;
      if (null != this.shape || (this.livePreviewActive || (Math.abs(delta.x) > clone || Math.abs(delta.y) > clone))) {
        if (null == this.highlight) {
          this.highlight = new mxCellHighlight(this.graph, mxConstants.DROP_TARGET_COLOR, 3);
        }
        clone = graph.isCloneEvent(me.getEvent()) && (graph.isCellsCloneable() && this.isCloneEnabled());
        var gridEnabled = graph.isGridEnabledEvent(me.getEvent());
        var cell = me.getCell();
        cell = null != cell && 0 > mxUtils.indexOf(this.cells, cell) ? cell : graph.getCellAt(me.getGraphX(), me.getGraphY(), null, null, null, mxUtils.bind(this, function(node, flex, editor) {
          return 0 <= mxUtils.indexOf(this.cells, node.cell);
        }));
        var g = true;
        var target = null;
        this.cloning = clone;
        if (graph.isDropEnabled()) {
          if (this.highlightEnabled) {
            target = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);
          }
        }
        var state = graph.getView().getState(target);
        var m = false;
        if (null != state && (clone || this.isValidDropTarget(target, me))) {
          if (this.target != target) {
            this.target = target;
            this.setHighlightColor(mxConstants.DROP_TARGET_COLOR);
          }
          m = true;
        } else {
          this.target = null;
          if (this.connectOnDrop) {
            if (null != cell) {
              if (1 == this.cells.length) {
                if (graph.getModel().isVertex(cell)) {
                  if (graph.isCellConnectable(cell)) {
                    state = graph.getView().getState(cell);
                    if (null != state) {
                      graph = null == graph.getEdgeValidationError(null, this.cell, cell) ? mxConstants.VALID_COLOR : mxConstants.INVALID_CONNECT_TARGET_COLOR;
                      this.setHighlightColor(graph);
                      m = true;
                    }
                  }
                }
              }
            }
          }
        }
        if (null != state && m) {
          this.highlight.highlight(state);
        } else {
          this.highlight.hide();
        }
        if (null != this.guide && this.useGuidesForEvent(me)) {
          delta = this.guide.move(this.bounds, delta, gridEnabled, clone);
          g = false;
        } else {
          delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);
        }
        if (null != this.guide) {
          if (g) {
            this.guide.hide();
          }
        }
        if (this.isConstrainedEvent(me)) {
          if (Math.abs(delta.x) > Math.abs(delta.y)) {
            delta.y = 0;
          } else {
            delta.x = 0;
          }
        }
        this.checkPreview();
        if (this.currentDx != delta.x || this.currentDy != delta.y) {
          this.currentDx = delta.x;
          this.currentDy = delta.y;
          this.updatePreview();
        }
      }
      this.updateHint(me);
      this.consumeMouseEvent(mxEvent.MOUSE_MOVE, me);
      mxEvent.consume(me.getEvent());
    }
  }
};
mxGraphHandler.prototype.isConstrainedEvent = function(me) {
  return(null == this.target || this.graph.isCloneEvent(me.getEvent())) && this.graph.isConstrainedEvent(me.getEvent());
};
mxGraphHandler.prototype.updatePreview = function(remote) {
  if (this.livePreviewUsed && !remote) {
    if (null != this.cells) {
      this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), false);
      this.updateLivePreview(this.currentDx, this.currentDy);
    }
  } else {
    this.updatePreviewShape();
  }
};
mxGraphHandler.prototype.updatePreviewShape = function() {
  if (null != this.shape) {
    if (null != this.pBounds) {
      this.shape.bounds = new mxRectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);
      this.shape.redraw();
    }
  }
};
mxGraphHandler.prototype.updateLivePreview = function(dx, dy) {
  if (!this.suspended) {
    var states = [];
    if (null != this.allCells) {
      this.allCells.visit(mxUtils.bind(this, function(realState, state) {
        realState = this.graph.view.getState(state.cell);
        if (realState != state) {
          state.destroy();
          if (null != realState) {
            this.allCells.put(state.cell, realState);
          } else {
            this.allCells.remove(state.cell);
          }
          state = realState;
        }
        if (null != state) {
          if (realState = state.clone(), states.push([state, realState]), null != state.shape && (null == state.shape.originalPointerEvents && (state.shape.originalPointerEvents = state.shape.pointerEvents), state.shape.pointerEvents = false, null != state.text && (null == state.text.originalPointerEvents && (state.text.originalPointerEvents = state.text.pointerEvents), state.text.pointerEvents = false)), this.graph.model.isVertex(state.cell)) {
            if (state.x += dx, state.y += dy, this.cloning) {
              if (null != state.text) {
                state.text.updateBoundingBox();
                if (null != state.text.boundingBox) {
                  state.text.boundingBox.x += dx;
                  state.text.boundingBox.y += dy;
                }
                if (null != state.text.unrotatedBoundingBox) {
                  state.text.unrotatedBoundingBox.x += dx;
                  state.text.unrotatedBoundingBox.y += dy;
                }
              }
            } else {
              state.view.graph.cellRenderer.redraw(state, true);
              state.view.invalidate(state.cell);
              state.invalid = false;
              if (null != state.control) {
                if (null != state.control.node) {
                  state.control.node.style.visibility = "hidden";
                }
              }
            }
          }
        }
      }));
    }
    if (0 == states.length) {
      this.reset();
    } else {
      var s = this.graph.view.scale;
      for (var i = 0;i < states.length;i++) {
        var state = states[i][0];
        if (this.graph.model.isEdge(state.cell)) {
          var source = this.graph.getCellGeometry(state.cell);
          var points = [];
          if (null != source && null != source.points) {
            for (var target = 0;target < source.points.length;target++) {
              if (null != source.points[target]) {
                points.push(new mxPoint(source.points[target].x + dx / s, source.points[target].y + dy / s));
              }
            }
          }
          source = state.visibleSourceState;
          target = state.visibleTargetState;
          var rpts = states[i][1].absolutePoints;
          if (null != source && this.isCellMoving(source.cell)) {
            state.view.updateFixedTerminalPoint(state, source, true, this.graph.getConnectionConstraint(state, source, true));
          } else {
            source = rpts[0];
            state.setAbsoluteTerminalPoint(new mxPoint(source.x + dx, source.y + dy), true);
            source = null;
          }
          if (null != target && this.isCellMoving(target.cell)) {
            state.view.updateFixedTerminalPoint(state, target, false, this.graph.getConnectionConstraint(state, target, false));
          } else {
            target = rpts[rpts.length - 1];
            state.setAbsoluteTerminalPoint(new mxPoint(target.x + dx, target.y + dy), false);
            target = null;
          }
          state.view.updatePoints(state, points, source, target);
          state.view.updateFloatingTerminalPoints(state, source, target);
          state.view.updateEdgeLabelOffset(state);
          state.invalid = false;
          if (!this.cloning) {
            state.view.graph.cellRenderer.redraw(state, true);
          }
        }
      }
      this.graph.view.validate();
      this.redrawHandles(states);
      this.resetPreviewStates(states);
    }
  }
};
mxGraphHandler.prototype.redrawHandles = function(states) {
  for (var i = 0;i < states.length;i++) {
    var handler = this.graph.selectionCellsHandler.getHandler(states[i][0].cell);
    if (null != handler) {
      handler.redraw(true);
    }
  }
};
mxGraphHandler.prototype.resetPreviewStates = function(states) {
  for (var i = 0;i < states.length;i++) {
    states[i][0].setState(states[i][1]);
  }
};
mxGraphHandler.prototype.suspend = function() {
  if (!this.suspended) {
    if (this.livePreviewUsed) {
      this.updateLivePreview(0, 0);
    }
    if (null != this.shape) {
      this.shape.node.style.visibility = "hidden";
    }
    if (null != this.guide) {
      this.guide.setVisible(false);
    }
    this.suspended = true;
  }
};
mxGraphHandler.prototype.resume = function() {
  if (this.suspended) {
    this.suspended = null;
    if (this.livePreviewUsed) {
      this.livePreviewActive = true;
    }
    if (null != this.shape) {
      this.shape.node.style.visibility = "visible";
    }
    if (null != this.guide) {
      this.guide.setVisible(true);
    }
  }
};
mxGraphHandler.prototype.resetLivePreview = function() {
  if (null != this.allCells) {
    this.allCells.visit(mxUtils.bind(this, function(flex, state) {
      if (null != state.shape) {
        if (null != state.shape.originalPointerEvents) {
          state.shape.pointerEvents = state.shape.originalPointerEvents;
          state.shape.originalPointerEvents = null;
          state.shape.bounds = null;
          if (null != state.text) {
            state.text.pointerEvents = state.text.originalPointerEvents;
            state.text.originalPointerEvents = null;
          }
        }
      }
      if (null != state.control) {
        if (null != state.control.node) {
          if ("hidden" == state.control.node.style.visibility) {
            state.control.node.style.visibility = "";
          }
        }
      }
      if (!this.cloning) {
        if (null != state.text) {
          state.text.updateBoundingBox();
        }
      }
      state.view.invalidate(state.cell);
    }));
    this.graph.view.validate();
  }
};
mxGraphHandler.prototype.setHandlesVisibleForCells = function(cells, visible, i) {
  if (i || this.handlesVisible != visible) {
    this.handlesVisible = visible;
    for (i = 0;i < cells.length;i++) {
      var handler = this.graph.selectionCellsHandler.getHandler(cells[i]);
      if (null != handler) {
        handler.setHandlesVisible(visible);
        if (visible) {
          handler.redraw();
        }
      }
    }
  }
};
mxGraphHandler.prototype.setHighlightColor = function(color) {
  if (null != this.highlight) {
    this.highlight.setHighlightColor(color);
  }
};
mxGraphHandler.prototype.mouseUp = function(graph, me) {
  if (!me.isConsumed()) {
    if (this.livePreviewUsed && this.resetLivePreview(), null == this.cell || (null == this.first || (null == this.shape && !this.livePreviewUsed || (null == this.currentDx || null == this.currentDy)))) {
      if (this.isSelectEnabled()) {
        if (this.delayedSelection) {
          if (null != this.cell) {
            this.selectDelayed(me);
          }
        }
      }
    } else {
      graph = this.graph;
      var cell = me.getCell();
      if (this.connectOnDrop && (null == this.target && (null != cell && (graph.getModel().isVertex(cell) && (graph.isCellConnectable(cell) && graph.isEdgeValid(null, this.cell, cell)))))) {
        graph.connectionHandler.connect(this.cell, cell, me.getEvent());
      } else {
        cell = graph.isCloneEvent(me.getEvent()) && (graph.isCellsCloneable() && this.isCloneEnabled());
        var dy = graph.getView().scale;
        var dx = this.roundLength(this.currentDx / dy);
        dy = this.roundLength(this.currentDy / dy);
        var target = this.target;
        if (graph.isSplitEnabled() && graph.isSplitTarget(target, this.cells, me.getEvent())) {
          graph.splitEdge(target, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());
        } else {
          this.moveCells(this.cells, dx, dy, cell, this.target, me.getEvent());
        }
      }
    }
  }
  if (this.cellWasClicked) {
    this.consumeMouseEvent(mxEvent.MOUSE_UP, me);
  }
  this.reset();
};
mxGraphHandler.prototype.reset = function() {
  if (this.livePreviewUsed) {
    this.resetLivePreview();
    this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), true);
  }
  this.destroyShapes();
  this.removeHint();
  this.delayedSelection = false;
  this.livePreviewUsed = this.livePreviewActive = null;
  this.cellWasClicked = false;
  this.cellCount = this.currentDy = this.currentDx = this.suspended = null;
  this.cloning = false;
  this.cell = this.cells = this.first = this.target = this.guides = this.pBounds = this.allCells = null;
};
mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(cell, cells, evt) {
  if (this.graph.getModel().isVertex(cell) && (cell = this.graph.getView().getState(cell), null != cell)) {
    evt = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
    var sin = mxUtils.toRadians(mxUtils.getValue(cell.style, mxConstants.STYLE_ROTATION) || 0);
    if (0 != sin) {
      cells = Math.cos(-sin);
      sin = Math.sin(-sin);
      var cx = new mxPoint(cell.getCenterX(), cell.getCenterY());
      evt = mxUtils.getRotatedPoint(evt, cells, sin, cx);
    }
    return!mxUtils.contains(cell, evt.x, evt.y);
  }
  return false;
};
mxGraphHandler.prototype.moveCells = function(cells, dx, dy, clone, target, evt) {
  if (clone) {
    cells = this.graph.getCloneableCells(cells);
  }
  var tmp = this.graph.getModel().getParent(this.cell);
  if (null == target) {
    if (null != evt) {
      if (this.isRemoveCellsFromParent()) {
        if (this.shouldRemoveCellsFromParent(tmp, cells, evt)) {
          target = this.graph.getDefaultParent();
        }
      }
    }
  }
  clone = clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());
  this.graph.getModel().beginUpdate();
  try {
    tmp = [];
    if (!clone && (null != target && this.removeEmptyParents)) {
      var dict = new mxDictionary;
      for (var i = 0;i < cells.length;i++) {
        dict.put(cells[i], true);
      }
      for (i = 0;i < cells.length;i++) {
        var cell = this.graph.model.getParent(cells[i]);
        if (!(null == cell)) {
          if (!dict.get(cell)) {
            dict.put(cell, true);
            tmp.push(cell);
          }
        }
      }
    }
    cells = this.graph.moveCells(cells, dx, dy, clone, target, evt);
    dx = [];
    for (i = 0;i < tmp.length;i++) {
      if (this.shouldRemoveParent(tmp[i])) {
        dx.push(tmp[i]);
      }
    }
    this.graph.removeCells(dx, false);
  } finally {
    this.graph.getModel().endUpdate();
  }
  if (clone) {
    this.graph.setSelectionCells(cells);
  }
  if (this.isSelectEnabled()) {
    if (this.scrollOnMove) {
      this.graph.scrollCellToVisible(cells[0]);
    }
  }
};
mxGraphHandler.prototype.shouldRemoveParent = function(state) {
  state = this.graph.view.getState(state);
  return null != state && ((this.graph.model.isEdge(state.cell) || this.graph.model.isVertex(state.cell)) && (this.graph.isCellDeletable(state.cell) && (0 == this.graph.model.getChildCount(state.cell) && this.graph.isTransparentState(state))));
};
mxGraphHandler.prototype.destroyShapes = function() {
  if (null != this.shape) {
    this.shape.destroy();
    this.shape = null;
  }
  if (null != this.guide) {
    this.guide.destroy();
    this.guide = null;
  }
  if (null != this.highlight) {
    this.highlight.destroy();
    this.highlight = null;
  }
};
mxGraphHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.panHandler);
  if (null != this.escapeHandler) {
    this.graph.removeListener(this.escapeHandler);
    this.escapeHandler = null;
  }
  if (null != this.refreshHandler) {
    this.graph.getModel().removeListener(this.refreshHandler);
    this.graph.removeListener(this.refreshHandler);
    this.refreshHandler = null;
  }
  mxEvent.removeListener(document, "keydown", this.keyHandler);
  mxEvent.removeListener(document, "keyup", this.keyHandler);
  this.destroyShapes();
  this.removeHint();
};
function mxPanningHandler(graph) {
  if (null != graph) {
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.forcePanningHandler = mxUtils.bind(this, function(evtName, me) {
      evtName = me.getProperty("eventName");
      me = me.getProperty("event");
      if (evtName == mxEvent.MOUSE_DOWN) {
        if (this.isForcePanningEvent(me)) {
          this.start(me);
          this.active = true;
          this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", me));
          me.consume();
        }
      }
    });
    this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);
    this.gestureHandler = mxUtils.bind(this, function(evt, eo) {
      if (this.isPinchEnabled()) {
        evt = eo.getProperty("event");
        if (mxEvent.isConsumed(evt) || "gesturestart" != evt.type) {
          if ("gestureend" == evt.type) {
            if (null != this.initialScale) {
              this.initialScale = null;
            }
          }
        } else {
          this.initialScale = this.graph.view.scale;
          if (!this.active) {
            if (!(null == this.mouseDownEvent)) {
              this.start(this.mouseDownEvent);
              this.mouseDownEvent = null;
            }
          }
        }
        if (null != this.initialScale) {
          this.zoomGraph(evt);
        }
      }
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    this.mouseUpListener = mxUtils.bind(this, function() {
      if (this.active) {
        this.reset();
      }
    });
    mxEvent.addGestureListeners(document, null, null, this.mouseUpListener);
    mxEvent.addListener(document, "mouseleave", this.mouseUpListener);
  }
}
mxPanningHandler.prototype = new mxEventSource;
mxPanningHandler.prototype.constructor = mxPanningHandler;
mxPanningHandler.prototype.graph = null;
mxPanningHandler.prototype.useLeftButtonForPanning = false;
mxPanningHandler.prototype.usePopupTrigger = true;
mxPanningHandler.prototype.ignoreCell = false;
mxPanningHandler.prototype.previewEnabled = true;
mxPanningHandler.prototype.useGrid = false;
mxPanningHandler.prototype.panningEnabled = true;
mxPanningHandler.prototype.pinchEnabled = true;
mxPanningHandler.prototype.maxScale = 8;
mxPanningHandler.prototype.minScale = 0.01;
mxPanningHandler.prototype.dx = null;
mxPanningHandler.prototype.dy = null;
mxPanningHandler.prototype.startX = 0;
mxPanningHandler.prototype.startY = 0;
mxPanningHandler.prototype.isActive = function() {
  return this.active || null != this.initialScale;
};
mxPanningHandler.prototype.isPanningEnabled = function() {
  return this.panningEnabled;
};
mxPanningHandler.prototype.setPanningEnabled = function(value) {
  this.panningEnabled = value;
};
mxPanningHandler.prototype.isPinchEnabled = function() {
  return this.pinchEnabled;
};
mxPanningHandler.prototype.setPinchEnabled = function(value) {
  this.pinchEnabled = value;
};
mxPanningHandler.prototype.isPanningTrigger = function(me) {
  var evt = me.getEvent();
  return this.useLeftButtonForPanning && (null == me.getState() && mxEvent.isLeftMouseButton(evt)) || (mxEvent.isControlDown(evt) && mxEvent.isShiftDown(evt) || this.usePopupTrigger && mxEvent.isPopupTrigger(evt));
};
mxPanningHandler.prototype.isForcePanningEvent = function(me) {
  return this.ignoreCell || mxEvent.isMultiTouchEvent(me.getEvent());
};
mxPanningHandler.prototype.mouseDown = function(cell, me) {
  this.mouseDownEvent = me;
  if (!me.isConsumed()) {
    if (this.isPanningEnabled()) {
      if (!this.active) {
        if (this.isPanningTrigger(me)) {
          this.start(me);
          this.consumePanningTrigger(me);
        }
      }
    }
  }
};
mxPanningHandler.prototype.start = function(me) {
  this.dx0 = -this.graph.container.scrollLeft;
  this.dy0 = -this.graph.container.scrollTop;
  this.startX = me.getX();
  this.startY = me.getY();
  this.dy = this.dx = null;
  this.panningTrigger = true;
};
mxPanningHandler.prototype.consumePanningTrigger = function(me) {
  me.consume();
};
mxPanningHandler.prototype.mouseMove = function(sender, me) {
  this.dx = me.getX() - this.startX;
  this.dy = me.getY() - this.startY;
  if (this.active) {
    if (this.previewEnabled) {
      if (this.useGrid) {
        this.dx = this.graph.snap(this.dx);
        this.dy = this.graph.snap(this.dy);
      }
      this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);
    }
    this.fireEvent(new mxEventObject(mxEvent.PAN, "event", me));
  } else {
    if (this.panningTrigger) {
      sender = this.active;
      this.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;
      if (!sender) {
        if (this.active) {
          this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", me));
        }
      }
    }
  }
  if (this.active || this.panningTrigger) {
    me.consume();
  }
};
mxPanningHandler.prototype.mouseUp = function(scale, me) {
  if (this.active) {
    if (null != this.dx && null != this.dy) {
      if (!this.graph.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.graph.container)) {
        scale = this.graph.getView().scale;
        var t = this.graph.getView().translate;
        this.graph.panGraph(0, 0);
        this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);
      }
      me.consume();
    }
    this.fireEvent(new mxEventObject(mxEvent.PAN_END, "event", me));
  }
  this.reset();
};
mxPanningHandler.prototype.zoomGraph = function(evt) {
  var value = Math.round(this.initialScale * evt.scale * 100) / 100;
  if (null != this.minScale) {
    value = Math.max(this.minScale, value);
  }
  if (null != this.maxScale) {
    value = Math.min(this.maxScale, value);
  }
  if (this.graph.view.scale != value) {
    this.graph.zoomTo(value);
    mxEvent.consume(evt);
  }
};
mxPanningHandler.prototype.reset = function() {
  this.panningTrigger = this.graph.isMouseDown = false;
  this.mouseDownEvent = null;
  this.active = false;
  this.dy = this.dx = null;
};
mxPanningHandler.prototype.panGraph = function(dx, dy) {
  this.graph.getView().setTranslate(dx, dy);
};
mxPanningHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.forcePanningHandler);
  this.graph.removeListener(this.gestureHandler);
  mxEvent.removeGestureListeners(document, null, null, this.mouseUpListener);
  mxEvent.removeListener(document, "mouseleave", this.mouseUpListener);
};
function mxPopupMenuHandler(graph, factoryMethod) {
  if (null != graph) {
    this.graph = graph;
    this.factoryMethod = factoryMethod;
    this.graph.addMouseListener(this);
    this.gestureHandler = mxUtils.bind(this, function(flex, editor) {
      this.inTolerance = false;
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    this.init();
  }
}
mxPopupMenuHandler.prototype = new mxPopupMenu;
mxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;
mxPopupMenuHandler.prototype.graph = null;
mxPopupMenuHandler.prototype.selectOnPopup = true;
mxPopupMenuHandler.prototype.clearSelectionOnBackground = true;
mxPopupMenuHandler.prototype.triggerX = null;
mxPopupMenuHandler.prototype.triggerY = null;
mxPopupMenuHandler.prototype.screenX = null;
mxPopupMenuHandler.prototype.screenY = null;
mxPopupMenuHandler.prototype.init = function() {
  mxPopupMenu.prototype.init.apply(this);
  mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(flex) {
    this.graph.tooltipHandler.hide();
  }));
};
mxPopupMenuHandler.prototype.isSelectOnPopup = function(me) {
  return this.selectOnPopup;
};
mxPopupMenuHandler.prototype.mouseDown = function(cell, me) {
  if (this.isEnabled()) {
    if (!mxEvent.isMultiTouchEvent(me.getEvent())) {
      this.hideMenu();
      this.triggerX = me.getGraphX();
      this.triggerY = me.getGraphY();
      this.screenX = mxEvent.getMainEvent(me.getEvent()).screenX;
      this.screenY = mxEvent.getMainEvent(me.getEvent()).screenY;
      this.popupTrigger = this.isPopupTrigger(me);
      this.inTolerance = true;
    }
  }
};
mxPopupMenuHandler.prototype.mouseMove = function(sender, me) {
  if (this.inTolerance) {
    if (null != this.screenX) {
      if (null != this.screenY) {
        if (Math.abs(mxEvent.getMainEvent(me.getEvent()).screenX - this.screenX) > this.graph.tolerance || Math.abs(mxEvent.getMainEvent(me.getEvent()).screenY - this.screenY) > this.graph.tolerance) {
          this.inTolerance = false;
        }
      }
    }
  }
};
mxPopupMenuHandler.prototype.mouseUp = function(sender, me, isCellVisibleFn) {
  sender = null == isCellVisibleFn;
  isCellVisibleFn = null != isCellVisibleFn ? isCellVisibleFn : mxUtils.bind(this, function(cell) {
    var first = mxUtils.getScrollOrigin();
    this.popup(me.getX() + first.x + 1, me.getY() + first.y + 1, cell, me.getEvent());
  });
  if (this.popupTrigger && (this.inTolerance && (null != this.triggerX && null != this.triggerY))) {
    var cell = this.getCellForPopupEvent(me);
    if (this.graph.isEnabled() && (this.isSelectOnPopup(me) && (null != cell && !this.graph.isCellSelected(cell)))) {
      this.graph.setSelectionCell(cell);
    } else {
      if (this.clearSelectionOnBackground) {
        if (null == cell) {
          this.graph.clearSelection();
        }
      }
    }
    this.graph.tooltipHandler.hide();
    isCellVisibleFn(cell);
    if (sender) {
      me.consume();
    }
  }
  this.inTolerance = this.popupTrigger = false;
};
mxPopupMenuHandler.prototype.getCellForPopupEvent = function(me) {
  return me.getCell();
};
mxPopupMenuHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.gestureHandler);
  mxPopupMenu.prototype.destroy.apply(this);
};
function mxCellMarker(graph, validColor, invalidColor, hotspot) {
  mxEventSource.call(this);
  if (null != graph) {
    this.graph = graph;
    this.validColor = null != validColor ? validColor : mxConstants.DEFAULT_VALID_COLOR;
    this.invalidColor = null != invalidColor ? invalidColor : mxConstants.DEFAULT_INVALID_COLOR;
    this.hotspot = null != hotspot ? hotspot : mxConstants.DEFAULT_HOTSPOT;
    this.highlight = new mxCellHighlight(graph);
  }
}
mxUtils.extend(mxCellMarker, mxEventSource);
mxCellMarker.prototype.graph = null;
mxCellMarker.prototype.enabled = true;
mxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT;
mxCellMarker.prototype.hotspotEnabled = false;
mxCellMarker.prototype.validColor = null;
mxCellMarker.prototype.invalidColor = null;
mxCellMarker.prototype.currentColor = null;
mxCellMarker.prototype.validState = null;
mxCellMarker.prototype.markedState = null;
mxCellMarker.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxCellMarker.prototype.isEnabled = function() {
  return this.enabled;
};
mxCellMarker.prototype.setHotspot = function(hotspot) {
  this.hotspot = hotspot;
};
mxCellMarker.prototype.getHotspot = function() {
  return this.hotspot;
};
mxCellMarker.prototype.setHotspotEnabled = function(enabled) {
  this.hotspotEnabled = enabled;
};
mxCellMarker.prototype.isHotspotEnabled = function() {
  return this.hotspotEnabled;
};
mxCellMarker.prototype.hasValidState = function() {
  return null != this.validState;
};
mxCellMarker.prototype.getValidState = function() {
  return this.validState;
};
mxCellMarker.prototype.getMarkedState = function() {
  return this.markedState;
};
mxCellMarker.prototype.reset = function() {
  this.validState = null;
  if (null != this.markedState) {
    this.markedState = null;
    this.unmark();
  }
};
mxCellMarker.prototype.process = function(me) {
  var state = null;
  if (this.isEnabled()) {
    state = this.getState(me);
    this.setCurrentState(state, me);
  }
  return state;
};
mxCellMarker.prototype.setCurrentState = function(state, me, color) {
  var isValid = null != state ? this.isValidState(state) : false;
  color = null != color ? color : this.getMarkerColor(me.getEvent(), state, isValid);
  this.validState = isValid ? state : null;
  if (state != this.markedState || color != this.currentColor) {
    this.currentColor = color;
    if (null != state && null != this.currentColor) {
      this.markedState = state;
      this.mark();
    } else {
      if (null != this.markedState) {
        this.markedState = null;
        this.unmark();
      }
    }
  }
};
mxCellMarker.prototype.markCell = function(cell, color) {
  cell = this.graph.getView().getState(cell);
  if (null != cell) {
    this.currentColor = null != color ? color : this.validColor;
    this.markedState = cell;
    this.mark();
  }
};
mxCellMarker.prototype.mark = function() {
  this.highlight.setHighlightColor(this.currentColor);
  this.highlight.highlight(this.markedState);
  this.fireEvent(new mxEventObject(mxEvent.MARK, "state", this.markedState));
};
mxCellMarker.prototype.unmark = function() {
  this.mark();
};
mxCellMarker.prototype.isValidState = function(state) {
  return true;
};
mxCellMarker.prototype.getMarkerColor = function(evt, state, isValid) {
  return isValid ? this.validColor : this.invalidColor;
};
mxCellMarker.prototype.getState = function(child) {
  var state = this.graph.getView();
  var cell = this.getCell(child);
  state = this.getStateToMark(state.getState(cell));
  return null != state && this.intersects(state, child) ? state : null;
};
mxCellMarker.prototype.getCell = function(me) {
  return me.getCell();
};
mxCellMarker.prototype.getStateToMark = function(state) {
  return state;
};
mxCellMarker.prototype.intersects = function(state, x) {
  return this.hotspotEnabled ? mxUtils.intersectsHotspot(state, x.getGraphX(), x.getGraphY(), this.hotspot, mxConstants.MIN_HOTSPOT_SIZE, mxConstants.MAX_HOTSPOT_SIZE) : true;
};
mxCellMarker.prototype.destroy = function() {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getModel().removeListener(this.resetHandler);
  this.highlight.destroy();
};
function mxSelectionCellsHandler(graph) {
  mxEventSource.call(this);
  this.graph = graph;
  this.handlers = new mxDictionary;
  this.graph.addMouseListener(this);
  this.refreshHandler = mxUtils.bind(this, function(flex, editor) {
    if (this.isEnabled()) {
      this.refresh();
    }
  });
  this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.SCALE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.DOWN, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.UP, this.refreshHandler);
}
mxUtils.extend(mxSelectionCellsHandler, mxEventSource);
mxSelectionCellsHandler.prototype.graph = null;
mxSelectionCellsHandler.prototype.enabled = true;
mxSelectionCellsHandler.prototype.refreshHandler = null;
mxSelectionCellsHandler.prototype.maxHandlers = 100;
mxSelectionCellsHandler.prototype.handlers = null;
mxSelectionCellsHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxSelectionCellsHandler.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxSelectionCellsHandler.prototype.getHandler = function(cell) {
  return this.handlers.get(cell);
};
mxSelectionCellsHandler.prototype.isHandled = function(cell) {
  return null != this.getHandler(cell);
};
mxSelectionCellsHandler.prototype.reset = function() {
  this.handlers.visit(function(flex, state) {
    state.reset.apply(state);
  });
};
mxSelectionCellsHandler.prototype.getHandledSelectionCells = function() {
  return this.graph.getSelectionCells();
};
mxSelectionCellsHandler.prototype.refresh = function() {
  var oldHandlers = this.handlers;
  this.handlers = new mxDictionary;
  var tmp = mxUtils.sortCells(this.getHandledSelectionCells(), false);
  for (var i = 0;i < tmp.length;i++) {
    var state = this.graph.view.getState(tmp[i]);
    if (null != state) {
      var handler = oldHandlers.remove(tmp[i]);
      if (null != handler) {
        if (handler.state != state) {
          handler.destroy();
          handler = null;
        } else {
          if (!this.isHandlerActive(handler)) {
            if (null != handler.refresh) {
              handler.refresh();
            }
            handler.redraw();
          }
        }
      }
      if (null != handler) {
        this.handlers.put(tmp[i], handler);
      }
    }
  }
  oldHandlers.visit(mxUtils.bind(this, function(flex, handler) {
    this.fireEvent(new mxEventObject(mxEvent.REMOVE, "state", handler.state));
    handler.destroy();
  }));
  for (i = 0;i < tmp.length;i++) {
    state = this.graph.view.getState(tmp[i]);
    if (null != state) {
      handler = this.handlers.get(tmp[i]);
      if (null == handler) {
        handler = this.graph.createHandler(state);
        this.fireEvent(new mxEventObject(mxEvent.ADD, "state", state));
        this.handlers.put(tmp[i], handler);
      } else {
        handler.updateParentHighlight();
      }
    }
  }
};
mxSelectionCellsHandler.prototype.isHandlerActive = function(handler) {
  return null != handler.index;
};
mxSelectionCellsHandler.prototype.updateHandler = function(state) {
  var handler = this.handlers.remove(state.cell);
  if (null != handler) {
    var index = handler.index;
    var x = handler.startX;
    var y = handler.startY;
    handler.destroy();
    handler = this.graph.createHandler(state);
    if (null != handler) {
      this.handlers.put(state.cell, handler);
      if (null != index) {
        if (null != x) {
          if (null != y) {
            handler.start(x, y, index);
          }
        }
      }
    }
  }
};
mxSelectionCellsHandler.prototype.mouseDown = function(sender, me) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    var args = [sender, me];
    this.handlers.visit(function(flex, state) {
      state.mouseDown.apply(state, args);
    });
  }
};
mxSelectionCellsHandler.prototype.mouseMove = function(sender, me) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    var args = [sender, me];
    this.handlers.visit(function(flex, state) {
      state.mouseMove.apply(state, args);
    });
  }
};
mxSelectionCellsHandler.prototype.mouseUp = function(sender, me) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    var args = [sender, me];
    this.handlers.visit(function(flex, state) {
      state.mouseUp.apply(state, args);
    });
  }
};
mxSelectionCellsHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  if (null != this.refreshHandler) {
    this.graph.getSelectionModel().removeListener(this.refreshHandler);
    this.graph.getModel().removeListener(this.refreshHandler);
    this.graph.getView().removeListener(this.refreshHandler);
    this.refreshHandler = null;
  }
};
function mxConnectionHandler(graph, factoryMethod) {
  mxEventSource.call(this);
  if (null != graph) {
    this.graph = graph;
    this.factoryMethod = factoryMethod;
    this.init();
    this.escapeHandler = mxUtils.bind(this, function(flex, editor) {
      this.reset();
    });
    this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  }
}
mxUtils.extend(mxConnectionHandler, mxEventSource);
mxConnectionHandler.prototype.graph = null;
mxConnectionHandler.prototype.factoryMethod = true;
mxConnectionHandler.prototype.moveIconFront = false;
mxConnectionHandler.prototype.moveIconBack = false;
mxConnectionHandler.prototype.connectImage = null;
mxConnectionHandler.prototype.targetConnectImage = false;
mxConnectionHandler.prototype.enabled = true;
mxConnectionHandler.prototype.select = true;
mxConnectionHandler.prototype.createTarget = false;
mxConnectionHandler.prototype.marker = null;
mxConnectionHandler.prototype.constraintHandler = null;
mxConnectionHandler.prototype.error = null;
mxConnectionHandler.prototype.waypointsEnabled = false;
mxConnectionHandler.prototype.ignoreMouseDown = false;
mxConnectionHandler.prototype.first = null;
mxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET);
mxConnectionHandler.prototype.edgeState = null;
mxConnectionHandler.prototype.changeHandler = null;
mxConnectionHandler.prototype.drillHandler = null;
mxConnectionHandler.prototype.mouseDownCounter = 0;
mxConnectionHandler.prototype.movePreviewAway = false;
mxConnectionHandler.prototype.outlineConnect = false;
mxConnectionHandler.prototype.livePreview = false;
mxConnectionHandler.prototype.cursor = null;
mxConnectionHandler.prototype.insertBeforeSource = false;
mxConnectionHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxConnectionHandler.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxConnectionHandler.prototype.isInsertBefore = function(edge, source, target, evt, cell) {
  return this.insertBeforeSource && source != target;
};
mxConnectionHandler.prototype.isCreateTarget = function(evt) {
  return this.createTarget;
};
mxConnectionHandler.prototype.setCreateTarget = function(value) {
  this.createTarget = value;
};
mxConnectionHandler.prototype.createShape = function() {
  var shape = this.livePreview && null != this.edgeState ? this.graph.cellRenderer.createShape(this.edgeState) : new mxPolyline([], mxConstants.INVALID_COLOR);
  shape.dialect = mxConstants.DIALECT_SVG;
  shape.scale = this.graph.view.scale;
  shape.svgStrokeTolerance = 0;
  shape.pointerEvents = false;
  shape.isDashed = true;
  shape.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(shape.node, this.graph, null);
  return shape;
};
mxConnectionHandler.prototype.init = function() {
  this.graph.addMouseListener(this);
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  this.changeHandler = mxUtils.bind(this, function(flex) {
    if (null != this.iconState) {
      this.iconState = this.graph.getView().getState(this.iconState.cell);
    }
    if (null != this.iconState) {
      this.redrawIcons(this.icons, this.iconState);
      this.constraintHandler.reset();
    } else {
      if (null != this.previous) {
        if (null == this.graph.view.getState(this.previous.cell)) {
          this.reset();
        }
      }
    }
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.SCALE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler);
  this.drillHandler = mxUtils.bind(this, function(flex) {
    this.reset();
  });
  this.graph.addListener(mxEvent.START_EDITING, this.drillHandler);
  this.graph.getView().addListener(mxEvent.DOWN, this.drillHandler);
  this.graph.getView().addListener(mxEvent.UP, this.drillHandler);
};
mxConnectionHandler.prototype.isConnectableCell = function(cell) {
  return true;
};
mxConnectionHandler.prototype.createMarker = function() {
  var state = new mxCellMarker(this.graph);
  state.hotspotEnabled = true;
  state.getCell = mxUtils.bind(this, function(me) {
    var cell = mxCellMarker.prototype.getCell.apply(state, arguments);
    this.error = null;
    if (null == cell) {
      if (null != this.currentPoint) {
        cell = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);
      }
    }
    if (null != cell && !this.graph.isCellConnectable(cell)) {
      var parent = this.graph.getModel().getParent(cell);
      if (this.graph.getModel().isVertex(parent)) {
        if (this.graph.isCellConnectable(parent)) {
          cell = parent;
        }
      }
    }
    if (this.graph.isSwimlane(cell) && (null != this.currentPoint && this.graph.hitsSwimlaneContent(cell, this.currentPoint.x, this.currentPoint.y)) || !this.isConnectableCell(cell)) {
      cell = null;
    }
    if (null != cell) {
      if (this.isConnecting()) {
        if (null != this.previous) {
          this.error = this.validateConnection(this.previous.cell, cell);
          if (null != this.error) {
            if (0 == this.error.length) {
              cell = null;
              if (this.isCreateTarget(me.getEvent())) {
                this.error = null;
              }
            }
          }
        }
      } else {
        if (!this.isValidSource(cell, me)) {
          cell = null;
        }
      }
    } else {
      if (!!this.isConnecting()) {
        if (!this.isCreateTarget(me.getEvent())) {
          if (!this.graph.allowDanglingEdges) {
            this.error = "";
          }
        }
      }
    }
    return cell;
  });
  state.isValidState = mxUtils.bind(this, function(flex) {
    return this.isConnecting() ? null == this.error : mxCellMarker.prototype.isValidState.apply(state, arguments);
  });
  state.getMarkerColor = mxUtils.bind(this, function(flex, editor, type) {
    return null == this.connectImage || this.isConnecting() ? mxCellMarker.prototype.getMarkerColor.apply(state, arguments) : null;
  });
  state.intersects = mxUtils.bind(this, function(flex, editor) {
    return null != this.connectImage || this.isConnecting() ? true : mxCellMarker.prototype.intersects.apply(state, arguments);
  });
  return state;
};
mxConnectionHandler.prototype.start = function(me, x, y, edgeState) {
  this.previous = me;
  this.first = new mxPoint(x, y);
  this.edgeState = null != edgeState ? edgeState : this.createEdgeState(null);
  this.marker.currentColor = this.marker.validColor;
  this.marker.markedState = me;
  this.marker.mark();
  this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
};
mxConnectionHandler.prototype.isConnecting = function() {
  return null != this.first && null != this.shape;
};
mxConnectionHandler.prototype.isValidSource = function(cell, me) {
  return this.graph.isValidSource(cell);
};
mxConnectionHandler.prototype.isValidTarget = function(cell) {
  return true;
};
mxConnectionHandler.prototype.validateConnection = function(source, target) {
  return this.isValidTarget(target) ? this.graph.getEdgeValidationError(null, source, target) : "";
};
mxConnectionHandler.prototype.getConnectImage = function(state) {
  return this.connectImage;
};
mxConnectionHandler.prototype.isMoveIconToFrontForState = function(state) {
  return null != state.text && state.text.node.parentNode == this.graph.container ? true : this.moveIconFront;
};
mxConnectionHandler.prototype.createIcons = function(state) {
  var image = this.getConnectImage(state);
  if (null != image && null != state) {
    this.iconState = state;
    var icons = [];
    var bounds = new mxRectangle(0, 0, image.width, image.height);
    var icon = new mxImageShape(bounds, image.src, null, null, 0);
    icon.preserveImageAspect = false;
    if (this.isMoveIconToFrontForState(state)) {
      icon.dialect = mxConstants.DIALECT_STRICTHTML;
      icon.init(this.graph.container);
    } else {
      icon.dialect = mxConstants.DIALECT_SVG;
      icon.init(this.graph.getView().getOverlayPane());
      if (this.moveIconBack) {
        if (null != icon.node.previousSibling) {
          icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
        }
      }
    }
    icon.node.style.cursor = mxConstants.CURSOR_CONNECT;
    var getState = mxUtils.bind(this, function() {
      return null != this.currentState ? this.currentState : state;
    });
    image = mxUtils.bind(this, function(evt) {
      if (!mxEvent.isConsumed(evt)) {
        this.icon = icon;
        this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, getState()));
      }
    });
    mxEvent.redirectMouseEvents(icon.node, this.graph, getState, image);
    icons.push(icon);
    this.redrawIcons(icons, this.iconState);
    return icons;
  }
  return null;
};
mxConnectionHandler.prototype.redrawIcons = function(icons, state) {
  if (null != icons) {
    if (null != icons[0]) {
      if (null != state) {
        state = this.getIconPosition(icons[0], state);
        icons[0].bounds.x = state.x;
        icons[0].bounds.y = state.y;
        icons[0].redraw();
      }
    }
  }
};
mxConnectionHandler.prototype.getIconPosition = function(icon, state) {
  var cos = this.graph.getView().scale;
  var cx = state.getCenterX();
  var cy = state.getCenterY();
  if (this.graph.isSwimlane(state.cell)) {
    var size = this.graph.getStartSize(state.cell);
    cx = 0 != size.width ? state.x + size.width * cos / 2 : cx;
    cy = 0 != size.height ? state.y + size.height * cos / 2 : cy;
    size = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);
    if (0 != size) {
      cos = Math.cos(size);
      size = Math.sin(size);
      state = new mxPoint(state.getCenterX(), state.getCenterY());
      cy = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, size, state);
      cx = cy.x;
      cy = cy.y;
    }
  }
  return new mxPoint(cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);
};
mxConnectionHandler.prototype.destroyIcons = function() {
  if (null != this.icons) {
    for (var i = 0;i < this.icons.length;i++) {
      this.icons[i].destroy();
    }
    this.iconState = this.selectedIcon = this.icon = this.icons = null;
  }
};
mxConnectionHandler.prototype.isStartEvent = function(me) {
  return null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint || null != this.previous && (null == this.error && (null == this.icons || null != this.icons && null != this.icon));
};
mxConnectionHandler.prototype.mouseDown = function(point, me) {
  this.mouseDownCounter++;
  if (this.isEnabled()) {
    if (this.graph.isEnabled()) {
      if (!me.isConsumed()) {
        if (!this.isConnecting()) {
          if (this.isStartEvent(me)) {
            if (null != this.constraintHandler.currentConstraint && (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint)) {
              this.sourceConstraint = this.constraintHandler.currentConstraint;
              this.previous = this.constraintHandler.currentFocus;
              this.first = this.constraintHandler.currentPoint.clone();
            } else {
              this.first = new mxPoint(me.getGraphX(), me.getGraphY());
            }
            this.edgeState = this.createEdgeState(me);
            this.mouseDownCounter = 1;
            if (this.waypointsEnabled) {
              if (null == this.shape) {
                this.waypoints = null;
                this.shape = this.createShape();
                if (null != this.edgeState) {
                  this.shape.apply(this.edgeState);
                }
              }
            }
            if (null == this.previous) {
              if (null != this.edgeState) {
                point = this.graph.getPointForEvent(me.getEvent());
                this.edgeState.cell.geometry.setTerminalPoint(point, true);
              }
            }
            this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
            me.consume();
          }
        }
      }
    }
  }
  this.selectedIcon = this.icon;
  this.icon = null;
};
mxConnectionHandler.prototype.isImmediateConnectSource = function(state) {
  return!this.graph.isCellMovable(state.cell);
};
mxConnectionHandler.prototype.createEdgeState = function(me) {
  return null;
};
mxConnectionHandler.prototype.isOutlineConnectEvent = function(me) {
  if (mxEvent.isShiftDown(me.getEvent()) && mxEvent.isAltDown(me.getEvent())) {
    return false;
  }
  var gridY = mxUtils.getOffset(this.graph.container);
  var evt = me.getEvent();
  var clientX = mxEvent.getClientX(evt);
  evt = mxEvent.getClientY(evt);
  var doc = document.documentElement;
  var gridX = this.currentPoint.x - this.graph.container.scrollLeft + gridY.x - ((window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0));
  gridY = this.currentPoint.y - this.graph.container.scrollTop + gridY.y - ((window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0));
  return this.outlineConnect && (mxEvent.isShiftDown(me.getEvent()) && !mxEvent.isAltDown(me.getEvent()) || (me.isSource(this.marker.highlight.shape) || (!mxEvent.isShiftDown(me.getEvent()) && (mxEvent.isAltDown(me.getEvent()) && null != me.getState()) || (this.marker.highlight.isHighlightAt(clientX, evt) || (gridX != clientX || gridY != evt) && (null == me.getState() && this.marker.highlight.isHighlightAt(gridX, gridY))))));
};
mxConnectionHandler.prototype.updateCurrentState = function(me, point) {
  this.constraintHandler.update(me, null == this.first, false, null == this.first || me.isSource(this.marker.highlight.shape) ? null : point);
  if (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint) {
    if (null != this.marker.highlight && (null != this.marker.highlight.state && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell)) {
      if ("transparent" != this.marker.highlight.shape.stroke) {
        this.marker.highlight.shape.stroke = "transparent";
        this.marker.highlight.repaint();
      }
    } else {
      this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
    }
    if (null != this.previous) {
      this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);
      if (null == this.error) {
        this.currentState = this.constraintHandler.currentFocus;
      }
      if (null != this.error || null != this.currentState && !this.isCellEnabled(this.currentState.cell)) {
        this.constraintHandler.reset();
      }
    }
  } else {
    if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
      this.marker.reset();
      this.currentState = null;
    } else {
      this.marker.process(me);
      this.currentState = this.marker.getValidState();
    }
    if (!(null == this.currentState)) {
      if (!this.isCellEnabled(this.currentState.cell)) {
        this.constraintHandler.reset();
        this.marker.reset();
        this.currentState = null;
      }
    }
    var constraint = this.isOutlineConnectEvent(me);
    if (null != this.currentState) {
      if (constraint) {
        if (me.isSource(this.marker.highlight.shape)) {
          point = new mxPoint(me.getGraphX(), me.getGraphY());
        }
        constraint = this.graph.getOutlineConstraint(point, this.currentState, me);
        this.constraintHandler.setFocus(me, this.currentState, false);
        this.constraintHandler.currentConstraint = constraint;
        this.constraintHandler.currentPoint = point;
      }
    }
    if (this.outlineConnect) {
      if (null != this.marker.highlight) {
        if (null != this.marker.highlight.shape) {
          point = this.graph.view.scale;
          if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus) {
            this.marker.highlight.shape.stroke = mxConstants.OUTLINE_HIGHLIGHT_COLOR;
            this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / point / point;
            this.marker.highlight.repaint();
          } else {
            if (this.marker.hasValidState()) {
              if (this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState()) {
                this.marker.highlight.shape.stroke = "transparent";
                this.currentState = null;
              } else {
                this.marker.highlight.shape.stroke = mxConstants.DEFAULT_VALID_COLOR;
              }
              this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / point / point;
              this.marker.highlight.repaint();
            }
          }
        }
      }
    }
  }
};
mxConnectionHandler.prototype.isCellEnabled = function(cell) {
  return true;
};
mxConnectionHandler.prototype.convertWaypoint = function(point) {
  var scale = this.graph.getView().getScale();
  var tr = this.graph.getView().getTranslate();
  point.x = point.x / scale - tr.x;
  point.y = point.y / scale - tr.y;
};
mxConnectionHandler.prototype.snapToPreview = function(me, point) {
  if (!mxEvent.isAltDown(me.getEvent()) && null != this.previous) {
    var c = this.graph.gridSize * this.graph.view.scale / 2;
    var tmp = null != this.sourceConstraint ? this.first : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
    if (Math.abs(tmp.x - me.getGraphX()) < c) {
      point.x = tmp.x;
    }
    if (Math.abs(tmp.y - me.getGraphY()) < c) {
      point.y = tmp.y;
    }
  }
};
mxConnectionHandler.prototype.mouseMove = function(point, me) {
  if (me.isConsumed() || !this.ignoreMouseDown && (null == this.first && this.graph.isMouseDown)) {
    this.constraintHandler.reset();
  } else {
    if (!this.isEnabled()) {
      if (!(null == this.currentState)) {
        this.destroyIcons();
        this.currentState = null;
      }
    }
    point = this.graph.getView();
    var current = point.scale;
    var i = point.translate;
    point = new mxPoint(me.getGraphX(), me.getGraphY());
    this.error = null;
    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      point = new mxPoint((this.graph.snap(point.x / current - i.x) + i.x) * current, (this.graph.snap(point.y / current - i.y) + i.y) * current);
    }
    this.snapToPreview(me, point);
    this.currentPoint = point;
    if (null != this.first || this.isEnabled() && this.graph.isEnabled()) {
      if (null != this.shape || (null == this.first || (Math.abs(me.getGraphX() - this.first.x) > this.graph.tolerance || Math.abs(me.getGraphY() - this.first.y) > this.graph.tolerance))) {
        this.updateCurrentState(me, point);
      }
    }
    if (null != this.first) {
      var constraint = null;
      current = point;
      if (null != this.constraintHandler.currentConstraint && (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint)) {
        constraint = this.constraintHandler.currentConstraint;
        current = this.constraintHandler.currentPoint.clone();
      } else {
        if (null != this.previous) {
          if (mxEvent.isShiftDown(me.getEvent())) {
            if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {
              if (Math.abs(this.previous.getCenterX() - point.x) < Math.abs(this.previous.getCenterY() - point.y)) {
                point.x = this.previous.getCenterX();
              } else {
                point.y = this.previous.getCenterY();
              }
            }
          }
        }
      }
      i = this.first;
      if (null != this.selectedIcon) {
        var tmp = this.selectedIcon.bounds.width;
        var len = this.selectedIcon.bounds.height;
        if (null != this.currentState && this.targetConnectImage) {
          tmp = this.getIconPosition(this.selectedIcon, this.currentState);
          this.selectedIcon.bounds.x = tmp.x;
          this.selectedIcon.bounds.y = tmp.y;
        } else {
          tmp = new mxRectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, tmp, len);
          this.selectedIcon.bounds = tmp;
        }
        this.selectedIcon.redraw();
      }
      if (null != this.edgeState) {
        this.updateEdgeState(current, constraint);
        current = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];
        i = this.edgeState.absolutePoints[0];
      } else {
        if (null != this.currentState) {
          if (null == this.constraintHandler.currentConstraint) {
            tmp = this.getTargetPerimeterPoint(this.currentState, me);
            if (null != tmp) {
              current = tmp;
            }
          }
        }
        if (null == this.sourceConstraint) {
          if (null != this.previous) {
            tmp = this.getSourcePerimeterPoint(this.previous, null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[0] : current, me);
            if (null != tmp) {
              i = tmp;
            }
          }
        }
      }
      if (null == this.currentState && this.movePreviewAway) {
        tmp = i;
        if (null != this.edgeState) {
          if (2 <= this.edgeState.absolutePoints.length) {
            constraint = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];
            if (null != constraint) {
              tmp = constraint;
            }
          }
        }
        constraint = current.x - tmp.x;
        tmp = current.y - tmp.y;
        len = Math.sqrt(constraint * constraint + tmp * tmp);
        if (0 == len) {
          return;
        }
        this.originalPoint = current.clone();
        current.x -= 4 * constraint / len;
        current.y -= 4 * tmp / len;
      } else {
        this.originalPoint = null;
      }
      if (null == this.shape) {
        if (constraint = Math.abs(me.getGraphX() - this.first.x), tmp = Math.abs(me.getGraphY() - this.first.y), constraint > this.graph.tolerance || tmp > this.graph.tolerance) {
          this.shape = this.createShape();
          if (null != this.edgeState) {
            this.shape.apply(this.edgeState);
          }
          this.updateCurrentState(me, point);
        }
      }
      if (null != this.shape) {
        if (null != this.edgeState) {
          this.shape.points = this.edgeState.absolutePoints;
        } else {
          point = [i];
          if (null != this.waypoints) {
            point = point.concat(this.waypoints);
          }
          point.push(current);
          this.shape.points = point;
        }
        this.drawPreview();
      }
      if (null != this.cursor) {
        this.graph.container.style.cursor = this.cursor;
      }
      mxEvent.consume(me.getEvent());
      me.consume();
    } else {
      if (this.isEnabled() && this.graph.isEnabled()) {
        if (this.previous != this.currentState && null == this.edgeState) {
          this.destroyIcons();
          if (null != this.currentState) {
            if (null == this.error) {
              if (null == this.constraintHandler.currentConstraint) {
                this.icons = this.createIcons(this.currentState);
                if (null == this.icons) {
                  this.currentState.setCursor(mxConstants.CURSOR_CONNECT);
                  me.consume();
                }
              }
            }
          }
          this.previous = this.currentState;
        } else {
          if (!(this.previous != this.currentState)) {
            if (!(null == this.currentState)) {
              if (!(null != this.icons)) {
                if (!this.graph.isMouseDown) {
                  me.consume();
                }
              }
            }
          }
        }
      } else {
        this.constraintHandler.reset();
      }
    }
    if (!this.graph.isMouseDown && (null != this.currentState && null != this.icons)) {
      point = false;
      current = me.getSource();
      for (i = 0;i < this.icons.length && !point;i++) {
        point = current == this.icons[i].node || current.parentNode == this.icons[i].node;
      }
      if (!point) {
        this.updateIcons(this.currentState, this.icons, me);
      }
    }
  }
};
mxConnectionHandler.prototype.updateEdgeState = function(points, constraint) {
  if (null != this.sourceConstraint) {
    if (null != this.sourceConstraint.point) {
      this.edgeState.style[mxConstants.STYLE_EXIT_X] = this.sourceConstraint.point.x;
      this.edgeState.style[mxConstants.STYLE_EXIT_Y] = this.sourceConstraint.point.y;
    }
  }
  if (null != constraint && null != constraint.point) {
    this.edgeState.style[mxConstants.STYLE_ENTRY_X] = constraint.point.x;
    this.edgeState.style[mxConstants.STYLE_ENTRY_Y] = constraint.point.y;
  } else {
    delete this.edgeState.style[mxConstants.STYLE_ENTRY_X];
    delete this.edgeState.style[mxConstants.STYLE_ENTRY_Y];
  }
  this.edgeState.absolutePoints = [null, null != this.currentState ? null : points];
  this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);
  if (null != this.currentState) {
    if (null == constraint) {
      constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);
    }
    this.edgeState.setAbsoluteTerminalPoint(null, false);
    this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);
  }
  points = null;
  if (null != this.waypoints) {
    points = [];
    for (constraint = 0;constraint < this.waypoints.length;constraint++) {
      var pt = this.waypoints[constraint].clone();
      this.convertWaypoint(pt);
      points[constraint] = pt;
    }
  }
  this.graph.view.updatePoints(this.edgeState, points, this.previous, this.currentState);
  this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
};
mxConnectionHandler.prototype.getTargetPerimeterPoint = function(state, me) {
  me = null;
  var view = state.view;
  var targetPerimeter = view.getPerimeterFunction(state);
  if (null != targetPerimeter) {
    var next = null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[this.waypoints.length - 1] : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
    state = targetPerimeter(view.getPerimeterBounds(state), this.edgeState, next, false);
    if (null != state) {
      me = state;
    }
  } else {
    me = new mxPoint(state.getCenterX(), state.getCenterY());
  }
  return me;
};
mxConnectionHandler.prototype.getSourcePerimeterPoint = function(state, next, me) {
  me = null;
  var view = state.view;
  var sourcePerimeter = view.getPerimeterFunction(state);
  var c = new mxPoint(state.getCenterX(), state.getCenterY());
  if (null != sourcePerimeter) {
    var g = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);
    var rad = Math.PI / 180 * -g;
    if (0 != g) {
      next = mxUtils.getRotatedPoint(new mxPoint(next.x, next.y), Math.cos(rad), Math.sin(rad), c);
    }
    state = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);
    if (null != state) {
      if (0 != g) {
        state = mxUtils.getRotatedPoint(new mxPoint(state.x, state.y), Math.cos(-rad), Math.sin(-rad), c);
      }
      me = state;
    }
  } else {
    me = c;
  }
  return me;
};
mxConnectionHandler.prototype.updateIcons = function(icons, state, me) {
};
mxConnectionHandler.prototype.isStopEvent = function(me) {
  return null != me.getState();
};
mxConnectionHandler.prototype.addWaypointForEvent = function(me) {
  var point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());
  var s = Math.abs(point.x - this.first.x);
  point = Math.abs(point.y - this.first.y);
  if (null != this.waypoints || 1 < this.mouseDownCounter && (s > this.graph.tolerance || point > this.graph.tolerance)) {
    if (null == this.waypoints) {
      this.waypoints = [];
    }
    s = this.graph.view.scale;
    point = new mxPoint(this.graph.snap(me.getGraphX() / s) * s, this.graph.snap(me.getGraphY() / s) * s);
    this.waypoints.push(point);
  }
};
mxConnectionHandler.prototype.checkConstraints = function(c1, c2) {
  return null == c1 || (null == c2 || (null == c1.point || (null == c2.point || (!c1.point.equals(c2.point) || (c1.dx != c2.dx || (c1.dy != c2.dy || c1.perimeter != c2.perimeter))))));
};
mxConnectionHandler.prototype.mouseUp = function(c1, me) {
  if (!me.isConsumed() && this.isConnecting()) {
    if (this.waypointsEnabled && !this.isStopEvent(me)) {
      this.addWaypointForEvent(me);
      me.consume();
      return;
    }
    c1 = this.sourceConstraint;
    var c2 = this.constraintHandler.currentConstraint;
    var source = null != this.previous ? this.previous.cell : null;
    var isConnect = null;
    if (null != this.constraintHandler.currentConstraint) {
      if (null != this.constraintHandler.currentFocus) {
        isConnect = this.constraintHandler.currentFocus.cell;
      }
    }
    if (null == isConnect) {
      if (null != this.currentState) {
        isConnect = this.currentState.cell;
      }
    }
    if (null != this.error || null != source && (null != isConnect && (source == isConnect && !this.checkConstraints(c1, c2)))) {
      if (null != this.previous) {
        if (null != this.marker.validState) {
          if (this.previous.cell == this.marker.validState.cell) {
            this.graph.selectCellForEvent(this.marker.source, me.getEvent());
          }
        }
      }
      if (null != this.error) {
        if (0 < this.error.length) {
          this.graph.validationAlert(this.error);
        }
      }
    } else {
      this.connect(source, isConnect, me.getEvent(), me.getCell());
    }
    this.destroyIcons();
    me.consume();
  }
  if (null != this.first) {
    this.reset();
  }
};
mxConnectionHandler.prototype.reset = function() {
  if (null != this.shape) {
    this.shape.destroy();
    this.shape = null;
  }
  if (null != this.cursor) {
    if (null != this.graph.container) {
      this.graph.container.style.cursor = "";
    }
  }
  this.destroyIcons();
  this.marker.reset();
  this.constraintHandler.reset();
  this.sourceConstraint = this.error = this.previous = this.edgeState = this.currentPoint = this.originalPoint = null;
  this.mouseDownCounter = 0;
  this.first = null;
  this.fireEvent(new mxEventObject(mxEvent.RESET));
};
mxConnectionHandler.prototype.drawPreview = function() {
  this.updatePreview(null == this.error);
  if (null != this.edgeState) {
    this.edgeState.shape = this.shape;
    this.graph.cellRenderer.postConfigureShape(this.edgeState);
    this.edgeState.shape = null;
  }
  this.shape.redraw();
};
mxConnectionHandler.prototype.updatePreview = function(valid) {
  this.shape.strokewidth = this.getEdgeWidth(valid);
  this.shape.stroke = this.getEdgeColor(valid);
};
mxConnectionHandler.prototype.getEdgeColor = function(valid) {
  return valid ? mxConstants.VALID_COLOR : mxConstants.INVALID_COLOR;
};
mxConnectionHandler.prototype.getEdgeWidth = function(valid) {
  return valid ? 3 : 1;
};
mxConnectionHandler.prototype.connect = function(source, target, evt, cell) {
  if (null != target || (this.isCreateTarget(evt) || this.graph.allowDanglingEdges)) {
    var model = this.graph.getModel();
    var terminalInserted = false;
    var edge = null;
    model.beginUpdate();
    try {
      if (null != source && (null == target && (!this.graph.isIgnoreTerminalEvent(evt) && (this.isCreateTarget(evt) && (target = this.createTargetVertex(evt, source), null != target))))) {
        cell = this.graph.getDropTarget([target], evt, cell);
        terminalInserted = true;
        if (null != cell && this.graph.getModel().isEdge(cell)) {
          cell = this.graph.getDefaultParent();
        } else {
          var value = this.graph.getView().getState(cell);
          if (null != value) {
            var tmp = model.getGeometry(target);
            tmp.x -= value.origin.x;
            tmp.y -= value.origin.y;
          }
        }
        this.graph.addCell(target, cell);
      }
      var parent = this.graph.getDefaultParent();
      if (null != source) {
        if (null != target) {
          if (model.getParent(source) == model.getParent(target)) {
            if (model.getParent(model.getParent(source)) != model.getRoot()) {
              parent = model.getParent(source);
              if (null != source.geometry) {
                if (source.geometry.relative) {
                  if (null != target.geometry) {
                    if (target.geometry.relative) {
                      parent = model.getParent(parent);
                    }
                  }
                }
              }
            }
          }
        }
      }
      var style = value = null;
      if (null != this.edgeState) {
        value = this.edgeState.cell.value;
        style = this.edgeState.cell.style;
      }
      edge = this.insertEdge(parent, null, value, source, target, style);
      if (null != edge) {
        this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);
        this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);
        if (null != this.edgeState) {
          model.setGeometry(edge, this.edgeState.cell.geometry);
        }
        parent = model.getParent(source);
        if (this.isInsertBefore(edge, source, target, evt, cell)) {
          for (tmp = source;null != tmp.parent && (null != tmp.geometry && (tmp.geometry.relative && tmp.parent != edge.parent));) {
            tmp = this.graph.model.getParent(tmp);
          }
          if (null != tmp) {
            if (null != tmp.parent) {
              if (tmp.parent == edge.parent) {
                model.add(parent, edge, tmp.parent.getIndex(tmp));
              }
            }
          }
        }
        var geo = model.getGeometry(edge);
        if (null == geo) {
          geo = new mxGeometry;
          geo.relative = true;
          model.setGeometry(edge, geo);
        }
        if (null != this.waypoints && 0 < this.waypoints.length) {
          var s = this.graph.view.scale;
          var t = this.graph.view.translate;
          geo.points = [];
          for (source = 0;source < this.waypoints.length;source++) {
            var pt = this.waypoints[source];
            geo.points.push(new mxPoint(pt.x / s - t.x, pt.y / s - t.y));
          }
        }
        if (null == target) {
          var tr = this.graph.view.translate;
          s = this.graph.view.scale;
          pt = null != this.originalPoint ? new mxPoint(this.originalPoint.x / s - tr.x, this.originalPoint.y / s - tr.y) : new mxPoint(this.currentPoint.x / s - tr.x, this.currentPoint.y / s - tr.y);
          pt.x -= this.graph.panDx / this.graph.view.scale;
          pt.y -= this.graph.panDy / this.graph.view.scale;
          geo.setTerminalPoint(pt, false);
        }
        this.fireEvent(new mxEventObject(mxEvent.CONNECT, "cell", edge, "terminal", target, "event", evt, "target", cell, "terminalInserted", terminalInserted));
      }
    } catch (e) {
      mxLog.show();
      mxLog.debug(e.message);
    } finally {
      model.endUpdate();
    }
    if (this.select) {
      this.selectCells(edge, terminalInserted ? target : null);
    }
  }
};
mxConnectionHandler.prototype.selectCells = function(edge, vertices) {
  this.graph.setSelectionCell(edge);
};
mxConnectionHandler.prototype.insertEdge = function(parent, edge, value, source, target, style) {
  if (null == this.factoryMethod) {
    return this.graph.insertEdge(parent, edge, value, source, target, style);
  }
  edge = this.createEdge(value, source, target, style);
  return edge = this.graph.addEdge(edge, parent, source, target);
};
mxConnectionHandler.prototype.createTargetVertex = function(geo, source) {
  for (geo = this.graph.getCellGeometry(source);null != geo && geo.relative;) {
    source = this.graph.getModel().getParent(source);
    geo = this.graph.getCellGeometry(source);
  }
  var clone = this.graph.cloneCell(source);
  geo = this.graph.getModel().getGeometry(clone);
  if (null != geo) {
    var y = this.graph.view.translate;
    var s = this.graph.view.scale;
    var point = new mxPoint(this.currentPoint.x / s - y.x, this.currentPoint.y / s - y.y);
    geo.x = Math.round(point.x - geo.width / 2 - this.graph.panDx / s);
    geo.y = Math.round(point.y - geo.height / 2 - this.graph.panDy / s);
    point = this.getAlignmentTolerance();
    if (0 < point) {
      var sourceState = this.graph.view.getState(source);
      if (null != sourceState) {
        source = sourceState.x / s - y.x;
        y = sourceState.y / s - y.y;
        if (Math.abs(source - geo.x) <= point) {
          geo.x = Math.round(source);
        }
        if (Math.abs(y - geo.y) <= point) {
          geo.y = Math.round(y);
        }
      }
    }
  }
  return clone;
};
mxConnectionHandler.prototype.getAlignmentTolerance = function(evt) {
  return this.graph.isGridEnabled() ? this.graph.gridSize / 2 : this.graph.tolerance;
};
mxConnectionHandler.prototype.createEdge = function(geometry, source, target, style) {
  var edge = null;
  if (null != this.factoryMethod) {
    edge = this.factoryMethod(source, target, style);
  }
  if (null == edge) {
    edge = new mxCell(geometry || "");
    edge.setEdge(true);
    edge.setStyle(style);
    geometry = new mxGeometry;
    geometry.relative = true;
    edge.setGeometry(geometry);
  }
  return edge;
};
mxConnectionHandler.prototype.destroy = function() {
  this.graph.removeMouseListener(this);
  if (null != this.shape) {
    this.shape.destroy();
    this.shape = null;
  }
  if (null != this.marker) {
    this.marker.destroy();
    this.marker = null;
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.destroy();
    this.constraintHandler = null;
  }
  if (null != this.changeHandler) {
    this.graph.getModel().removeListener(this.changeHandler);
    this.graph.getView().removeListener(this.changeHandler);
    this.changeHandler = null;
  }
  if (null != this.drillHandler) {
    this.graph.removeListener(this.drillHandler);
    this.graph.getView().removeListener(this.drillHandler);
    this.drillHandler = null;
  }
  if (null != this.escapeHandler) {
    this.graph.removeListener(this.escapeHandler);
    this.escapeHandler = null;
  }
};
function mxConstraintHandler(graph) {
  this.graph = graph;
  this.resetHandler = mxUtils.bind(this, function(flex, editor) {
    if (null != this.currentFocus && null == this.graph.view.getState(this.currentFocus.cell)) {
      this.reset();
    } else {
      this.redraw();
    }
  });
  this.graph.model.addListener(mxEvent.CHANGE, this.resetHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent.TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent.SCALE, this.resetHandler);
  this.graph.addListener(mxEvent.ROOT, this.resetHandler);
}
mxConstraintHandler.prototype.pointImage = new mxImage(mxClient.imageBasePath + "/point.gif", 5, 5);
mxConstraintHandler.prototype.graph = null;
mxConstraintHandler.prototype.enabled = true;
mxConstraintHandler.prototype.highlightColor = mxConstants.DEFAULT_VALID_COLOR;
mxConstraintHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxConstraintHandler.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxConstraintHandler.prototype.reset = function() {
  if (null != this.focusIcons) {
    for (var i = 0;i < this.focusIcons.length;i++) {
      this.focusIcons[i].destroy();
    }
    this.focusIcons = null;
  }
  if (null != this.focusHighlight) {
    this.focusHighlight.destroy();
    this.focusHighlight = null;
  }
  this.focusPoints = this.currentFocus = this.currentPoint = this.currentFocusArea = this.currentConstraint = null;
};
mxConstraintHandler.prototype.getTolerance = function(me) {
  return this.graph.getTolerance();
};
mxConstraintHandler.prototype.getImageForConstraint = function(state, constraint, point) {
  return this.pointImage;
};
mxConstraintHandler.prototype.isEventIgnored = function(me, source) {
  return false;
};
mxConstraintHandler.prototype.isStateIgnored = function(state, mainLoopIteration) {
  return false;
};
mxConstraintHandler.prototype.destroyIcons = function() {
  if (null != this.focusIcons) {
    for (var i = 0;i < this.focusIcons.length;i++) {
      this.focusIcons[i].destroy();
    }
    this.focusPoints = this.focusIcons = null;
  }
};
mxConstraintHandler.prototype.destroyFocusHighlight = function() {
  if (null != this.focusHighlight) {
    this.focusHighlight.destroy();
    this.focusHighlight = null;
  }
};
mxConstraintHandler.prototype.isKeepFocusEvent = function(me) {
  return mxEvent.isShiftDown(me.getEvent()) && !mxEvent.isAltDown(me.getEvent());
};
mxConstraintHandler.prototype.getCellForEvent = function(me, point) {
  var cell = me.getCell();
  if (!(null != cell)) {
    if (!(null == point)) {
      if (!(me.getGraphX() == point.x && me.getGraphY() == point.y)) {
        cell = this.graph.getCellAt(point.x, point.y);
      }
    }
  }
  if (!(null == cell)) {
    if (!this.graph.isCellConnectable(cell)) {
      me = this.graph.getModel().getParent(cell);
      if (this.graph.getModel().isVertex(me)) {
        if (this.graph.isCellConnectable(me)) {
          cell = me;
        }
      }
    }
  }
  return this.graph.isCellLocked(cell) ? null : cell;
};
mxConstraintHandler.prototype.update = function(me, y, existingEdge, point) {
  if (this.isEnabled() && !this.isEventIgnored(me)) {
    if (null == this.mouseleaveHandler) {
      if (null != this.graph.container) {
        this.mouseleaveHandler = mxUtils.bind(this, function() {
          this.reset();
        });
        mxEvent.addListener(this.graph.container, "mouseleave", this.resetHandler);
      }
    }
    var hit = this.getTolerance(me);
    var x = null != point ? point.x : me.getGraphX();
    var cy = null != point ? point.y : me.getGraphY();
    x = new mxRectangle(x - hit, cy - hit, 2 * hit, 2 * hit);
    hit = new mxRectangle(me.getGraphX() - hit, me.getGraphY() - hit, 2 * hit, 2 * hit);
    var state = this.graph.view.getState(this.getCellForEvent(me, point));
    if (!this.isKeepFocusEvent(me)) {
      if (!(null != this.currentFocusArea && (null != this.currentFocus && (null == state && (this.graph.getModel().isVertex(this.currentFocus.cell) && mxUtils.intersects(this.currentFocusArea, hit)))))) {
        if (!(state == this.currentFocus)) {
          this.currentFocus = this.currentFocusArea = null;
          this.setFocus(me, state, y);
        }
      }
    }
    me = this.currentPoint = this.currentConstraint = null;
    if (null != this.focusIcons && (null != this.constraints && (null == state || this.currentFocus == state))) {
      cy = hit.getCenterX();
      var l = hit.getCenterY();
      for (var i = 0;i < this.focusIcons.length;i++) {
        var tmp = cy - this.focusIcons[i].bounds.getCenterX();
        var hl = l - this.focusIcons[i].bounds.getCenterY();
        tmp = tmp * tmp + hl * hl;
        if ((this.intersects(this.focusIcons[i], hit, y, existingEdge) || null != point && this.intersects(this.focusIcons[i], x, y, existingEdge)) && (null == me || tmp < me)) {
          this.currentConstraint = this.constraints[i];
          this.currentPoint = this.focusPoints[i];
          me = tmp;
          tmp = this.focusIcons[i].bounds.clone();
          tmp.grow(mxConstants.HIGHLIGHT_SIZE + 1);
          --tmp.width;
          --tmp.height;
          if (null == this.focusHighlight) {
            hl = this.createHighlightShape();
            hl.dialect = mxConstants.DIALECT_SVG;
            hl.pointerEvents = false;
            hl.init(this.graph.getView().getOverlayPane());
            this.focusHighlight = hl;
            var getState = mxUtils.bind(this, function() {
              return null != this.currentFocus ? this.currentFocus : state;
            });
            mxEvent.redirectMouseEvents(hl.node, this.graph, getState);
          }
          this.focusHighlight.bounds = tmp;
          this.focusHighlight.redraw();
        }
      }
    }
    if (null == this.currentConstraint) {
      this.destroyFocusHighlight();
    }
  } else {
    this.currentPoint = this.currentFocus = this.currentConstraint = null;
  }
};
mxConstraintHandler.prototype.redraw = function() {
  if (null != this.currentFocus && (null != this.constraints && null != this.focusIcons)) {
    var state = this.graph.view.getState(this.currentFocus.cell);
    this.currentFocus = state;
    this.currentFocusArea = new mxRectangle(state.x, state.y, state.width, state.height);
    for (var i = 0;i < this.constraints.length;i++) {
      var cp = this.graph.getConnectionPoint(state, this.constraints[i]);
      var img = this.getImageForConstraint(state, this.constraints[i], cp);
      img = new mxRectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
      this.focusIcons[i].bounds = img;
      this.focusIcons[i].redraw();
      this.currentFocusArea.add(this.focusIcons[i].bounds);
      this.focusPoints[i] = cp;
    }
  }
};
mxConstraintHandler.prototype.setFocus = function(me, state, i) {
  this.constraints = null != state && (!this.isStateIgnored(state, i) && this.graph.isCellConnectable(state.cell)) ? this.isEnabled() ? this.graph.getAllConnectionConstraints(state, i) || [] : [] : null;
  if (null != this.constraints) {
    this.currentFocus = state;
    this.currentFocusArea = new mxRectangle(state.x, state.y, state.width, state.height);
    if (null != this.focusIcons) {
      for (i = 0;i < this.focusIcons.length;i++) {
        this.focusIcons[i].destroy();
      }
      this.focusPoints = this.focusIcons = null;
    }
    this.focusPoints = [];
    this.focusIcons = [];
    for (i = 0;i < this.constraints.length;i++) {
      var cp = this.graph.getConnectionPoint(state, this.constraints[i]);
      var img = this.getImageForConstraint(state, this.constraints[i], cp);
      var icon = img.src;
      img = new mxRectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
      icon = new mxImageShape(img, icon);
      icon.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
      icon.preserveImageAspect = false;
      icon.init(this.graph.getView().getDecoratorPane());
      if (null != icon.node.previousSibling) {
        icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
      }
      img = mxUtils.bind(this, function() {
        return null != this.currentFocus ? this.currentFocus : state;
      });
      icon.redraw();
      mxEvent.redirectMouseEvents(icon.node, this.graph, img);
      this.currentFocusArea.add(icon.bounds);
      this.focusIcons.push(icon);
      this.focusPoints.push(cp);
    }
    this.currentFocusArea.grow(this.getTolerance(me));
  } else {
    this.destroyIcons();
    this.destroyFocusHighlight();
  }
};
mxConstraintHandler.prototype.createHighlightShape = function() {
  var hl = new mxRectangleShape(null, this.highlightColor, this.highlightColor, mxConstants.HIGHLIGHT_STROKEWIDTH);
  hl.opacity = mxConstants.HIGHLIGHT_OPACITY;
  return hl;
};
mxConstraintHandler.prototype.intersects = function(state, x, y, existingEdge) {
  return mxUtils.intersects(state.bounds, x);
};
mxConstraintHandler.prototype.destroy = function() {
  this.reset();
  if (null != this.resetHandler) {
    this.graph.model.removeListener(this.resetHandler);
    this.graph.view.removeListener(this.resetHandler);
    this.graph.removeListener(this.resetHandler);
    this.resetHandler = null;
  }
  if (null != this.mouseleaveHandler) {
    if (null != this.graph.container) {
      mxEvent.removeListener(this.graph.container, "mouseleave", this.mouseleaveHandler);
      this.mouseleaveHandler = null;
    }
  }
};
function mxRubberband(graph) {
  if (null != graph) {
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.forceRubberbandHandler = mxUtils.bind(this, function(evtName, me) {
      evtName = me.getProperty("eventName");
      me = me.getProperty("event");
      if (evtName == mxEvent.MOUSE_DOWN && this.isForceRubberbandEvent(me)) {
        evtName = mxUtils.getOffset(this.graph.container);
        var origin = mxUtils.getScrollOrigin(this.graph.container);
        origin.x -= evtName.x;
        origin.y -= evtName.y;
        this.start(me.getX() + origin.x, me.getY() + origin.y);
        me.consume(false);
      }
    });
    this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);
    this.panHandler = mxUtils.bind(this, function() {
      this.repaint();
    });
    this.graph.addListener(mxEvent.PAN, this.panHandler);
    this.gestureHandler = mxUtils.bind(this, function(flex, editor) {
      if (null != this.first) {
        this.reset();
      }
    });
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
    if (mxClient.IS_IE) {
      mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
        this.destroy();
      }));
    }
  }
}
mxRubberband.prototype.defaultOpacity = 20;
mxRubberband.prototype.enabled = true;
mxRubberband.prototype.div = null;
mxRubberband.prototype.sharedDiv = null;
mxRubberband.prototype.currentX = 0;
mxRubberband.prototype.currentY = 0;
mxRubberband.prototype.fadeOut = false;
mxRubberband.prototype.isEnabled = function() {
  return this.enabled;
};
mxRubberband.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxRubberband.prototype.isForceRubberbandEvent = function(me) {
  return mxEvent.isAltDown(me.getEvent());
};
mxRubberband.prototype.mouseDown = function(offset, me) {
  if (!me.isConsumed() && (this.isEnabled() && (this.graph.isEnabled() && (null == me.getState() && !mxEvent.isMultiTouchEvent(me.getEvent()))))) {
    offset = mxUtils.getOffset(this.graph.container);
    var origin = mxUtils.getScrollOrigin(this.graph.container);
    origin.x -= offset.x;
    origin.y -= offset.y;
    this.start(me.getX() + origin.x, me.getY() + origin.y);
    me.consume(false);
  }
};
mxRubberband.prototype.start = function(x, y) {
  function createMouseEvent(me) {
    me = new mxMouseEvent(me);
    var pt = mxUtils.convertPoint(container, me.getX(), me.getY());
    me.graphX = pt.x;
    me.graphY = pt.y;
    return me;
  }
  this.first = new mxPoint(x, y);
  var container = this.graph.container;
  this.dragHandler = mxUtils.bind(this, function(evt) {
    this.mouseMove(this.graph, createMouseEvent(evt));
  });
  this.dropHandler = mxUtils.bind(this, function(evt) {
    this.mouseUp(this.graph, createMouseEvent(evt));
  });
  if (mxClient.IS_FF) {
    mxEvent.addGestureListeners(document, null, this.dragHandler, this.dropHandler);
  }
};
mxRubberband.prototype.mouseMove = function(x, me) {
  if (!me.isConsumed() && null != this.first) {
    var y = mxUtils.getScrollOrigin(this.graph.container);
    x = mxUtils.getOffset(this.graph.container);
    y.x -= x.x;
    y.y -= x.y;
    x = me.getX() + y.x;
    y = me.getY() + y.y;
    var dx = this.first.x - x;
    var dy = this.first.y - y;
    var tol = this.graph.tolerance;
    if (null != this.div || (Math.abs(dx) > tol || Math.abs(dy) > tol)) {
      if (null == this.div) {
        this.div = this.createShape();
      }
      mxUtils.clearSelection();
      this.update(x, y);
      me.consume();
    }
  }
};
mxRubberband.prototype.createShape = function() {
  if (null == this.sharedDiv) {
    this.sharedDiv = document.createElement("div");
    this.sharedDiv.className = "mxRubberband";
    mxUtils.setOpacity(this.sharedDiv, this.defaultOpacity);
  }
  this.graph.container.appendChild(this.sharedDiv);
  var result = this.sharedDiv;
  if (mxClient.IS_SVG) {
    if (!mxClient.IS_IE || 10 <= document.documentMode) {
      if (this.fadeOut) {
        this.sharedDiv = null;
      }
    }
  }
  return result;
};
mxRubberband.prototype.isActive = function(me, sender) {
  return null != this.div && "none" != this.div.style.display;
};
mxRubberband.prototype.mouseUp = function(sender, me) {
  sender = this.isActive();
  this.reset();
  if (sender) {
    this.execute(me.getEvent());
    me.consume();
  }
};
mxRubberband.prototype.execute = function(parent) {
  var rect = new mxRectangle(this.x, this.y, this.width, this.height);
  this.graph.selectRegion(rect, parent);
};
mxRubberband.prototype.reset = function() {
  if (null != this.div) {
    if (mxClient.IS_SVG && ((!mxClient.IS_IE || 10 <= document.documentMode) && this.fadeOut)) {
      var temp = this.div;
      mxUtils.setPrefixedStyle(temp.style, "transition", "all 0.2s linear");
      temp.style.pointerEvents = "none";
      temp.style.opacity = 0;
      window.setTimeout(function() {
        temp.parentNode.removeChild(temp);
      }, 200);
    } else {
      this.div.parentNode.removeChild(this.div);
    }
  }
  mxEvent.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);
  this.dropHandler = this.dragHandler = null;
  this.currentY = this.currentX = 0;
  this.div = this.first = null;
};
mxRubberband.prototype.update = function(x, y) {
  this.currentX = x;
  this.currentY = y;
  this.repaint();
};
mxRubberband.prototype.repaint = function() {
  if (null != this.div) {
    var x = this.currentX - this.graph.panDx;
    var y = this.currentY - this.graph.panDy;
    this.x = Math.min(this.first.x, x);
    this.y = Math.min(this.first.y, y);
    this.width = Math.max(this.first.x, x) - this.x;
    this.height = Math.max(this.first.y, y) - this.y;
    this.div.style.left = this.x + 0 + "px";
    this.div.style.top = this.y + 0 + "px";
    this.div.style.width = Math.max(1, this.width) + "px";
    this.div.style.height = Math.max(1, this.height) + "px";
  }
};
mxRubberband.prototype.destroy = function() {
  if (!this.destroyed) {
    this.destroyed = true;
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.forceRubberbandHandler);
    this.graph.removeListener(this.panHandler);
    this.reset();
    if (null != this.sharedDiv) {
      this.sharedDiv = null;
    }
  }
};
function mxHandle(state, cursor, image, shape) {
  this.graph = state.view.graph;
  this.state = state;
  this.cursor = null != cursor ? cursor : this.cursor;
  this.image = null != image ? image : this.image;
  this.shape = null != shape ? shape : null;
  this.init();
}
mxHandle.prototype.cursor = "default";
mxHandle.prototype.image = null;
mxHandle.prototype.ignoreGrid = false;
mxHandle.prototype.getPosition = function(bounds) {
};
mxHandle.prototype.setPosition = function(bounds, pt, me) {
};
mxHandle.prototype.execute = function(parent) {
};
mxHandle.prototype.copyStyle = function(key) {
  this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);
};
mxHandle.prototype.processEvent = function(me) {
  var scale = this.graph.view.scale;
  var pt = this.graph.view.translate;
  pt = new mxPoint(me.getGraphX() / scale - pt.x, me.getGraphY() / scale - pt.y);
  if (null != this.shape) {
    if (null != this.shape.bounds) {
      pt.x -= this.shape.bounds.width / scale / 4;
      pt.y -= this.shape.bounds.height / scale / 4;
    }
  }
  scale = -mxUtils.toRadians(this.getRotation());
  var alpha2 = -mxUtils.toRadians(this.getTotalRotation()) - scale;
  pt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, scale), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha2));
  this.setPosition(this.state.getPaintBounds(), pt, me);
  this.redraw();
};
mxHandle.prototype.positionChanged = function() {
  if (null != this.state.text) {
    this.state.text.apply(this.state);
  }
  if (null != this.state.shape) {
    this.state.shape.apply(this.state);
  }
  this.graph.cellRenderer.redraw(this.state, true);
};
mxHandle.prototype.getRotation = function() {
  return null != this.state.shape ? this.state.shape.getRotation() : 0;
};
mxHandle.prototype.getTotalRotation = function() {
  return null != this.state.shape ? this.state.shape.getShapeRotation() : 0;
};
mxHandle.prototype.init = function() {
  var html = this.isHtmlRequired();
  if (null != this.image) {
    this.shape = new mxImageShape(new mxRectangle(0, 0, this.image.width, this.image.height), this.image.src);
    this.shape.preserveImageAspect = false;
  } else {
    if (null == this.shape) {
      this.shape = this.createShape(html);
    }
  }
  this.initShape(html);
};
mxHandle.prototype.createShape = function(html) {
  html = new mxRectangle(0, 0, mxConstants.HANDLE_SIZE, mxConstants.HANDLE_SIZE);
  return new mxRectangleShape(html, mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
mxHandle.prototype.initShape = function(html) {
  if (html && this.shape.isHtmlAllowed()) {
    this.shape.dialect = mxConstants.DIALECT_STRICTHTML;
    this.shape.init(this.graph.container);
  } else {
    this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    if (null != this.cursor) {
      this.shape.init(this.graph.getView().getOverlayPane());
    }
  }
  mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
  this.shape.node.style.cursor = this.cursor;
};
mxHandle.prototype.redraw = function() {
  if (null != this.shape && null != this.state.shape) {
    var pt = this.getPosition(this.state.getPaintBounds());
    if (null != pt) {
      var y = mxUtils.toRadians(this.getTotalRotation());
      pt = this.rotatePoint(this.flipPoint(pt), y);
      y = this.graph.view.scale;
      var tr = this.graph.view.translate;
      this.shape.bounds.x = Math.floor((pt.x + tr.x) * y - this.shape.bounds.width / 2);
      this.shape.bounds.y = Math.floor((pt.y + tr.y) * y - this.shape.bounds.height / 2);
      this.shape.redraw();
    }
  }
};
mxHandle.prototype.isHtmlRequired = function() {
  return null != this.state.text && this.state.text.node.parentNode == this.graph.container;
};
mxHandle.prototype.rotatePoint = function(pt, rad) {
  var cx = this.state.getCellBounds();
  cx = new mxPoint(cx.getCenterX(), cx.getCenterY());
  return mxUtils.getRotatedPoint(pt, Math.cos(rad), Math.sin(rad), cx);
};
mxHandle.prototype.flipPoint = function(pt) {
  if (null != this.state.shape) {
    var bounds = this.state.getCellBounds();
    if (this.state.shape.flipH) {
      pt.x = 2 * bounds.x + bounds.width - pt.x;
    }
    if (this.state.shape.flipV) {
      pt.y = 2 * bounds.y + bounds.height - pt.y;
    }
  }
  return pt;
};
mxHandle.prototype.snapPoint = function(pt, ignore) {
  if (!ignore) {
    pt.x = this.graph.snap(pt.x);
    pt.y = this.graph.snap(pt.y);
  }
  return pt;
};
mxHandle.prototype.setVisible = function(visible) {
  if (null != this.shape) {
    if (null != this.shape.node) {
      this.shape.node.style.display = visible ? "" : "none";
    }
  }
};
mxHandle.prototype.reset = function() {
  this.setVisible(true);
  this.state.style = this.graph.getCellStyle(this.state.cell);
  this.positionChanged();
};
mxHandle.prototype.destroy = function() {
  if (null != this.shape) {
    this.shape.destroy();
    this.shape = null;
  }
};
function mxVertexHandler(state) {
  if (null != state) {
    this.state = state;
    this.init();
    this.escapeHandler = mxUtils.bind(this, function(flex, editor) {
      if (this.livePreview) {
        if (null != this.index) {
          this.state.view.graph.cellRenderer.redraw(this.state, true);
          this.state.view.invalidate(this.state.cell);
          this.state.invalid = false;
          this.state.view.validate();
        }
      }
      this.reset();
    });
    this.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  }
}
mxVertexHandler.prototype.graph = null;
mxVertexHandler.prototype.state = null;
mxVertexHandler.prototype.singleSizer = false;
mxVertexHandler.prototype.index = null;
mxVertexHandler.prototype.allowHandleBoundsCheck = true;
mxVertexHandler.prototype.handleImage = null;
mxVertexHandler.prototype.handlesVisible = true;
mxVertexHandler.prototype.tolerance = 0;
mxVertexHandler.prototype.rotationEnabled = false;
mxVertexHandler.prototype.parentHighlightEnabled = false;
mxVertexHandler.prototype.rotationRaster = true;
mxVertexHandler.prototype.rotationCursor = "crosshair";
mxVertexHandler.prototype.livePreview = false;
mxVertexHandler.prototype.movePreviewToFront = false;
mxVertexHandler.prototype.manageSizers = false;
mxVertexHandler.prototype.constrainGroupByChildren = false;
mxVertexHandler.prototype.rotationHandleVSpacing = -16;
mxVertexHandler.prototype.horizontalOffset = 0;
mxVertexHandler.prototype.verticalOffset = 0;
mxVertexHandler.prototype.init = function() {
  this.graph = this.state.view.graph;
  this.selectionBounds = this.getSelectionBounds(this.state);
  this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
  this.selectionBorder = this.createSelectionShape(this.bounds);
  this.selectionBorder.dialect = mxConstants.DIALECT_SVG;
  this.selectionBorder.pointerEvents = false;
  this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  this.selectionBorder.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);
  if (this.graph.isCellMovable(this.state.cell)) {
    if (!this.graph.isCellLocked(this.state.cell)) {
      this.selectionBorder.setCursor(mxConstants.CURSOR_MOVABLE_VERTEX);
    }
  }
  if (0 >= mxGraphHandler.prototype.maxCells || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells) {
    var geo = this.graph.isCellResizable(this.state.cell) && !this.graph.isCellLocked(this.state.cell);
    this.sizers = [];
    if (geo || this.graph.isLabelMovable(this.state.cell) && (2 <= this.state.width && 2 <= this.state.height)) {
      var i = 0;
      if (geo) {
        if (!this.singleSizer) {
          this.sizers.push(this.createSizer("nw-resize", i++));
          this.sizers.push(this.createSizer("n-resize", i++));
          this.sizers.push(this.createSizer("ne-resize", i++));
          this.sizers.push(this.createSizer("w-resize", i++));
          this.sizers.push(this.createSizer("e-resize", i++));
          this.sizers.push(this.createSizer("sw-resize", i++));
          this.sizers.push(this.createSizer("s-resize", i++));
        }
        this.sizers.push(this.createSizer("se-resize", i++));
      }
      geo = this.graph.model.getGeometry(this.state.cell);
      if (!(null == geo)) {
        if (!geo.relative) {
          if (!this.graph.isSwimlane(this.state.cell)) {
            if (!!this.graph.isLabelMovable(this.state.cell)) {
              this.labelShape = this.createSizer(mxConstants.CURSOR_LABEL_HANDLE, mxEvent.LABEL_HANDLE, mxConstants.LABEL_HANDLE_SIZE, mxConstants.LABEL_HANDLE_FILLCOLOR);
              this.sizers.push(this.labelShape);
            }
          }
        }
      }
    } else {
      if (this.graph.isCellMovable(this.state.cell)) {
        if (!geo) {
          if (2 > this.state.width) {
            if (2 > this.state.height) {
              this.labelShape = this.createSizer(mxConstants.CURSOR_MOVABLE_VERTEX, mxEvent.LABEL_HANDLE, null, mxConstants.LABEL_HANDLE_FILLCOLOR);
              this.sizers.push(this.labelShape);
            }
          }
        }
      }
    }
  }
  if (this.isRotationHandleVisible()) {
    this.rotationShape = this.createSizer(this.rotationCursor, mxEvent.ROTATION_HANDLE, mxConstants.HANDLE_SIZE + 3, mxConstants.HANDLE_FILLCOLOR);
    this.sizers.push(this.rotationShape);
  }
  if (!this.graph.isCellLocked(this.state.cell)) {
    this.customHandles = this.createCustomHandles();
  }
  this.redraw();
  if (this.constrainGroupByChildren) {
    this.updateMinBounds();
  }
};
mxVertexHandler.prototype.isRotationHandleVisible = function() {
  return this.graph.isEnabled() && (this.rotationEnabled && (!this.graph.isCellLocked(this.state.cell) && (this.graph.isCellRotatable(this.state.cell) && (0 >= mxGraphHandler.prototype.maxCells || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells))));
};
mxVertexHandler.prototype.isConstrainedEvent = function(me) {
  return mxEvent.isShiftDown(me.getEvent()) || "fixed" == this.state.style[mxConstants.STYLE_ASPECT];
};
mxVertexHandler.prototype.isCenteredEvent = function(state, me) {
  return false;
};
mxVertexHandler.prototype.createCustomHandles = function() {
  return null;
};
mxVertexHandler.prototype.updateMinBounds = function() {
  var s = this.graph.getChildCells(this.state.cell);
  if (0 < s.length && (this.minBounds = this.graph.view.getBounds(s), null != this.minBounds)) {
    s = this.state.view.scale;
    var t = this.state.view.translate;
    this.minBounds.x -= this.state.x;
    this.minBounds.y -= this.state.y;
    this.minBounds.x /= s;
    this.minBounds.y /= s;
    this.minBounds.width /= s;
    this.minBounds.height /= s;
    this.x0 = this.state.x / s - t.x;
    this.y0 = this.state.y / s - t.y;
  }
};
mxVertexHandler.prototype.getSelectionBounds = function(state) {
  return new mxRectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));
};
mxVertexHandler.prototype.createParentHighlightShape = function(bounds) {
  return this.createSelectionShape(bounds);
};
mxVertexHandler.prototype.createSelectionShape = function(bounds) {
  bounds = new mxRectangleShape(mxRectangle.fromRectangle(bounds), null, this.getSelectionColor());
  bounds.strokewidth = this.getSelectionStrokeWidth();
  bounds.isDashed = this.isSelectionDashed();
  return bounds;
};
mxVertexHandler.prototype.getSelectionColor = function() {
  return this.graph.isCellEditable(this.state.cell) ? mxConstants.VERTEX_SELECTION_COLOR : mxConstants.LOCKED_HANDLE_FILLCOLOR;
};
mxVertexHandler.prototype.getSelectionStrokeWidth = function() {
  return mxConstants.VERTEX_SELECTION_STROKEWIDTH;
};
mxVertexHandler.prototype.isSelectionDashed = function() {
  return mxConstants.VERTEX_SELECTION_DASHED;
};
mxVertexHandler.prototype.createSizer = function(cursor, index, size, sizer) {
  size = size || mxConstants.HANDLE_SIZE;
  size = new mxRectangle(0, 0, size, size);
  sizer = this.createSizerShape(size, index, sizer);
  if (sizer.isHtmlAllowed() && (null != this.state.text && this.state.text.node.parentNode == this.graph.container)) {
    --sizer.bounds.height;
    --sizer.bounds.width;
    sizer.dialect = mxConstants.DIALECT_STRICTHTML;
    sizer.init(this.graph.container);
  } else {
    sizer.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    sizer.init(this.graph.getView().getOverlayPane());
  }
  mxEvent.redirectMouseEvents(sizer.node, this.graph, this.state);
  if (this.graph.isEnabled()) {
    sizer.setCursor(cursor);
  }
  if (!this.isSizerVisible(index)) {
    sizer.visible = false;
  }
  return sizer;
};
mxVertexHandler.prototype.isSizerVisible = function(index) {
  return true;
};
mxVertexHandler.prototype.createSizerShape = function(bounds, index, fillColor) {
  return null != this.handleImage ? (bounds = new mxRectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height), bounds = new mxImageShape(bounds, this.handleImage.src), bounds.preserveImageAspect = false, bounds) : index == mxEvent.ROTATION_HANDLE ? new mxEllipse(bounds, fillColor || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR) : new mxRectangleShape(bounds, fillColor || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
mxVertexHandler.prototype.moveSizerTo = function(shape, x, y) {
  if (null != shape) {
    shape.bounds.x = Math.floor(x - shape.bounds.width / 2);
    shape.bounds.y = Math.floor(y - shape.bounds.height / 2);
    if (null != shape.node) {
      if ("none" != shape.node.style.display) {
        shape.redraw();
      }
    }
  }
};
mxVertexHandler.prototype.getHandleForEvent = function(me) {
  var checkShape = mxEvent.isMouseEvent(me.getEvent()) ? 1 : this.tolerance;
  var c = this.allowHandleBoundsCheck && (mxClient.IS_IE || 0 < checkShape) ? new mxRectangle(me.getGraphX() - checkShape, me.getGraphY() - checkShape, 2 * checkShape, 2 * checkShape) : null;
  checkShape = mxUtils.bind(this, function(shape) {
    var height = null != shape && (shape.constructor != mxImageShape && this.allowHandleBoundsCheck) ? shape.strokewidth + shape.svgStrokeTolerance : null;
    height = null != height ? new mxRectangle(me.getGraphX() - Math.floor(height / 2), me.getGraphY() - Math.floor(height / 2), height, height) : c;
    return null != shape && (me.isSource(shape) || shape.intersectsRectangle(height));
  });
  if (checkShape(this.rotationShape)) {
    return mxEvent.ROTATION_HANDLE;
  }
  if (checkShape(this.labelShape)) {
    return mxEvent.LABEL_HANDLE;
  }
  if (null != this.sizers) {
    for (var i = 0;i < this.sizers.length;i++) {
      if (checkShape(this.sizers[i])) {
        return i;
      }
    }
  }
  if (null != this.customHandles && this.isCustomHandleEvent(me)) {
    for (i = this.customHandles.length - 1;0 <= i;i--) {
      if (checkShape(this.customHandles[i].shape)) {
        return mxEvent.CUSTOM_HANDLE - i;
      }
    }
  }
  return null;
};
mxVertexHandler.prototype.isCustomHandleEvent = function(me) {
  return true;
};
mxVertexHandler.prototype.mouseDown = function(index, me) {
  if (!me.isConsumed()) {
    if (this.graph.isEnabled()) {
      index = this.getHandleForEvent(me);
      if (null != index) {
        this.start(me.getGraphX(), me.getGraphY(), index);
        me.consume();
      }
    }
  }
};
mxVertexHandler.prototype.isLivePreviewBorder = function() {
  return null != this.state.shape && (null == this.state.shape.fill && null == this.state.shape.stroke);
};
mxVertexHandler.prototype.start = function(me, cell, index) {
  if (null != this.selectionBorder) {
    if (this.livePreviewActive = this.livePreview && 0 == this.graph.model.getChildCount(this.state.cell), this.inTolerance = true, this.childOffsetY = this.childOffsetX = 0, this.index = index, this.startX = me, this.startY = cell, this.index <= mxEvent.CUSTOM_HANDLE && this.isGhostPreview()) {
      this.ghostPreview = this.createGhostPreview();
    } else {
      me = this.state.view.graph.model;
      cell = me.getParent(this.state.cell);
      if (this.state.view.currentRoot != cell) {
        if (me.isVertex(cell) || me.isEdge(cell)) {
          this.parentState = this.state.view.graph.view.getState(cell);
        }
      }
      this.selectionBorder.node.style.display = index == mxEvent.ROTATION_HANDLE ? "inline" : "none";
      if (!this.livePreviewActive || this.isLivePreviewBorder()) {
        this.preview = this.createSelectionShape(this.bounds);
        if (mxClient.IS_SVG && 0 != Number(this.state.style[mxConstants.STYLE_ROTATION] || "0") || (null == this.state.text || this.state.text.node.parentNode != this.graph.container)) {
          this.preview.dialect = mxConstants.DIALECT_SVG;
          this.preview.init(this.graph.view.getOverlayPane());
        } else {
          this.preview.dialect = mxConstants.DIALECT_STRICTHTML;
          this.preview.init(this.graph.container);
        }
      }
      if (index == mxEvent.ROTATION_HANDLE) {
        cell = this.getRotationHandlePosition();
        me = cell.x - this.state.getCenterX();
        cell = cell.y - this.state.getCenterY();
        this.startAngle = 0 != me ? 180 * Math.atan(cell / me) / Math.PI + 90 : 0;
        this.startDist = Math.sqrt(me * me + cell * cell);
      }
      if (this.livePreviewActive) {
        this.hideSizers();
        if (index == mxEvent.ROTATION_HANDLE) {
          this.rotationShape.node.style.display = "";
        } else {
          if (index == mxEvent.LABEL_HANDLE) {
            this.labelShape.node.style.display = "";
          } else {
            if (null != this.sizers && null != this.sizers[index]) {
              this.sizers[index].node.style.display = "";
            } else {
              if (index <= mxEvent.CUSTOM_HANDLE) {
                if (null != this.customHandles) {
                  this.customHandles[mxEvent.CUSTOM_HANDLE - index].setVisible(true);
                }
              }
            }
          }
        }
        index = this.graph.getEdges(this.state.cell);
        this.edgeHandlers = [];
        for (me = 0;me < index.length;me++) {
          cell = this.graph.selectionCellsHandler.getHandler(index[me]);
          if (null != cell) {
            this.edgeHandlers.push(cell);
          }
        }
      }
    }
  }
};
mxVertexHandler.prototype.createGhostPreview = function() {
  var shape = this.graph.cellRenderer.createShape(this.state);
  shape.init(this.graph.view.getOverlayPane());
  shape.scale = this.state.view.scale;
  shape.bounds = this.bounds;
  shape.outline = true;
  return shape;
};
mxVertexHandler.prototype.setHandlesVisible = function(visible) {
  this.handlesVisible = visible;
  if (null != this.sizers) {
    for (var i = 0;i < this.sizers.length;i++) {
      this.sizers[i].node.style.display = visible ? "" : "none";
    }
  }
  if (null != this.customHandles) {
    for (i = 0;i < this.customHandles.length;i++) {
      this.customHandles[i].setVisible(visible);
    }
  }
};
mxVertexHandler.prototype.hideSizers = function() {
  this.setHandlesVisible(false);
};
mxVertexHandler.prototype.checkTolerance = function(me) {
  if (this.inTolerance) {
    if (null != this.startX) {
      if (null != this.startY) {
        if (mxEvent.isMouseEvent(me.getEvent()) || (Math.abs(me.getGraphX() - this.startX) > this.graph.tolerance || Math.abs(me.getGraphY() - this.startY) > this.graph.tolerance)) {
          this.inTolerance = false;
        }
      }
    }
  }
};
mxVertexHandler.prototype.updateHint = function(me) {
};
mxVertexHandler.prototype.removeHint = function() {
};
mxVertexHandler.prototype.roundAngle = function(angle) {
  return Math.round(10 * angle) / 10;
};
mxVertexHandler.prototype.roundLength = function(length) {
  return Math.round(100 * length) / 100;
};
mxVertexHandler.prototype.mouseMove = function(sender, me) {
  if (me.isConsumed() || null == this.index) {
    if (!this.graph.isMouseDown) {
      if (!(null == this.getHandleForEvent(me))) {
        me.consume(false);
      }
    }
  } else {
    this.checkTolerance(me);
    if (!this.inTolerance) {
      if (this.index <= mxEvent.CUSTOM_HANDLE) {
        if (null != this.customHandles) {
          this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);
          this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].active = true;
          if (null != this.ghostPreview) {
            this.ghostPreview.apply(this.state);
            this.ghostPreview.strokewidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;
            this.ghostPreview.isDashed = this.isSelectionDashed();
            this.ghostPreview.stroke = this.getSelectionColor();
            this.ghostPreview.redraw();
            if (null != this.selectionBounds) {
              this.selectionBorder.node.style.display = "none";
            }
          } else {
            if (this.movePreviewToFront) {
              this.moveToFront();
            }
            this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();
          }
        }
      } else {
        if (this.index == mxEvent.LABEL_HANDLE) {
          this.moveLabel(me);
        } else {
          if (this.index == mxEvent.ROTATION_HANDLE) {
            this.rotateVertex(me);
          } else {
            this.resizeVertex(me);
          }
          this.updateHint(me);
        }
      }
    }
    me.consume();
  }
};
mxVertexHandler.prototype.isGhostPreview = function() {
  return 0 < this.state.view.graph.model.getChildCount(this.state.cell);
};
mxVertexHandler.prototype.moveLabel = function(me) {
  var point = new mxPoint(me.getGraphX(), me.getGraphY());
  var tr = this.graph.view.translate;
  var scale = this.graph.view.scale;
  if (this.graph.isGridEnabledEvent(me.getEvent())) {
    point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
    point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
  }
  this.moveSizerTo(this.sizers[null != this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1], point.x, point.y);
};
mxVertexHandler.prototype.rotateVertex = function(me) {
  var point = new mxPoint(me.getGraphX(), me.getGraphY());
  var dx = this.state.x + this.state.width / 2 - point.x;
  var dy = this.state.y + this.state.height / 2 - point.y;
  this.currentAlpha = 0 != dx ? 180 * Math.atan(dy / dx) / Math.PI + 90 : 0 > dy ? 180 : 0;
  if (0 < dx) {
    this.currentAlpha -= 180;
  }
  this.currentAlpha -= this.startAngle;
  if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {
    dx = point.x - this.state.getCenterX();
    dy = point.y - this.state.getCenterY();
    me = Math.sqrt(dx * dx + dy * dy);
    raster = 2 > me - this.startDist ? 15 : 25 > me - this.startDist ? 5 : 1;
    this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
  } else {
    this.currentAlpha = this.roundAngle(this.currentAlpha);
  }
  this.selectionBorder.rotation = this.currentAlpha;
  this.selectionBorder.redraw();
  if (this.livePreviewActive) {
    this.redrawHandles();
  }
};
mxVertexHandler.prototype.resizeVertex = function(me) {
  var ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
  var alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  var tmp = new mxPoint(me.getGraphX(), me.getGraphY());
  var tr = this.graph.view.translate;
  var scale = this.graph.view.scale;
  var geo = Math.cos(-alpha);
  var max = Math.sin(-alpha);
  var overlap = tmp.x - this.startX;
  var dy = tmp.y - this.startY;
  tmp = max * overlap + geo * dy;
  overlap = geo * overlap - max * dy;
  dy = tmp;
  geo = this.graph.getCellGeometry(this.state.cell);
  this.unscaledBounds = this.union(geo, overlap / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new mxPoint(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));
  if (!geo.relative) {
    max = this.graph.getMaximumGraphBounds();
    if (null != max) {
      if (null != this.parentState) {
        max = mxRectangle.fromRectangle(max);
        max.x -= (this.parentState.x - tr.x * scale) / scale;
        max.y -= (this.parentState.y - tr.y * scale) / scale;
      }
    }
    if (this.graph.isConstrainChild(this.state.cell)) {
      tmp = this.graph.getCellContainmentArea(this.state.cell);
      if (null != tmp) {
        overlap = this.graph.getOverlap(this.state.cell);
        if (0 < overlap) {
          tmp = mxRectangle.fromRectangle(tmp);
          tmp.x -= tmp.width * overlap;
          tmp.y -= tmp.height * overlap;
          tmp.width += 2 * tmp.width * overlap;
          tmp.height += 2 * tmp.height * overlap;
        }
        if (null == max) {
          max = tmp;
        } else {
          max = mxRectangle.fromRectangle(max);
          max.intersect(tmp);
        }
      }
    }
    if (null != max) {
      if (this.unscaledBounds.x < max.x) {
        this.unscaledBounds.width -= max.x - this.unscaledBounds.x;
        this.unscaledBounds.x = max.x;
      }
      if (this.unscaledBounds.y < max.y) {
        this.unscaledBounds.height -= max.y - this.unscaledBounds.y;
        this.unscaledBounds.y = max.y;
      }
      if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {
        this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;
      }
      if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {
        this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;
      }
    }
  }
  tmp = this.bounds;
  this.bounds = new mxRectangle((null != this.parentState ? this.parentState.x : tr.x * scale) + this.unscaledBounds.x * scale, (null != this.parentState ? this.parentState.y : tr.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);
  if (geo.relative) {
    if (null != this.parentState) {
      this.bounds.x += this.state.x - this.parentState.x;
      this.bounds.y += this.state.y - this.parentState.y;
    }
  }
  geo = Math.cos(alpha);
  max = Math.sin(alpha);
  alpha = new mxPoint(this.bounds.getCenterX(), this.bounds.getCenterY());
  overlap = alpha.x - ct.x;
  dy = alpha.y - ct.y;
  ct = geo * overlap - max * dy - overlap;
  alpha = max * overlap + geo * dy - dy;
  overlap = this.bounds.x - this.state.x;
  dy = this.bounds.y - this.state.y;
  tr = geo * overlap - max * dy;
  geo = max * overlap + geo * dy;
  this.bounds.x += ct;
  this.bounds.y += alpha;
  this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + ct / scale);
  this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + alpha / scale);
  this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
  this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);
  if (this.graph.isCellCollapsed(this.state.cell) || 0 == ct && 0 == alpha) {
    this.childOffsetY = this.childOffsetX = 0;
  } else {
    this.childOffsetX = this.state.x - this.bounds.x + tr;
    this.childOffsetY = this.state.y - this.bounds.y + geo;
  }
  if (!tmp.equals(this.bounds)) {
    if (this.livePreviewActive) {
      this.updateLivePreview(me);
    }
    if (null != this.preview) {
      this.drawPreview();
    } else {
      this.updateParentHighlight();
    }
  }
};
mxVertexHandler.prototype.updateLivePreview = function(me) {
  var s = this.graph.view.scale;
  var t = this.graph.view.translate;
  me = this.state.clone();
  this.state.x = this.bounds.x;
  this.state.y = this.bounds.y;
  this.state.origin = new mxPoint(this.state.x / s - t.x, this.state.y / s - t.y);
  this.state.width = this.bounds.width;
  this.state.height = this.bounds.height;
  s = this.state.absoluteOffset;
  new mxPoint(s.x, s.y);
  this.state.absoluteOffset.x = 0;
  this.state.absoluteOffset.y = 0;
  s = this.graph.getCellGeometry(this.state.cell);
  if (null != s) {
    t = s.offset || this.EMPTY_POINT;
    if (!(null == t)) {
      if (!s.relative) {
        this.state.absoluteOffset.x = this.state.view.scale * t.x;
        this.state.absoluteOffset.y = this.state.view.scale * t.y;
      }
    }
    this.state.view.updateVertexLabelOffset(this.state);
  }
  this.state.view.graph.cellRenderer.redraw(this.state, true);
  this.state.view.invalidate(this.state.cell);
  this.state.invalid = false;
  this.state.view.validate();
  this.redrawHandles();
  if (this.movePreviewToFront) {
    this.moveToFront();
  }
  if (null != this.state.control) {
    if (null != this.state.control.node) {
      this.state.control.node.style.visibility = "hidden";
    }
  }
  this.state.setState(me);
};
mxVertexHandler.prototype.moveToFront = function() {
  if (null != this.state.text && (null != this.state.text.node && null != this.state.text.node.nextSibling) || null != this.state.shape && (null != this.state.shape.node && (null != this.state.shape.node.nextSibling && (null == this.state.text || this.state.shape.node.nextSibling != this.state.text.node)))) {
    if (null != this.state.shape) {
      if (null != this.state.shape.node) {
        this.state.shape.node.parentNode.appendChild(this.state.shape.node);
      }
    }
    if (null != this.state.text) {
      if (null != this.state.text.node) {
        this.state.text.node.parentNode.appendChild(this.state.text.node);
      }
    }
  }
};
mxVertexHandler.prototype.mouseUp = function(index, parent) {
  if (null != this.index && null != this.state) {
    var point = new mxPoint(parent.getGraphX(), parent.getGraphY());
    index = this.index;
    this.index = null;
    if (null == this.ghostPreview) {
      this.state.view.invalidate(this.state.cell, false, false);
      this.state.view.validate();
    }
    this.graph.getModel().beginUpdate();
    try {
      if (index <= mxEvent.CUSTOM_HANDLE) {
        if (null != this.customHandles) {
          var style = this.state.view.graph.getCellStyle(this.state.cell);
          this.customHandles[mxEvent.CUSTOM_HANDLE - index].active = false;
          this.customHandles[mxEvent.CUSTOM_HANDLE - index].execute(parent);
          if (null != this.customHandles) {
            if (null != this.customHandles[mxEvent.CUSTOM_HANDLE - index]) {
              this.state.style = style;
              this.customHandles[mxEvent.CUSTOM_HANDLE - index].positionChanged();
            }
          }
        }
      } else {
        if (index == mxEvent.ROTATION_HANDLE) {
          if (null != this.currentAlpha) {
            var delta = this.currentAlpha - (this.state.style[mxConstants.STYLE_ROTATION] || 0);
            if (0 != delta) {
              this.rotateCell(this.state.cell, delta);
            }
          } else {
            this.rotateClick();
          }
        } else {
          var gridEnabled = this.graph.isGridEnabledEvent(parent.getEvent());
          var alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
          var cos = Math.cos(-alpha);
          var sin = Math.sin(-alpha);
          var dx = point.x - this.startX;
          var dy = point.y - this.startY;
          style = sin * dx + cos * dy;
          dx = cos * dx - sin * dy;
          dy = style;
          var s = this.graph.view.scale;
          var recurse = this.isRecursiveResize(this.state, parent);
          this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(parent), recurse);
        }
      }
    } finally {
      this.graph.getModel().endUpdate();
    }
    parent.consume();
    this.reset();
    this.redrawHandles();
  }
};
mxVertexHandler.prototype.isRecursiveResize = function(state, parent) {
  return this.graph.isRecursiveResize(this.state);
};
mxVertexHandler.prototype.rotateClick = function() {
};
mxVertexHandler.prototype.rotateCell = function(cell, angle, parent) {
  if (0 != angle) {
    var model = this.graph.getModel();
    if (model.isVertex(cell) || model.isEdge(cell)) {
      if (!model.isEdge(cell)) {
        var geo = (this.graph.getCurrentCellStyle(cell)[mxConstants.STYLE_ROTATION] || 0) + angle;
        this.graph.setCellStyles(mxConstants.STYLE_ROTATION, geo, [cell]);
      }
      geo = this.graph.getCellGeometry(cell);
      if (null != geo) {
        var pgeo = this.graph.getCellGeometry(parent);
        if (!(null == pgeo)) {
          if (!model.isEdge(parent)) {
            geo = geo.clone();
            geo.rotate(angle, new mxPoint(pgeo.width / 2, pgeo.height / 2));
            model.setGeometry(cell, geo);
          }
        }
        if (model.isVertex(cell) && !geo.relative || model.isEdge(cell)) {
          parent = model.getChildCount(cell);
          for (geo = 0;geo < parent;geo++) {
            this.rotateCell(model.getChildAt(cell, geo), angle, cell);
          }
        }
      }
    }
  }
};
mxVertexHandler.prototype.reset = function() {
  if (null != this.sizers) {
    if (null != this.index) {
      if (null != this.sizers[this.index]) {
        if ("none" == this.sizers[this.index].node.style.display) {
          this.sizers[this.index].node.style.display = "";
        }
      }
    }
  }
  this.index = this.inTolerance = this.currentAlpha = null;
  if (null != this.preview) {
    this.preview.destroy();
    this.preview = null;
  }
  if (null != this.ghostPreview) {
    this.ghostPreview.destroy();
    this.ghostPreview = null;
  }
  if (this.livePreviewActive && null != this.sizers) {
    for (var i = 0;i < this.sizers.length;i++) {
      if (null != this.sizers[i]) {
        this.sizers[i].node.style.display = "";
      }
    }
    if (null != this.state.control) {
      if (null != this.state.control.node) {
        this.state.control.node.style.visibility = "";
      }
    }
  }
  if (null != this.customHandles) {
    for (i = 0;i < this.customHandles.length;i++) {
      if (this.customHandles[i].active) {
        this.customHandles[i].active = false;
        this.customHandles[i].reset();
      } else {
        this.customHandles[i].setVisible(true);
      }
    }
  }
  if (null != this.selectionBorder) {
    this.selectionBorder.node.style.display = "inline";
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.drawPreview();
  }
  this.removeHint();
  this.redrawHandles();
  this.edgeHandlers = null;
  this.handlesVisible = true;
  this.livePreviewActive = this.unscaledBounds = null;
};
mxVertexHandler.prototype.resizeCell = function(cell, geo, sin, alpha, gridEnabled, dx, recurse) {
  geo = this.graph.model.getGeometry(cell);
  if (null != geo) {
    if (alpha == mxEvent.LABEL_HANDLE) {
      alpha = -mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
      recurse = Math.cos(alpha);
      sin = Math.sin(alpha);
      alpha = this.graph.view.scale;
      recurse = mxUtils.getRotatedPoint(new mxPoint(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / alpha), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / alpha)), recurse, sin);
      geo = geo.clone();
      if (null == geo.offset) {
        geo.offset = recurse;
      } else {
        geo.offset.x += recurse.x;
        geo.offset.y += recurse.y;
      }
      this.graph.model.setGeometry(cell, geo);
    } else {
      if (null != this.unscaledBounds) {
        alpha = this.graph.view.scale;
        if (!(0 == this.childOffsetX && 0 == this.childOffsetY)) {
          this.moveChildren(cell, Math.round(this.childOffsetX / alpha), Math.round(this.childOffsetY / alpha));
        }
        this.graph.resizeCell(cell, this.unscaledBounds, recurse);
      }
    }
  }
};
mxVertexHandler.prototype.moveChildren = function(cell, x, y) {
  var model = this.graph.getModel();
  var childCount = model.getChildCount(cell);
  for (var i = 0;i < childCount;i++) {
    var child = model.getChildAt(cell, i);
    var geo = this.graph.getCellGeometry(child);
    if (null != geo) {
      geo = geo.clone();
      geo.translate(x, y);
      model.setGeometry(child, geo);
    }
  }
};
mxVertexHandler.prototype.union = function(bounds, dx, height, result, width, scale, y, aspect, constrained) {
  width = null != width ? width && this.graph.gridEnabled : this.graph.gridEnabled;
  if (this.singleSizer) {
    return result = bounds.x + bounds.width + dx, y = bounds.y + bounds.height + height, width && (result = this.graph.snap(result / scale) * scale, y = this.graph.snap(y / scale) * scale), scale = new mxRectangle(bounds.x, bounds.y, 0, 0), scale.add(new mxRectangle(result, y, 0, 0)), scale;
  }
  var w0 = bounds.width;
  var h0 = bounds.height;
  var left = bounds.x - y.x * scale;
  var right = left + w0;
  bounds = bounds.y - y.y * scale;
  var bottom = bounds + h0;
  var cx = left + w0 / 2;
  var u = bounds + h0 / 2;
  if (4 < result) {
    bottom += height;
    bottom = width ? this.graph.snap(bottom / scale) * scale : Math.round(bottom / scale) * scale;
  } else {
    if (3 > result) {
      bounds += height;
      bounds = width ? this.graph.snap(bounds / scale) * scale : Math.round(bounds / scale) * scale;
    }
  }
  if (0 == result || (3 == result || 5 == result)) {
    left += dx;
    left = width ? this.graph.snap(left / scale) * scale : Math.round(left / scale) * scale;
  } else {
    if (2 == result || (4 == result || 7 == result)) {
      right += dx;
      right = width ? this.graph.snap(right / scale) * scale : Math.round(right / scale) * scale;
    }
  }
  width = right - left;
  height = bottom - bounds;
  if (aspect) {
    aspect = this.graph.getCellGeometry(this.state.cell);
    if (null != aspect) {
      aspect = aspect.width / aspect.height;
      if (1 == result || (2 == result || (7 == result || 6 == result))) {
        width = height * aspect;
      } else {
        height = width / aspect;
      }
      if (0 == result) {
        left = right - width;
        bounds = bottom - height;
      }
    }
  }
  if (constrained) {
    width += width - w0;
    height += height - h0;
    left += cx - (left + width / 2);
    bounds += u - (bounds + height / 2);
  }
  if (0 > width) {
    left += width;
    width = Math.abs(width);
  }
  if (0 > height) {
    bounds += height;
    height = Math.abs(height);
  }
  result = new mxRectangle(left + y.x * scale, bounds + y.y * scale, width, height);
  if (null != this.minBounds) {
    result.width = Math.max(result.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - result.x));
    result.height = Math.max(result.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - result.y));
  }
  return result;
};
mxVertexHandler.prototype.redraw = function(state) {
  this.selectionBounds = this.getSelectionBounds(this.state);
  this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
  this.drawPreview();
  if (!state) {
    this.redrawHandles();
  }
};
mxVertexHandler.prototype.getHandlePadding = function() {
  var result = new mxPoint(0, 0);
  var tol = this.tolerance;
  if (null != this.sizers) {
    if (0 < this.sizers.length) {
      if (null != this.sizers[0]) {
        if (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol) {
          tol /= 2;
          result.x = this.sizers[0].bounds.width + tol;
          result.y = this.sizers[0].bounds.height + tol;
        }
      }
    }
  }
  return result;
};
mxVertexHandler.prototype.getSizerBounds = function() {
  return this.bounds;
};
mxVertexHandler.prototype.redrawHandles = function() {
  var s = this.getSizerBounds();
  var r = this.tolerance;
  this.verticalOffset = this.horizontalOffset = 0;
  if (null != this.customHandles) {
    for (var i = 0;i < this.customHandles.length;i++) {
      var cx = this.customHandles[i].shape.node.style.display;
      this.customHandles[i].redraw();
      this.customHandles[i].shape.node.style.display = cx;
      this.customHandles[i].shape.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
    }
  }
  if (null != this.sizers && (0 < this.sizers.length && null != this.sizers[0])) {
    if (null == this.index && (this.manageSizers && 8 <= this.sizers.length)) {
      i = this.getHandlePadding();
      this.horizontalOffset = i.x;
      this.verticalOffset = i.y;
      if (0 != this.horizontalOffset || 0 != this.verticalOffset) {
        s = new mxRectangle(s.x, s.y, s.width, s.height);
        s.x -= this.horizontalOffset / 2;
        s.width += this.horizontalOffset;
        s.y -= this.verticalOffset / 2;
        s.height += this.verticalOffset;
      }
      if (8 <= this.sizers.length) {
        if (s.width < 2 * this.sizers[0].bounds.width + 2 * r || s.height < 2 * this.sizers[0].bounds.height + 2 * r) {
          this.sizers[0].node.style.display = "none";
          this.sizers[2].node.style.display = "none";
          this.sizers[5].node.style.display = "none";
          this.sizers[7].node.style.display = "none";
        } else {
          if (this.handlesVisible) {
            this.sizers[0].node.style.display = "";
            this.sizers[2].node.style.display = "";
            this.sizers[5].node.style.display = "";
            this.sizers[7].node.style.display = "";
          }
        }
      }
    }
    r = s.x + s.width;
    i = s.y + s.height;
    if (this.singleSizer) {
      this.moveSizerTo(this.sizers[0], r, i);
    } else {
      cx = s.x + s.width / 2;
      var cy = s.y + s.height / 2;
      if (8 <= this.sizers.length) {
        var crs = "nw-resize n-resize ne-resize e-resize se-resize s-resize sw-resize w-resize".split(" ");
        var alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
        var cos = Math.cos(alpha);
        var sin = Math.sin(alpha);
        alpha = Math.round(4 * alpha / Math.PI);
        var ct = new mxPoint(s.getCenterX(), s.getCenterY());
        var pt = mxUtils.getRotatedPoint(new mxPoint(s.x, s.y), cos, sin, ct);
        this.moveSizerTo(this.sizers[0], pt.x, pt.y);
        this.sizers[0].setCursor(crs[mxUtils.mod(0 + alpha, crs.length)]);
        pt.x = cx;
        pt.y = s.y;
        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[1], pt.x, pt.y);
        this.sizers[1].setCursor(crs[mxUtils.mod(1 + alpha, crs.length)]);
        pt.x = r;
        pt.y = s.y;
        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[2], pt.x, pt.y);
        this.sizers[2].setCursor(crs[mxUtils.mod(2 + alpha, crs.length)]);
        pt.x = s.x;
        pt.y = cy;
        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[3], pt.x, pt.y);
        this.sizers[3].setCursor(crs[mxUtils.mod(7 + alpha, crs.length)]);
        pt.x = r;
        pt.y = cy;
        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[4], pt.x, pt.y);
        this.sizers[4].setCursor(crs[mxUtils.mod(3 + alpha, crs.length)]);
        pt.x = s.x;
        pt.y = i;
        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[5], pt.x, pt.y);
        this.sizers[5].setCursor(crs[mxUtils.mod(6 + alpha, crs.length)]);
        pt.x = cx;
        pt.y = i;
        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[6], pt.x, pt.y);
        this.sizers[6].setCursor(crs[mxUtils.mod(5 + alpha, crs.length)]);
        pt.x = r;
        pt.y = i;
        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[7], pt.x, pt.y);
        this.sizers[7].setCursor(crs[mxUtils.mod(4 + alpha, crs.length)]);
        pt.x = cx + this.state.absoluteOffset.x;
        pt.y = cy + this.state.absoluteOffset.y;
        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
        this.moveSizerTo(this.sizers[8], pt.x, pt.y);
      } else {
        if (2 <= this.state.width && 2 <= this.state.height) {
          this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);
        } else {
          this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
        }
      }
    }
  }
  if (null != this.rotationShape) {
    alpha = mxUtils.toRadians(null != this.currentAlpha ? this.currentAlpha : this.state.style[mxConstants.STYLE_ROTATION] || "0");
    cos = Math.cos(alpha);
    sin = Math.sin(alpha);
    ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
    pt = mxUtils.getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);
    if (null != this.rotationShape.node) {
      this.moveSizerTo(this.rotationShape, pt.x, pt.y);
      this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? "hidden" : "";
    }
  }
  if (null != this.selectionBorder) {
    this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
  }
  if (null != this.edgeHandlers) {
    for (i = 0;i < this.edgeHandlers.length;i++) {
      this.edgeHandlers[i].redraw();
    }
  }
};
mxVertexHandler.prototype.isCustomHandleVisible = function(handle) {
  return!this.graph.isEditing() && 1 == this.state.view.graph.getSelectionCount();
};
mxVertexHandler.prototype.getRotationHandlePosition = function() {
  return new mxPoint(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);
};
mxVertexHandler.prototype.isParentHighlightVisible = function() {
  return!this.graph.isCellSelected(this.graph.model.getParent(this.state.cell));
};
mxVertexHandler.prototype.destroyParentHighlight = function() {
  if (null != this.parentHighlight.state) {
    delete this.parentHighlight.state.parentHighlight;
    delete this.parentHighlight.state;
  }
  this.parentHighlight.destroy();
  this.parentHighlight = null;
};
mxVertexHandler.prototype.updateParentHighlight = function() {
  if (!this.isDestroyed()) {
    var bounds = this.isParentHighlightVisible();
    var cell = this.graph.model.getParent(this.state.cell);
    var pstate = this.graph.view.getState(cell);
    if (null != this.parentHighlight) {
      if (this.graph.model.isVertex(cell) && bounds) {
        bounds = this.parentHighlight.bounds;
        if (!(null == pstate)) {
          if (!(bounds.x == pstate.x && (bounds.y == pstate.y && (bounds.width == pstate.width && bounds.height == pstate.height)))) {
            this.parentHighlight.bounds = mxRectangle.fromRectangle(pstate);
            this.parentHighlight.redraw();
          }
        }
      } else {
        this.destroyParentHighlight();
      }
    } else {
      if (this.parentHighlightEnabled) {
        if (bounds) {
          if (this.graph.model.isVertex(cell)) {
            if (null != pstate) {
              if (null == pstate.parentHighlight) {
                this.parentHighlight = this.createParentHighlightShape(pstate);
                this.parentHighlight.dialect = mxConstants.DIALECT_SVG;
                this.parentHighlight.pointerEvents = false;
                this.parentHighlight.rotation = Number(pstate.style[mxConstants.STYLE_ROTATION] || "0");
                this.parentHighlight.init(this.graph.getView().getOverlayPane());
                this.parentHighlight.redraw();
                pstate.parentHighlight = this.parentHighlight;
                this.parentHighlight.state = pstate;
              }
            }
          }
        }
      }
    }
  }
};
mxVertexHandler.prototype.drawPreview = function() {
  if (null != this.preview) {
    this.preview.bounds = this.bounds;
    if (this.preview.node.parentNode == this.graph.container) {
      this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
      this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
    }
    this.preview.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
    this.preview.redraw();
  }
  this.selectionBorder.bounds = this.getSelectionBorderBounds();
  this.selectionBorder.redraw();
  this.updateParentHighlight();
};
mxVertexHandler.prototype.getSelectionBorderBounds = function() {
  return this.bounds;
};
mxVertexHandler.prototype.isDestroyed = function() {
  return null == this.selectionBorder;
};
mxVertexHandler.prototype.destroy = function() {
  if (null != this.escapeHandler) {
    this.state.view.graph.removeListener(this.escapeHandler);
    this.escapeHandler = null;
  }
  if (null != this.preview) {
    this.preview.destroy();
    this.preview = null;
  }
  if (null != this.ghostPreview) {
    this.ghostPreview.destroy();
    this.ghostPreview = null;
  }
  if (null != this.selectionBorder) {
    this.selectionBorder.destroy();
    this.selectionBorder = null;
  }
  if (null != this.parentHighlight) {
    this.destroyParentHighlight();
  }
  this.labelShape = null;
  this.removeHint();
  if (null != this.sizers) {
    for (var i = 0;i < this.sizers.length;i++) {
      this.sizers[i].destroy();
    }
    this.sizers = null;
  }
  if (null != this.customHandles) {
    for (i = 0;i < this.customHandles.length;i++) {
      this.customHandles[i].destroy();
    }
    this.customHandles = null;
  }
};
function mxEdgeHandler(state) {
  if (null != state) {
    if (null != state.shape) {
      this.state = state;
      this.init();
      this.escapeHandler = mxUtils.bind(this, function(flex, editor) {
        flex = null != this.index;
        this.reset();
        if (flex) {
          this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());
        }
      });
      this.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
    }
  }
}
mxEdgeHandler.prototype.graph = null;
mxEdgeHandler.prototype.state = null;
mxEdgeHandler.prototype.marker = null;
mxEdgeHandler.prototype.constraintHandler = null;
mxEdgeHandler.prototype.error = null;
mxEdgeHandler.prototype.shape = null;
mxEdgeHandler.prototype.bends = null;
mxEdgeHandler.prototype.labelShape = null;
mxEdgeHandler.prototype.cloneEnabled = true;
mxEdgeHandler.prototype.addEnabled = false;
mxEdgeHandler.prototype.removeEnabled = false;
mxEdgeHandler.prototype.dblClickRemoveEnabled = false;
mxEdgeHandler.prototype.mergeRemoveEnabled = false;
mxEdgeHandler.prototype.straightRemoveEnabled = false;
mxEdgeHandler.prototype.virtualBendsEnabled = false;
mxEdgeHandler.prototype.virtualBendOpacity = 20;
mxEdgeHandler.prototype.parentHighlightEnabled = false;
mxEdgeHandler.prototype.preferHtml = false;
mxEdgeHandler.prototype.allowHandleBoundsCheck = true;
mxEdgeHandler.prototype.snapToTerminals = false;
mxEdgeHandler.prototype.handleImage = null;
mxEdgeHandler.prototype.tolerance = 0;
mxEdgeHandler.prototype.outlineConnect = false;
mxEdgeHandler.prototype.manageLabelHandle = false;
mxEdgeHandler.prototype.init = function() {
  this.graph = this.state.view.graph;
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  this.points = [];
  this.abspoints = this.getSelectionPoints(this.state);
  this.shape = this.createSelectionShape(this.abspoints);
  this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
  this.shape.init(this.graph.getView().getOverlayPane());
  this.shape.svgStrokeTolerance = 0;
  this.shape.pointerEvents = false;
  mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
  if (this.graph.isCellMovable(this.state.cell)) {
    this.shape.setCursor(mxConstants.CURSOR_MOVABLE_EDGE);
  }
  this.preferHtml = null != this.state.text && this.state.text.node.parentNode == this.graph.container;
  if (!this.preferHtml) {
    var sourceState = this.state.getVisibleTerminalState(true);
    if (null != sourceState) {
      this.preferHtml = null != sourceState.text && sourceState.text.node.parentNode == this.graph.container;
    }
    if (!this.preferHtml) {
      sourceState = this.state.getVisibleTerminalState(false);
      if (null != sourceState) {
        this.preferHtml = null != sourceState.text && sourceState.text.node.parentNode == this.graph.container;
      }
    }
  }
  if (this.graph.isCellEditable(this.state.cell)) {
    if (this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells || 0 >= mxGraphHandler.prototype.maxCells) {
      this.bends = this.createBends();
      if (this.isVirtualBendsEnabled()) {
        this.virtualBends = this.createVirtualBends();
      }
    }
  }
  this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
  this.labelShape = this.createLabelHandleShape();
  this.initBend(this.labelShape);
  if (this.graph.isCellEditable(this.state.cell)) {
    this.labelShape.setCursor(mxConstants.CURSOR_LABEL_HANDLE);
    this.customHandles = this.createCustomHandles();
  }
  this.updateParentHighlight();
  this.redraw();
};
mxEdgeHandler.prototype.isParentHighlightVisible = mxVertexHandler.prototype.isParentHighlightVisible;
mxEdgeHandler.prototype.destroyParentHighlight = mxVertexHandler.prototype.destroyParentHighlight;
mxEdgeHandler.prototype.updateParentHighlight = mxVertexHandler.prototype.updateParentHighlight;
mxEdgeHandler.prototype.createCustomHandles = function() {
  return null;
};
mxEdgeHandler.prototype.isVirtualBendsEnabled = function(evt) {
  return this.virtualBendsEnabled && ((null == this.state.style[mxConstants.STYLE_EDGE] || (this.state.style[mxConstants.STYLE_EDGE] == mxConstants.NONE || 1 == this.state.style[mxConstants.STYLE_NOEDGESTYLE])) && "arrow" != mxUtils.getValue(this.state.style, mxConstants.STYLE_SHAPE, null));
};
mxEdgeHandler.prototype.isCellEnabled = function(cell) {
  return true;
};
mxEdgeHandler.prototype.isAddPointEvent = function(evt) {
  return mxEvent.isShiftDown(evt);
};
mxEdgeHandler.prototype.isRemovePointEvent = function(evt) {
  return mxEvent.isShiftDown(evt);
};
mxEdgeHandler.prototype.getSelectionPoints = function(state) {
  return state.absolutePoints;
};
mxEdgeHandler.prototype.createParentHighlightShape = function(bounds) {
  bounds = new mxRectangleShape(mxRectangle.fromRectangle(bounds), null, this.getSelectionColor());
  bounds.strokewidth = this.getSelectionStrokeWidth();
  bounds.isDashed = this.isSelectionDashed();
  return bounds;
};
mxEdgeHandler.prototype.createSelectionShape = function(shape) {
  shape = new this.state.shape.constructor;
  shape.outline = true;
  shape.apply(this.state);
  shape.isDashed = this.isSelectionDashed();
  shape.stroke = this.getSelectionColor();
  shape.isShadow = false;
  return shape;
};
mxEdgeHandler.prototype.getSelectionColor = function() {
  return this.graph.isCellEditable(this.state.cell) ? mxConstants.EDGE_SELECTION_COLOR : mxConstants.LOCKED_HANDLE_FILLCOLOR;
};
mxEdgeHandler.prototype.getSelectionStrokeWidth = function() {
  return mxConstants.EDGE_SELECTION_STROKEWIDTH;
};
mxEdgeHandler.prototype.isSelectionDashed = function() {
  return mxConstants.EDGE_SELECTION_DASHED;
};
mxEdgeHandler.prototype.isConnectableCell = function(cell) {
  return true;
};
mxEdgeHandler.prototype.getCellAt = function(x, y) {
  return this.outlineConnect ? null : this.graph.getCellAt(x, y);
};
mxEdgeHandler.prototype.createMarker = function() {
  var marker = new mxCellMarker(this.graph);
  var self = this;
  marker.getCell = function(me) {
    var cell = mxCellMarker.prototype.getCell.apply(this, arguments);
    if (!(cell != self.state.cell && null != cell)) {
      if (!(null == self.currentPoint)) {
        cell = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);
      }
    }
    if (null != cell && !this.graph.isCellConnectable(cell)) {
      var parent = this.graph.getModel().getParent(cell);
      if (this.graph.getModel().isVertex(parent)) {
        if (this.graph.isCellConnectable(parent)) {
          cell = parent;
        }
      }
    }
    parent = self.graph.getModel();
    if (this.graph.isSwimlane(cell) && (null != self.currentPoint && this.graph.hitsSwimlaneContent(cell, self.currentPoint.x, self.currentPoint.y)) || (!self.isConnectableCell(cell) || (cell == self.state.cell || (null != cell && (!self.graph.connectableEdges && parent.isEdge(cell)) || parent.isAncestor(self.state.cell, cell))))) {
      cell = null;
    }
    if (!this.graph.isCellConnectable(cell)) {
      cell = null;
    }
    return cell;
  };
  marker.isValidState = function(state) {
    var otherCell = self.graph.getModel();
    otherCell = self.graph.view.getTerminalPort(state, self.graph.view.getState(otherCell.getTerminal(self.state.cell, !self.isSource)), !self.isSource);
    otherCell = null != otherCell ? otherCell.cell : null;
    self.error = self.validateConnection(self.isSource ? state.cell : otherCell, self.isSource ? otherCell : state.cell);
    return null == self.error;
  };
  return marker;
};
mxEdgeHandler.prototype.validateConnection = function(source, target) {
  return this.graph.getEdgeValidationError(this.state.cell, source, target);
};
mxEdgeHandler.prototype.createBends = function() {
  var cell = this.state.cell;
  var bends = [];
  for (var i = 0;i < this.abspoints.length;i++) {
    if (this.isHandleVisible(i)) {
      var target = i == this.abspoints.length - 1;
      var terminal = 0 == i || target;
      if (terminal || this.graph.isCellBendable(cell)) {
        mxUtils.bind(this, function(index) {
          var bend = this.createHandleShape(index, null, index == this.abspoints.length - 1);
          this.initBend(bend, mxUtils.bind(this, mxUtils.bind(this, function() {
            if (this.dblClickRemoveEnabled) {
              this.removePoint(this.state, index);
            }
          })));
          if (this.isHandleEnabled(i)) {
            bend.setCursor(terminal ? mxConstants.CURSOR_TERMINAL_HANDLE : mxConstants.CURSOR_BEND_HANDLE);
          }
          bends.push(bend);
          if (!terminal) {
            this.points.push(new mxPoint(0, 0));
            bend.node.style.visibility = "hidden";
          }
        })(i);
      }
    }
  }
  return bends;
};
mxEdgeHandler.prototype.createVirtualBends = function() {
  var bends = [];
  if (this.graph.isCellBendable(this.state.cell)) {
    for (var i = 1;i < this.abspoints.length;i++) {
      mxUtils.bind(this, function(bend) {
        this.initBend(bend);
        bend.setCursor(mxConstants.CURSOR_VIRTUAL_BEND_HANDLE);
        bends.push(bend);
      })(this.createHandleShape());
    }
  }
  return bends;
};
mxEdgeHandler.prototype.isHandleEnabled = function(index) {
  return true;
};
mxEdgeHandler.prototype.isHandleVisible = function(index) {
  var source = this.state.getVisibleTerminalState(true);
  var target = this.state.getVisibleTerminalState(false);
  var geo = this.graph.getCellGeometry(this.state.cell);
  return(null != geo ? this.graph.view.getEdgeStyle(this.state, geo.points, source, target) : null) != mxEdgeStyle.EntityRelation || (0 == index || index == this.abspoints.length - 1);
};
mxEdgeHandler.prototype.createHandleShape = function(index) {
  if (null != this.handleImage) {
    return index = new mxImageShape(new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src), index.preserveImageAspect = false, index;
  }
  index = mxConstants.HANDLE_SIZE;
  if (this.preferHtml) {
    --index;
  }
  return new mxRectangleShape(new mxRectangle(0, 0, index, index), mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
mxEdgeHandler.prototype.createLabelHandleShape = function() {
  if (null != this.labelHandleImage) {
    var s = new mxImageShape(new mxRectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);
    s.preserveImageAspect = false;
    return s;
  }
  s = mxConstants.LABEL_HANDLE_SIZE;
  return new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants.LABEL_HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
mxEdgeHandler.prototype.initBend = function(bend, dblClick) {
  if (this.preferHtml) {
    bend.dialect = mxConstants.DIALECT_STRICTHTML;
    bend.init(this.graph.container);
  } else {
    bend.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
    bend.init(this.graph.getView().getOverlayPane());
  }
  mxEvent.redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);
  if (mxClient.IS_TOUCH) {
    bend.node.setAttribute("pointer-events", "none");
  }
};
mxEdgeHandler.prototype.getHandleForEvent = function(me) {
  var result = null;
  if (null != this.state) {
    var checkShape = function(shape) {
      if (null != shape && (me.isSource(shape) || shape.intersectsRectangle(r))) {
        var dist = me.getGraphX() - shape.bounds.getCenterX();
        shape = me.getGraphY() - shape.bounds.getCenterY();
        dist = dist * dist + shape * shape;
        if (null == minDist || dist <= minDist) {
          return minDist = dist, true;
        }
      }
      return false;
    };
    var i = mxEvent.isMouseEvent(me.getEvent()) ? 1 : this.tolerance;
    var r = this.allowHandleBoundsCheck && (mxClient.IS_IE || 0 < i) ? new mxRectangle(me.getGraphX() - i, me.getGraphY() - i, 2 * i, 2 * i) : null;
    var minDist = null;
    if (null != this.customHandles && this.isCustomHandleEvent(me)) {
      for (i = this.customHandles.length - 1;0 <= i;i--) {
        if (checkShape(this.customHandles[i].shape)) {
          return mxEvent.CUSTOM_HANDLE - i;
        }
      }
    }
    if (me.isSource(this.state.text) || checkShape(this.labelShape)) {
      result = mxEvent.LABEL_HANDLE;
    }
    if (null != this.bends) {
      for (i = 0;i < this.bends.length;i++) {
        if (checkShape(this.bends[i])) {
          result = i;
        }
      }
    }
    if (null != this.virtualBends && this.isAddVirtualBendEvent(me)) {
      for (i = 0;i < this.virtualBends.length;i++) {
        if (checkShape(this.virtualBends[i])) {
          result = mxEvent.VIRTUAL_HANDLE - i;
        }
      }
    }
  }
  return result;
};
mxEdgeHandler.prototype.isAddVirtualBendEvent = function(me) {
  return true;
};
mxEdgeHandler.prototype.isCustomHandleEvent = function(me) {
  return true;
};
mxEdgeHandler.prototype.mouseDown = function(handle, me) {
  if (this.graph.isCellEditable(this.state.cell)) {
    handle = this.getHandleForEvent(me);
    if (null != this.bends && null != this.bends[handle]) {
      var b = this.bends[handle].bounds;
      this.snapPoint = new mxPoint(b.getCenterX(), b.getCenterY());
    }
    if (this.addEnabled && (null == handle && this.isAddPointEvent(me.getEvent()))) {
      this.addPoint(this.state, me.getEvent());
      me.consume();
    } else {
      if (null != handle && (!me.isConsumed() && this.graph.isEnabled())) {
        if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {
          this.removePoint(this.state, handle);
        } else {
          if (handle != mxEvent.LABEL_HANDLE || this.graph.isLabelMovable(me.getCell())) {
            if (handle <= mxEvent.VIRTUAL_HANDLE) {
              mxUtils.setOpacity(this.virtualBends[mxEvent.VIRTUAL_HANDLE - handle].node, 100);
            }
            this.start(me.getX(), me.getY(), handle);
          }
        }
        me.consume();
      }
    }
  }
};
mxEdgeHandler.prototype.start = function(cell, y, index) {
  this.startX = cell;
  this.startY = y;
  this.isSource = null == this.bends ? false : 0 == index;
  this.isTarget = null == this.bends ? false : index == this.bends.length - 1;
  this.isLabel = index == mxEvent.LABEL_HANDLE;
  if (this.isSource || this.isTarget) {
    if (cell = this.state.cell, y = this.graph.model.getTerminal(cell, this.isSource), null == y && this.graph.isTerminalPointMovable(cell, this.isSource) || null != y && this.graph.isCellDisconnectable(cell, y, this.isSource)) {
      this.index = index;
    }
  } else {
    this.index = index;
  }
  if (this.index <= mxEvent.CUSTOM_HANDLE && (this.index > mxEvent.VIRTUAL_HANDLE && null != this.customHandles)) {
    for (index = 0;index < this.customHandles.length;index++) {
      if (index != mxEvent.CUSTOM_HANDLE - this.index) {
        this.customHandles[index].setVisible(false);
      }
    }
  }
};
mxEdgeHandler.prototype.clonePreviewState = function(terminal, point) {
  return this.state.clone();
};
mxEdgeHandler.prototype.getSnapToTerminalTolerance = function() {
  return 2;
};
mxEdgeHandler.prototype.updateHint = function(me, point) {
};
mxEdgeHandler.prototype.removeHint = function() {
};
mxEdgeHandler.prototype.roundLength = function(length) {
  return Math.round(length);
};
mxEdgeHandler.prototype.isSnapToTerminalsEvent = function(me) {
  return this.snapToTerminals && !mxEvent.isAltDown(me.getEvent());
};
mxEdgeHandler.prototype.getPointForEvent = function(me) {
  var view = this.graph.getView();
  var scale = view.scale;
  var point = new mxPoint(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);
  var tt = this.getSnapToTerminalTolerance();
  var f = false;
  var g = false;
  if (0 < tt && this.isSnapToTerminalsEvent(me)) {
    var snapToTerminal = function(x) {
      if (null != x) {
        snapToPoint.call(this, new mxPoint(view.getRoutingCenterX(x), view.getRoutingCenterY(x)));
      }
    };
    var snapToPoint = function(y) {
      if (null != y) {
        var x = y.x;
        if (Math.abs(point.x - x) < tt) {
          point.x = x;
          f = true;
        }
        y = y.y;
        if (Math.abs(point.y - y) < tt) {
          point.y = y;
          g = true;
        }
      }
    };
    snapToTerminal.call(this, this.state.getVisibleTerminalState(true));
    snapToTerminal.call(this, this.state.getVisibleTerminalState(false));
    snapToTerminal = this.state.absolutePoints;
    if (null != snapToTerminal) {
      for (var i = 0;i < snapToTerminal.length;i++) {
        if (0 < i || !this.state.isFloatingTerminalPoint(true)) {
          if (i < snapToTerminal.length - 1 || !this.state.isFloatingTerminalPoint(false)) {
            snapToPoint.call(this, this.state.absolutePoints[i]);
          }
        }
      }
    }
  }
  if (this.graph.isGridEnabledEvent(me.getEvent())) {
    me = view.translate;
    if (!f) {
      point.x = (this.graph.snap(point.x / scale - me.x) + me.x) * scale;
    }
    if (!g) {
      point.y = (this.graph.snap(point.y / scale - me.y) + me.y) * scale;
    }
  }
  return point;
};
mxEdgeHandler.prototype.getPreviewTerminalState = function(me) {
  this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);
  if (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint) {
    return null != this.marker.highlight && (null != this.marker.highlight.state && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) ? "transparent" != this.marker.highlight.shape.stroke && (this.marker.highlight.shape.stroke = "transparent", this.marker.highlight.repaint()) : this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent"), me = this.graph.getModel(), me = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(me.getTerminal(this.state.cell,
    !this.isSource)), !this.isSource), me = null != me ? me.cell : null, this.error = this.validateConnection(this.isSource ? this.constraintHandler.currentFocus.cell : me, this.isSource ? me : this.constraintHandler.currentFocus.cell), me = null, null == this.error && (me = this.constraintHandler.currentFocus), (null != this.error || null != me && !this.isCellEnabled(me.cell)) && this.constraintHandler.reset(), me;
  }
  if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
    return this.marker.reset(), null;
  }
  this.marker.process(me);
  me = this.marker.getValidState();
  if (!(null == me)) {
    if (!this.isCellEnabled(me.cell)) {
      this.constraintHandler.reset();
      this.marker.reset();
    }
  }
  return this.marker.getValidState();
};
mxEdgeHandler.prototype.getPreviewPoints = function(pt, me) {
  var points = this.graph.getCellGeometry(this.state.cell);
  points = null != points.points ? points.points.slice() : null;
  var point = new mxPoint(pt.x, pt.y);
  var result = null;
  if (this.isSource || this.isTarget) {
    if (this.graph.resetEdgesOnConnect) {
      points = null;
    }
  } else {
    if (this.convertPoint(point, false), null == points) {
      points = [point];
    } else {
      if (this.index <= mxEvent.VIRTUAL_HANDLE) {
        points.splice(mxEvent.VIRTUAL_HANDLE - this.index, 0, point);
      }
      if (!this.isSource && !this.isTarget) {
        for (var abs = 0;abs < this.bends.length;abs++) {
          if (abs != this.index) {
            var idx = this.bends[abs];
            if (null != idx) {
              if (mxUtils.contains(idx.bounds, pt.x, pt.y)) {
                if (this.index <= mxEvent.VIRTUAL_HANDLE) {
                  points.splice(mxEvent.VIRTUAL_HANDLE - this.index, 1);
                } else {
                  points.splice(this.index - 1, 1);
                }
                result = points;
              }
            }
          }
        }
        if (null == result && (this.straightRemoveEnabled && (null == me || !mxEvent.isAltDown(me.getEvent())))) {
          me = this.graph.tolerance * this.graph.tolerance;
          abs = this.state.absolutePoints.slice();
          abs[this.index] = pt;
          var terminal = this.state.getVisibleTerminalState(true);
          if (null != terminal) {
            if (idx = this.graph.getConnectionConstraint(this.state, terminal, true), null == idx || null == this.graph.getConnectionPoint(terminal, idx)) {
              abs[0] = new mxPoint(terminal.view.getRoutingCenterX(terminal), terminal.view.getRoutingCenterY(terminal));
            }
          }
          terminal = this.state.getVisibleTerminalState(false);
          if (null != terminal) {
            if (idx = this.graph.getConnectionConstraint(this.state, terminal, false), null == idx || null == this.graph.getConnectionPoint(terminal, idx)) {
              abs[abs.length - 1] = new mxPoint(terminal.view.getRoutingCenterX(terminal), terminal.view.getRoutingCenterY(terminal));
            }
          }
          idx = this.index;
          if (0 < idx) {
            if (idx < abs.length - 1) {
              if (mxUtils.ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, pt.x, pt.y) < me) {
                points.splice(idx - 1, 1);
                result = points;
              }
            }
          }
        }
      }
      if (null == result) {
        if (this.index > mxEvent.VIRTUAL_HANDLE) {
          points[this.index - 1] = point;
        }
      }
    }
  }
  return null != result ? result : points;
};
mxEdgeHandler.prototype.isOutlineConnectEvent = function(me) {
  if (mxEvent.isShiftDown(me.getEvent()) && mxEvent.isAltDown(me.getEvent())) {
    return false;
  }
  var gridY = mxUtils.getOffset(this.graph.container);
  var evt = me.getEvent();
  var clientX = mxEvent.getClientX(evt);
  evt = mxEvent.getClientY(evt);
  var doc = document.documentElement;
  var gridX = this.currentPoint.x - this.graph.container.scrollLeft + gridY.x - ((window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0));
  gridY = this.currentPoint.y - this.graph.container.scrollTop + gridY.y - ((window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0));
  return this.outlineConnect && (mxEvent.isShiftDown(me.getEvent()) && !mxEvent.isAltDown(me.getEvent()) || (me.isSource(this.marker.highlight.shape) || (!mxEvent.isShiftDown(me.getEvent()) && (mxEvent.isAltDown(me.getEvent()) && null != me.getState()) || (this.marker.highlight.isHighlightAt(clientX, evt) || (gridX != clientX || gridY != evt) && (null == me.getState() && this.marker.highlight.isHighlightAt(gridX, gridY))))));
};
mxEdgeHandler.prototype.updatePreviewState = function(edge, point, terminalState, me, outline) {
  var source = this.isSource ? terminalState : this.state.getVisibleTerminalState(true);
  var target = this.isTarget ? terminalState : this.state.getVisibleTerminalState(false);
  var sourceConstraint = this.graph.getConnectionConstraint(edge, source, true);
  var targetConstraint = this.graph.getConnectionConstraint(edge, target, false);
  var constraint = this.constraintHandler.currentConstraint;
  if (null == constraint) {
    if (outline) {
      if (null != terminalState) {
        if (me.isSource(this.marker.highlight.shape)) {
          point = new mxPoint(me.getGraphX(), me.getGraphY());
        }
        constraint = this.graph.getOutlineConstraint(point, terminalState, me);
        this.constraintHandler.setFocus(me, terminalState, this.isSource);
        this.constraintHandler.currentConstraint = constraint;
        this.constraintHandler.currentPoint = point;
      } else {
        constraint = new mxConnectionConstraint;
      }
    }
  }
  if (this.outlineConnect && (null != this.marker.highlight && null != this.marker.highlight.shape)) {
    var s = this.graph.view.scale;
    if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus) {
      this.marker.highlight.shape.stroke = outline ? mxConstants.OUTLINE_HIGHLIGHT_COLOR : "transparent";
      this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
      this.marker.highlight.repaint();
    } else {
      if (this.marker.hasValidState()) {
        this.marker.highlight.shape.stroke = this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState() ? "transparent" : mxConstants.DEFAULT_VALID_COLOR;
        this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / s / s;
        this.marker.highlight.repaint();
      }
    }
  }
  if (this.isSource) {
    sourceConstraint = constraint;
  } else {
    if (this.isTarget) {
      targetConstraint = constraint;
    }
  }
  if (this.isSource || this.isTarget) {
    if (null != constraint && null != constraint.point) {
      edge.style[this.isSource ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X] = constraint.point.x;
      edge.style[this.isSource ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y] = constraint.point.y;
    } else {
      delete edge.style[this.isSource ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
      delete edge.style[this.isSource ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
    }
  }
  edge.setVisibleTerminalState(source, true);
  edge.setVisibleTerminalState(target, false);
  if (!(this.isSource && null == source)) {
    edge.view.updateFixedTerminalPoint(edge, source, true, sourceConstraint);
  }
  if (!(this.isTarget && null == target)) {
    edge.view.updateFixedTerminalPoint(edge, target, false, targetConstraint);
  }
  if (this.isSource || this.isTarget) {
    if (null == terminalState) {
      edge.setAbsoluteTerminalPoint(point, this.isSource);
      if (null == this.marker.getMarkedState()) {
        this.error = this.graph.allowDanglingEdges ? null : "";
      }
    }
  }
  edge.view.updatePoints(edge, this.points, source, target);
  edge.view.updateFloatingTerminalPoints(edge, source, target);
};
mxEdgeHandler.prototype.mouseMove = function(terminalState, me) {
  if (null != this.index && null != this.marker) {
    this.currentPoint = this.getPointForEvent(me);
    this.error = null;
    if (null != this.snapPoint) {
      if (mxEvent.isShiftDown(me.getEvent())) {
        if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {
          if (null == this.constraintHandler.currentFocus) {
            if (this.constraintHandler.currentFocus != this.state) {
              if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {
                this.currentPoint.x = this.snapPoint.x;
              } else {
                this.currentPoint.y = this.snapPoint.y;
              }
            }
          }
        }
      }
    }
    if (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE) {
      if (null != this.customHandles) {
        this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);
        this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();
        if (null != this.shape) {
          if (null != this.shape.node) {
            this.shape.node.style.display = "none";
          }
        }
      }
    } else {
      if (this.isLabel) {
        this.label.x = this.currentPoint.x;
        this.label.y = this.currentPoint.y;
      } else {
        this.points = this.getPreviewPoints(this.currentPoint, me);
        terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;
        if (null != this.constraintHandler.currentConstraint && (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint)) {
          this.currentPoint = this.constraintHandler.currentPoint.clone();
        } else {
          if (this.outlineConnect) {
            var outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;
            if (outline) {
              terminalState = this.marker.highlight.state;
            } else {
              if (null != terminalState) {
                if (terminalState != me.getState()) {
                  if (this.graph.isCellConnectable(me.getCell())) {
                    if (null != this.marker.highlight.shape) {
                      this.marker.highlight.shape.stroke = "transparent";
                      this.marker.highlight.repaint();
                      terminalState = null;
                    }
                  }
                }
              }
            }
          }
        }
        if (!(null == terminalState)) {
          if (!this.isCellEnabled(terminalState.cell)) {
            terminalState = null;
            this.marker.reset();
          }
        }
        var clone = this.clonePreviewState(this.currentPoint, null != terminalState ? terminalState.cell : null);
        this.updatePreviewState(clone, this.currentPoint, terminalState, me, outline);
        this.setPreviewColor(null == this.error ? this.marker.validColor : this.marker.invalidColor);
        this.abspoints = clone.absolutePoints;
        this.active = true;
        this.updateHint(me, this.currentPoint);
      }
    }
    this.drawPreview();
    mxEvent.consume(me.getEvent());
    me.consume();
  } else {
    if (mxClient.IS_IE) {
      if (null != this.getHandleForEvent(me)) {
        me.consume(false);
      }
    }
  }
};
mxEdgeHandler.prototype.mouseUp = function(edge, parent) {
  if (null != this.index && null != this.marker) {
    if (null != this.shape) {
      if (null != this.shape.node) {
        this.shape.node.style.display = "";
      }
    }
    edge = this.state.cell;
    var index = this.index;
    this.index = null;
    if (parent.getX() != this.startX || parent.getY() != this.startY) {
      var clone = !this.graph.isIgnoreTerminalEvent(parent.getEvent()) && (this.graph.isCloneEvent(parent.getEvent()) && (this.cloneEnabled && this.graph.isCellsCloneable()));
      if (null != this.error) {
        if (0 < this.error.length) {
          this.graph.validationAlert(this.error);
        }
      } else {
        if (index <= mxEvent.CUSTOM_HANDLE && index > mxEvent.VIRTUAL_HANDLE) {
          if (null != this.customHandles) {
            var model = this.graph.getModel();
            model.beginUpdate();
            try {
              this.customHandles[mxEvent.CUSTOM_HANDLE - index].execute(parent);
              if (null != this.shape) {
                if (null != this.shape.node) {
                  this.shape.apply(this.state);
                  this.shape.redraw();
                }
              }
            } finally {
              model.endUpdate();
            }
          }
        } else {
          if (this.isLabel) {
            this.moveLabel(this.state, this.label.x, this.label.y);
          } else {
            if (this.isSource || this.isTarget) {
              if (index = null, null != this.constraintHandler.currentConstraint && (null != this.constraintHandler.currentFocus && (index = this.constraintHandler.currentFocus.cell)), null == index && (this.marker.hasValidState() && (null != this.marker.highlight && (null != this.marker.highlight.shape && ("transparent" != this.marker.highlight.shape.stroke && ("white" != this.marker.highlight.shape.stroke && (index = this.marker.validState.cell)))))), null != index) {
                model = this.graph.getModel();
                var child = model.getParent(edge);
                model.beginUpdate();
                try {
                  if (clone) {
                    var pt = model.getGeometry(edge);
                    clone = this.graph.cloneCell(edge);
                    model.add(child, clone, model.getChildCount(child));
                    if (null != pt) {
                      pt = pt.clone();
                      model.setGeometry(clone, pt);
                    }
                    var terminal = model.getTerminal(edge, !this.isSource);
                    this.graph.connectCell(clone, terminal, !this.isSource);
                    edge = clone;
                  }
                  edge = this.connect(edge, index, this.isSource, clone, parent);
                } finally {
                  model.endUpdate();
                }
              } else {
                if (this.graph.isAllowDanglingEdges()) {
                  pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];
                  pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);
                  pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);
                  terminal = this.graph.getView().getState(this.graph.getModel().getParent(edge));
                  if (null != terminal) {
                    pt.x -= terminal.origin.x;
                    pt.y -= terminal.origin.y;
                  }
                  pt.x -= this.graph.panDx / this.graph.view.scale;
                  pt.y -= this.graph.panDy / this.graph.view.scale;
                  edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);
                }
              }
            } else {
              if (this.active) {
                edge = this.changePoints(edge, this.points, clone);
              } else {
                this.graph.getView().invalidate(this.state.cell);
                this.graph.getView().validate(this.state.cell);
              }
            }
          }
        }
      }
    } else {
      if (this.graph.isToggleEvent(parent.getEvent())) {
        this.graph.selectCellForEvent(this.state.cell, parent.getEvent());
      }
    }
    if (null != this.marker) {
      this.reset();
      if (edge != this.state.cell) {
        this.graph.setSelectionCell(edge);
      }
    }
    parent.consume();
  }
};
mxEdgeHandler.prototype.reset = function() {
  if (this.active) {
    this.refresh();
  }
  this.snapPoint = this.points = this.label = this.index = this.error = null;
  this.active = this.isTarget = this.isSource = this.isLabel = false;
  if (this.livePreview && null != this.sizers) {
    for (var i = 0;i < this.sizers.length;i++) {
      if (null != this.sizers[i]) {
        this.sizers[i].node.style.display = "";
      }
    }
  }
  if (null != this.marker) {
    this.marker.reset();
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.reset();
  }
  if (null != this.customHandles) {
    for (i = 0;i < this.customHandles.length;i++) {
      this.customHandles[i].reset();
    }
  }
  this.setPreviewColor(mxConstants.EDGE_SELECTION_COLOR);
  this.removeHint();
  this.redraw();
};
mxEdgeHandler.prototype.setPreviewColor = function(color) {
  if (null != this.shape) {
    this.shape.stroke = color;
  }
};
mxEdgeHandler.prototype.convertPoint = function(point, gridEnabled) {
  var scale = this.graph.getView().getScale();
  var tr = this.graph.getView().getTranslate();
  if (gridEnabled) {
    point.x = this.graph.snap(point.x);
    point.y = this.graph.snap(point.y);
  }
  point.x = Math.round(point.x / scale - tr.x);
  point.y = Math.round(point.y / scale - tr.y);
  gridEnabled = this.graph.getView().getState(this.graph.getModel().getParent(this.state.cell));
  if (null != gridEnabled) {
    point.x -= gridEnabled.origin.x;
    point.y -= gridEnabled.origin.y;
  }
  return point;
};
mxEdgeHandler.prototype.moveLabel = function(edgeState, x, y) {
  var model = this.graph.getModel();
  var geometry = model.getGeometry(edgeState.cell);
  if (null != geometry) {
    var scale = this.graph.getView().scale;
    geometry = geometry.clone();
    if (geometry.relative) {
      var pt = this.graph.getView().getRelativePoint(edgeState, x, y);
      geometry.x = Math.round(1E4 * pt.x) / 1E4;
      geometry.y = Math.round(pt.y);
      geometry.offset = new mxPoint(0, 0);
      pt = this.graph.view.getPoint(edgeState, geometry);
      geometry.offset = new mxPoint(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));
    } else {
      var lastPushed = edgeState.absolutePoints;
      pt = lastPushed[0];
      lastPushed = lastPushed[lastPushed.length - 1];
      if (null != pt) {
        if (null != lastPushed) {
          geometry.offset = new mxPoint(Math.round((x - (pt.x + (lastPushed.x - pt.x) / 2)) / scale), Math.round((y - (pt.y + (lastPushed.y - pt.y) / 2)) / scale));
          geometry.x = 0;
          geometry.y = 0;
        }
      }
    }
    model.setGeometry(edgeState.cell, geometry);
  }
};
mxEdgeHandler.prototype.connect = function(edge, isConnect, isSource, model, me) {
  model = this.graph.getModel();
  model.getParent(edge);
  model.beginUpdate();
  try {
    var constraint = this.constraintHandler.currentConstraint;
    if (null == constraint) {
      constraint = new mxConnectionConstraint;
    }
    this.graph.connectCell(edge, isConnect, isSource, constraint);
  } finally {
    model.endUpdate();
  }
  return edge;
};
mxEdgeHandler.prototype.changeTerminalPoint = function(edge, point, isSource, clone) {
  var model = this.graph.getModel();
  model.beginUpdate();
  try {
    if (clone) {
      var parent = model.getParent(edge);
      var terminal = model.getTerminal(edge, !isSource);
      edge = this.graph.cloneCell(edge);
      model.add(parent, edge, model.getChildCount(parent));
      model.setTerminal(edge, terminal, !isSource);
    }
    var geo = model.getGeometry(edge);
    if (null != geo) {
      geo = geo.clone();
      geo.setTerminalPoint(point, isSource);
      model.setGeometry(edge, geo);
      this.graph.connectCell(edge, null, isSource, new mxConnectionConstraint);
    }
  } finally {
    model.endUpdate();
  }
  return edge;
};
mxEdgeHandler.prototype.changePoints = function(edge, points, clone) {
  var model = this.graph.getModel();
  model.beginUpdate();
  try {
    if (clone) {
      var parent = model.getParent(edge);
      var terminal = model.getTerminal(edge, true);
      var source = model.getTerminal(edge, false);
      edge = this.graph.cloneCell(edge);
      model.add(parent, edge, model.getChildCount(parent));
      model.setTerminal(edge, terminal, true);
      model.setTerminal(edge, source, false);
    }
    var geo = model.getGeometry(edge);
    if (null != geo) {
      geo = geo.clone();
      geo.points = points;
      model.setGeometry(edge, geo);
    }
  } finally {
    model.endUpdate();
  }
  return edge;
};
mxEdgeHandler.prototype.addPoint = function(state, evt) {
  var pt = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
  var gridEnabled = this.graph.isGridEnabledEvent(evt);
  this.convertPoint(pt, gridEnabled);
  this.addPointAt(state, pt.x, pt.y);
  mxEvent.consume(evt);
};
mxEdgeHandler.prototype.addPointAt = function(state, pt, s) {
  var geo = this.graph.getCellGeometry(state.cell);
  pt = new mxPoint(pt, s);
  if (null != geo) {
    geo = geo.clone();
    var pState = this.graph.view.translate;
    s = this.graph.view.scale;
    pState = new mxPoint(pState.x * s, pState.y * s);
    var cell = this.graph.model.getParent(this.state.cell);
    if (this.graph.model.isVertex(cell)) {
      pState = this.graph.view.getState(cell);
      pState = new mxPoint(pState.x, pState.y);
    }
    s = mxUtils.findNearestSegment(state, pt.x * s + pState.x, pt.y * s + pState.y);
    if (null == geo.points) {
      geo.points = [pt];
    } else {
      geo.points.splice(s, 0, pt);
    }
    this.graph.getModel().setGeometry(state.cell, geo);
    this.refresh();
    this.redraw();
  }
};
mxEdgeHandler.prototype.removePoint = function(state, index) {
  if (0 < index && index < this.abspoints.length - 1) {
    var geo = this.graph.getCellGeometry(this.state.cell);
    if (null != geo) {
      if (null != geo.points) {
        geo = geo.clone();
        geo.points.splice(index - 1, 1);
        this.graph.getModel().setGeometry(state.cell, geo);
        this.refresh();
        this.redraw();
      }
    }
  }
};
mxEdgeHandler.prototype.getHandleFillColor = function(isSource) {
  isSource = 0 == isSource;
  var cell = this.state.cell;
  var terminal = this.graph.getModel().getTerminal(cell, isSource);
  var color = mxConstants.HANDLE_FILLCOLOR;
  if (null != terminal && !this.graph.isCellDisconnectable(cell, terminal, isSource) || null == terminal && !this.graph.isTerminalPointMovable(cell, isSource)) {
    color = mxConstants.LOCKED_HANDLE_FILLCOLOR;
  } else {
    if (null != terminal) {
      if (this.graph.isCellDisconnectable(cell, terminal, isSource)) {
        color = mxConstants.CONNECT_HANDLE_FILLCOLOR;
      }
    }
  }
  return color;
};
mxEdgeHandler.prototype.redraw = function(state) {
  if (null != this.state) {
    this.abspoints = this.state.absolutePoints.slice();
    var pts = this.graph.getModel().getGeometry(this.state.cell);
    if (null != pts && (pts = pts.points, null != this.bends && (0 < this.bends.length && null != pts))) {
      if (null == this.points) {
        this.points = [];
      }
      for (var i = 1;i < this.bends.length - 1;i++) {
        if (null != this.bends[i]) {
          if (null != this.abspoints[i]) {
            this.points[i - 1] = pts[i - 1];
          }
        }
      }
    }
    this.drawPreview();
    if (!state) {
      this.redrawHandles();
    }
  }
};
mxEdgeHandler.prototype.redrawHandles = function() {
  var i = this.state.cell;
  var b = this.labelShape.bounds;
  this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
  this.labelShape.bounds = new mxRectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
  b = this.graph.getLabel(i);
  this.labelShape.visible = null != b && (0 < b.length && (this.graph.isCellEditable(this.state.cell) && this.graph.isLabelMovable(i)));
  if (null != this.bends && 0 < this.bends.length) {
    var last = this.abspoints.length - 1;
    i = this.abspoints[0];
    var pt = i.x;
    var y0 = i.y;
    b = this.bends[0].bounds;
    this.bends[0].bounds = new mxRectangle(Math.floor(pt - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);
    this.bends[0].fill = this.getHandleFillColor(0);
    this.bends[0].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[0].bounds);
    }
    last = this.abspoints[last];
    pt = last.x;
    y0 = last.y;
    var bn = this.bends.length - 1;
    b = this.bends[bn].bounds;
    this.bends[bn].bounds = new mxRectangle(Math.floor(pt - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);
    this.bends[bn].fill = this.getHandleFillColor(bn);
    this.bends[bn].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[bn].bounds);
    }
    this.redrawInnerBends(i, last);
  }
  if (null != this.abspoints && (null != this.virtualBends && 0 < this.virtualBends.length)) {
    last = this.abspoints[0];
    for (i = 0;i < this.virtualBends.length;i++) {
      if (null != this.virtualBends[i]) {
        if (null != this.abspoints[i + 1]) {
          pt = this.abspoints[i + 1];
          b = this.virtualBends[i];
          b.bounds = new mxRectangle(Math.floor(last.x + (pt.x - last.x) / 2 - b.bounds.width / 2), Math.floor(last.y + (pt.y - last.y) / 2 - b.bounds.height / 2), b.bounds.width, b.bounds.height);
          b.redraw();
          mxUtils.setOpacity(b.node, this.virtualBendOpacity);
          last = pt;
          if (this.manageLabelHandle) {
            this.checkLabelHandle(b.bounds);
          }
        }
      }
    }
  }
  if (null != this.labelShape) {
    this.labelShape.redraw();
  }
  if (null != this.customHandles) {
    for (i = 0;i < this.customHandles.length;i++) {
      b = this.customHandles[i].shape.node.style.display;
      this.customHandles[i].redraw();
      this.customHandles[i].shape.node.style.display = b;
      this.customHandles[i].shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
    }
  }
};
mxEdgeHandler.prototype.isCustomHandleVisible = function(handle) {
  return!this.graph.isEditing() && 1 == this.state.view.graph.getSelectionCount();
};
mxEdgeHandler.prototype.setHandlesVisible = function(visible) {
  if (null != this.bends) {
    for (var i = 0;i < this.bends.length;i++) {
      this.bends[i].node.style.display = visible ? "" : "none";
    }
  }
  if (null != this.virtualBends) {
    for (i = 0;i < this.virtualBends.length;i++) {
      this.virtualBends[i].node.style.display = visible ? "" : "none";
    }
  }
  if (null != this.labelShape) {
    this.labelShape.node.style.display = visible ? "" : "none";
  }
  if (null != this.customHandles) {
    for (i = 0;i < this.customHandles.length;i++) {
      this.customHandles[i].setVisible(visible);
    }
  }
};
mxEdgeHandler.prototype.redrawInnerBends = function(i, cx) {
  for (i = 1;i < this.bends.length - 1;i++) {
    if (null != this.bends[i]) {
      if (null != this.abspoints[i]) {
        cx = this.abspoints[i].x;
        var y = this.abspoints[i].y;
        var b = this.bends[i].bounds;
        this.bends[i].node.style.visibility = "visible";
        this.bends[i].bounds = new mxRectangle(Math.round(cx - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);
        if (this.manageLabelHandle) {
          this.checkLabelHandle(this.bends[i].bounds);
        } else {
          if (null == this.handleImage) {
            if (this.labelShape.visible) {
              if (mxUtils.intersects(this.bends[i].bounds, this.labelShape.bounds)) {
                w = mxConstants.HANDLE_SIZE + 3;
                h = mxConstants.HANDLE_SIZE + 3;
                this.bends[i].bounds = new mxRectangle(Math.round(cx - w / 2), Math.round(y - h / 2), w, h);
              }
            }
          }
        }
        this.bends[i].redraw();
      } else {
        this.bends[i].destroy();
        this.bends[i] = null;
      }
    }
  }
};
mxEdgeHandler.prototype.checkLabelHandle = function(state) {
  if (null != this.labelShape) {
    var box = this.labelShape.bounds;
    if (mxUtils.intersects(state, box)) {
      if (state.getCenterY() < box.getCenterY()) {
        box.y = state.y + state.height;
      } else {
        box.y = state.y - box.height;
      }
    }
  }
};
mxEdgeHandler.prototype.drawPreview = function() {
  try {
    if (this.isLabel) {
      var b = this.labelShape.bounds;
      var bounds = new mxRectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
      if (!this.labelShape.bounds.equals(bounds)) {
        this.labelShape.bounds = bounds;
        this.labelShape.redraw();
      }
    }
    if (!(null == this.shape)) {
      if (!mxUtils.equalPoints(this.shape.points, this.abspoints)) {
        this.shape.apply(this.state);
        this.shape.points = this.abspoints.slice();
        this.shape.scale = this.state.view.scale;
        this.shape.isDashed = this.isSelectionDashed();
        this.shape.stroke = this.getSelectionColor();
        this.shape.strokewidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
        this.shape.isShadow = false;
        this.shape.redraw();
      }
    }
    this.updateParentHighlight();
  } catch (c) {
  }
};
mxEdgeHandler.prototype.refresh = function() {
  if (null != this.state) {
    this.abspoints = this.getSelectionPoints(this.state);
    this.points = [];
    if (null != this.bends) {
      this.destroyBends(this.bends);
      this.bends = this.createBends();
    }
    if (null != this.virtualBends) {
      this.destroyBends(this.virtualBends);
      this.virtualBends = this.createVirtualBends();
    }
    if (null != this.customHandles) {
      this.destroyBends(this.customHandles);
      this.customHandles = this.createCustomHandles();
    }
    if (null != this.labelShape) {
      if (null != this.labelShape.node) {
        if (null != this.labelShape.node.parentNode) {
          this.labelShape.node.parentNode.appendChild(this.labelShape.node);
        }
      }
    }
  }
};
mxEdgeHandler.prototype.isDestroyed = function() {
  return null == this.shape;
};
mxEdgeHandler.prototype.destroyBends = function(bends) {
  if (null != bends) {
    for (var i = 0;i < bends.length;i++) {
      if (null != bends[i]) {
        bends[i].destroy();
      }
    }
  }
};
mxEdgeHandler.prototype.destroy = function() {
  if (null != this.escapeHandler) {
    this.state.view.graph.removeListener(this.escapeHandler);
    this.escapeHandler = null;
  }
  if (null != this.marker) {
    this.marker.destroy();
    this.marker = null;
  }
  if (null != this.shape) {
    this.shape.destroy();
    this.shape = null;
  }
  if (null != this.labelShape) {
    this.labelShape.destroy();
    this.labelShape = null;
  }
  if (null != this.constraintHandler) {
    this.constraintHandler.destroy();
    this.constraintHandler = null;
  }
  if (null != this.parentHighlight) {
    this.destroyParentHighlight();
  }
  this.destroyBends(this.virtualBends);
  this.virtualBends = null;
  this.destroyBends(this.customHandles);
  this.customHandles = null;
  this.destroyBends(this.bends);
  this.bends = null;
  this.removeHint();
};
function mxElbowEdgeHandler(state) {
  mxEdgeHandler.call(this, state);
}
mxUtils.extend(mxElbowEdgeHandler, mxEdgeHandler);
mxElbowEdgeHandler.prototype.flipEnabled = true;
mxElbowEdgeHandler.prototype.doubleClickOrientationResource = "none" != mxClient.language ? "doubleClickOrientation" : "";
mxElbowEdgeHandler.prototype.createBends = function() {
  var bends = [];
  var bend = this.createHandleShape(0);
  this.initBend(bend);
  bend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  bends.push(bend);
  bends.push(this.createVirtualBend(mxUtils.bind(this, function(evt) {
    if (!mxEvent.isConsumed(evt)) {
      if (this.flipEnabled) {
        this.graph.flipEdge(this.state.cell, evt);
        mxEvent.consume(evt);
      }
    }
  })));
  this.points.push(new mxPoint(0, 0));
  bend = this.createHandleShape(2, null, true);
  this.initBend(bend);
  bend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  bends.push(bend);
  return bends;
};
mxElbowEdgeHandler.prototype.createVirtualBend = function(dblClickHandler) {
  var bend = this.createHandleShape();
  this.initBend(bend, dblClickHandler);
  bend.setCursor(this.getCursorForBend());
  if (!this.graph.isCellBendable(this.state.cell)) {
    bend.node.style.display = "none";
  }
  return bend;
};
mxElbowEdgeHandler.prototype.getCursorForBend = function() {
  return this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.TopToBottom || (this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_TOPTOBOTTOM || (this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.ElbowConnector || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_ELBOW) && this.state.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL) ? "row-resize" : "col-resize";
};
mxElbowEdgeHandler.prototype.getTooltipForNode = function(source) {
  var cell = null;
  if (!(null == this.bends)) {
    if (!(null == this.bends[1])) {
      if (!(source != this.bends[1].node && source.parentNode != this.bends[1].node)) {
        cell = this.doubleClickOrientationResource;
        cell = mxResources.get(cell) || cell;
      }
    }
  }
  return cell;
};
mxElbowEdgeHandler.prototype.convertPoint = function(point, gridEnabled) {
  var scale = this.graph.getView().getScale();
  var tr = this.graph.getView().getTranslate();
  var origin = this.state.origin;
  if (gridEnabled) {
    point.x = this.graph.snap(point.x);
    point.y = this.graph.snap(point.y);
  }
  point.x = Math.round(point.x / scale - tr.x - origin.x);
  point.y = Math.round(point.y / scale - tr.y - origin.y);
  return point;
};
mxElbowEdgeHandler.prototype.redrawInnerBends = function(state, last) {
  var g = this.graph.getModel().getGeometry(this.state.cell);
  var pts = this.state.absolutePoints;
  var p0 = null;
  if (1 < pts.length) {
    state = pts[1];
    last = pts[pts.length - 2];
  } else {
    if (null != g.points) {
      if (0 < g.points.length) {
        p0 = pts[0];
      }
    }
  }
  p0 = null == p0 ? new mxPoint(state.x + (last.x - state.x) / 2, state.y + (last.y - state.y) / 2) : new mxPoint(this.graph.getView().scale * (p0.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale * (p0.y + this.graph.getView().translate.y + this.state.origin.y));
  last = this.bends[1].bounds;
  state = last.width;
  last = last.height;
  state = new mxRectangle(Math.round(p0.x - state / 2), Math.round(p0.y - last / 2), state, last);
  if (this.manageLabelHandle) {
    this.checkLabelHandle(state);
  } else {
    if (null == this.handleImage) {
      if (this.labelShape.visible) {
        if (mxUtils.intersects(state, this.labelShape.bounds)) {
          state = mxConstants.HANDLE_SIZE + 3;
          last = mxConstants.HANDLE_SIZE + 3;
          state = new mxRectangle(Math.floor(p0.x - state / 2), Math.floor(p0.y - last / 2), state, last);
        }
      }
    }
  }
  this.bends[1].bounds = state;
  this.bends[1].redraw();
  if (this.manageLabelHandle) {
    this.checkLabelHandle(this.bends[1].bounds);
  }
};
function mxEdgeSegmentHandler(state) {
  mxEdgeHandler.call(this, state);
}
mxUtils.extend(mxEdgeSegmentHandler, mxElbowEdgeHandler);
mxEdgeSegmentHandler.prototype.getCurrentPoints = function() {
  var pts = this.state.absolutePoints;
  if (null != pts) {
    var x = Math.max(1, this.graph.view.scale);
    if (2 == pts.length || 3 == pts.length && (Math.abs(pts[0].x - pts[1].x) < x && Math.abs(pts[1].x - pts[2].x) < x || Math.abs(pts[0].y - pts[1].y) < x && Math.abs(pts[1].y - pts[2].y) < x)) {
      x = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
      var y = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
      pts = [pts[0], new mxPoint(x, y), new mxPoint(x, y), pts[pts.length - 1]];
    }
  }
  return pts;
};
mxEdgeSegmentHandler.prototype.getPreviewPoints = function(point) {
  if (this.isSource || this.isTarget) {
    return mxElbowEdgeHandler.prototype.getPreviewPoints.apply(this, arguments);
  }
  var tmp = this.getCurrentPoints();
  var last = this.convertPoint(tmp[0].clone(), false);
  point = this.convertPoint(point.clone(), false);
  var result = [];
  for (var i = 1;i < tmp.length;i++) {
    var pt = this.convertPoint(tmp[i].clone(), false);
    if (i == this.index) {
      if (0 == Math.round(last.x - pt.x)) {
        last.x = point.x;
        pt.x = point.x;
      }
      if (0 == Math.round(last.y - pt.y)) {
        last.y = point.y;
        pt.y = point.y;
      }
    }
    if (i < tmp.length - 1) {
      result.push(pt);
    }
    last = pt;
  }
  if (1 == result.length) {
    tmp = this.state.getVisibleTerminalState(true);
    last = this.state.getVisibleTerminalState(false);
    pt = this.state.view.getScale();
    var first = this.state.view.getTranslate();
    i = result[0].x * pt + first.x;
    pt = result[0].y * pt + first.y;
    if (null != tmp && mxUtils.contains(tmp, i, pt) || null != last && mxUtils.contains(last, i, pt)) {
      result = [point, point];
    }
  }
  return result;
};
mxEdgeSegmentHandler.prototype.updatePreviewState = function(edge, point, terminalState, me) {
  mxEdgeHandler.prototype.updatePreviewState.apply(this, arguments);
  if (!this.isSource && !this.isTarget) {
    point = this.convertPoint(point.clone(), false);
    var pts = edge.absolutePoints;
    var source = pts[0];
    var target = pts[1];
    var result = [];
    for (var constraint = 2;constraint < pts.length;constraint++) {
      var p0 = pts[constraint];
      if (!(0 == Math.round(source.x - target.x) && 0 == Math.round(target.x - p0.x))) {
        if (!(0 == Math.round(source.y - target.y) && 0 == Math.round(target.y - p0.y))) {
          result.push(this.convertPoint(target.clone(), false));
        }
      }
      source = target;
      target = p0;
    }
    source = this.state.getVisibleTerminalState(true);
    target = this.state.getVisibleTerminalState(false);
    constraint = this.state.absolutePoints;
    if (0 == result.length && (0 == Math.round(pts[0].x - pts[pts.length - 1].x) || 0 == Math.round(pts[0].y - pts[pts.length - 1].y))) {
      result = [point, point];
    } else {
      if (5 == pts.length && (2 == result.length && (null != source && (null != target && (null != constraint && 0 == Math.round(constraint[0].x - constraint[constraint.length - 1].x)))))) {
        result = this.graph.getView();
        constraint = result.getScale();
        p0 = result.getTranslate();
        pts = result.getRoutingCenterY(source) / constraint - p0.y;
        var pt = this.graph.getConnectionConstraint(edge, source, true);
        if (null != pt) {
          pt = this.graph.getConnectionPoint(source, pt);
          if (null != pt) {
            this.convertPoint(pt, false);
            pts = pt.y;
          }
        }
        result = result.getRoutingCenterY(target) / constraint - p0.y;
        if (constraint = this.graph.getConnectionConstraint(edge, target, false)) {
          pt = this.graph.getConnectionPoint(target, constraint);
          if (null != pt) {
            this.convertPoint(pt, false);
            result = pt.y;
          }
        }
        result = [new mxPoint(point.x, pts), new mxPoint(point.x, result)];
      }
    }
    this.points = result;
    edge.view.updateFixedTerminalPoints(edge, source, target);
    edge.view.updatePoints(edge, this.points, source, target);
    edge.view.updateFloatingTerminalPoints(edge, source, target);
  }
};
mxEdgeSegmentHandler.prototype.connect = function(edge, isConnect, me, isClone, parent) {
  var model = this.graph.getModel();
  var geo = model.getGeometry(edge);
  var result = null;
  if (null != geo && (null != geo.points && 0 < geo.points.length)) {
    var pts = this.abspoints;
    var pt0 = pts[0];
    var pt1 = pts[1];
    result = [];
    for (var i = 2;i < pts.length;i++) {
      var pt2 = pts[i];
      if (!(0 == Math.round(pt0.x - pt1.x) && 0 == Math.round(pt1.x - pt2.x))) {
        if (!(0 == Math.round(pt0.y - pt1.y) && 0 == Math.round(pt1.y - pt2.y))) {
          result.push(this.convertPoint(pt1.clone(), false));
        }
      }
      pt0 = pt1;
      pt1 = pt2;
    }
  }
  model.beginUpdate();
  try {
    if (null != result) {
      geo = model.getGeometry(edge);
      if (null != geo) {
        geo = geo.clone();
        geo.points = result;
        model.setGeometry(edge, geo);
      }
    }
    edge = mxEdgeHandler.prototype.connect.apply(this, arguments);
  } finally {
    model.endUpdate();
  }
  return edge;
};
mxEdgeSegmentHandler.prototype.getTooltipForNode = function(source) {
  return null;
};
mxEdgeSegmentHandler.prototype.start = function(me, y, index) {
  mxEdgeHandler.prototype.start.apply(this, arguments);
  if (!(null == this.bends)) {
    if (!(null == this.bends[index])) {
      if (!this.isSource) {
        if (!this.isTarget) {
          mxUtils.setOpacity(this.bends[index].node, 100);
        }
      }
    }
  }
};
mxEdgeSegmentHandler.prototype.createBends = function() {
  var bends = [];
  var bend = this.createHandleShape(0);
  this.initBend(bend);
  bend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  bends.push(bend);
  var pts = this.getCurrentPoints();
  if (this.graph.isCellBendable(this.state.cell)) {
    if (null == this.points) {
      this.points = [];
    }
    for (var i = 0;i < pts.length - 1;i++) {
      bend = this.createVirtualBend();
      bends.push(bend);
      var horizontal = 0 == Math.round(pts[i].x - pts[i + 1].x);
      if (0 == Math.round(pts[i].y - pts[i + 1].y)) {
        if (i < pts.length - 2) {
          horizontal = 0 == Math.round(pts[i].x - pts[i + 2].x);
        }
      }
      bend.setCursor(horizontal ? "col-resize" : "row-resize");
      this.points.push(new mxPoint(0, 0));
    }
  }
  bend = this.createHandleShape(pts.length, null, true);
  this.initBend(bend);
  bend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
  bends.push(bend);
  return bends;
};
mxEdgeSegmentHandler.prototype.redraw = function() {
  this.refresh();
  mxEdgeHandler.prototype.redraw.apply(this, arguments);
};
mxEdgeSegmentHandler.prototype.redrawInnerBends = function(p0, bbox) {
  if (this.graph.isCellBendable(this.state.cell)) {
    var pts = this.getCurrentPoints();
    if (null != pts && 1 < pts.length) {
      var d = false;
      if (4 == pts.length && (0 == Math.round(pts[1].x - pts[2].x) && 0 == Math.round(pts[1].y - pts[2].y))) {
        if (d = true, 0 == Math.round(pts[0].y - pts[pts.length - 1].y)) {
          var i = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
          pts[1] = new mxPoint(i, pts[1].y);
          pts[2] = new mxPoint(i, pts[2].y);
        } else {
          i = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
          pts[1] = new mxPoint(pts[1].x, i);
          pts[2] = new mxPoint(pts[2].x, i);
        }
      }
      for (i = 0;i < pts.length - 1;i++) {
        if (null != this.bends[i + 1]) {
          p0 = pts[i];
          bbox = pts[i + 1];
          p0 = new mxPoint(p0.x + (bbox.x - p0.x) / 2, p0.y + (bbox.y - p0.y) / 2);
          bbox = this.bends[i + 1].bounds;
          this.bends[i + 1].bounds = new mxRectangle(Math.floor(p0.x - bbox.width / 2), Math.floor(p0.y - bbox.height / 2), bbox.width, bbox.height);
          this.bends[i + 1].redraw();
          if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[i + 1].bounds);
          }
        }
      }
      if (d) {
        mxUtils.setOpacity(this.bends[1].node, this.virtualBendOpacity);
        mxUtils.setOpacity(this.bends[3].node, this.virtualBendOpacity);
      }
    }
  }
};
function mxKeyHandler(graph, target) {
  if (null != graph) {
    this.graph = graph;
    this.target = target || document.documentElement;
    this.normalKeys = [];
    this.shiftKeys = [];
    this.controlKeys = [];
    this.controlShiftKeys = [];
    this.keydownHandler = mxUtils.bind(this, function(evt) {
      this.keyDown(evt);
    });
    mxEvent.addListener(this.target, "keydown", this.keydownHandler);
    if (mxClient.IS_IE) {
      mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
        this.destroy();
      }));
    }
  }
}
mxKeyHandler.prototype.graph = null;
mxKeyHandler.prototype.target = null;
mxKeyHandler.prototype.normalKeys = null;
mxKeyHandler.prototype.shiftKeys = null;
mxKeyHandler.prototype.controlKeys = null;
mxKeyHandler.prototype.controlShiftKeys = null;
mxKeyHandler.prototype.enabled = true;
mxKeyHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxKeyHandler.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxKeyHandler.prototype.bindKey = function(code, funct) {
  this.normalKeys[code] = funct;
};
mxKeyHandler.prototype.bindShiftKey = function(code, funct) {
  this.shiftKeys[code] = funct;
};
mxKeyHandler.prototype.bindControlKey = function(code, funct) {
  this.controlKeys[code] = funct;
};
mxKeyHandler.prototype.bindControlShiftKey = function(code, funct) {
  this.controlShiftKeys[code] = funct;
};
mxKeyHandler.prototype.isControlDown = function(evt) {
  return mxEvent.isControlDown(evt);
};
mxKeyHandler.prototype.getFunction = function(evt) {
  return null == evt || mxEvent.isAltDown(evt) ? null : this.isControlDown(evt) ? mxEvent.isShiftDown(evt) ? this.controlShiftKeys[evt.keyCode] : this.controlKeys[evt.keyCode] : mxEvent.isShiftDown(evt) ? this.shiftKeys[evt.keyCode] : this.normalKeys[evt.keyCode];
};
mxKeyHandler.prototype.isGraphEvent = function(evt) {
  var source = mxEvent.getSource(evt);
  return source == this.target || (source.parentNode == this.target || null != this.graph.cellEditor && this.graph.cellEditor.isEventSource(evt)) ? true : mxUtils.isAncestorNode(this.graph.container, source);
};
mxKeyHandler.prototype.keyDown = function(evt) {
  if (this.isEnabledForEvent(evt)) {
    if (27 == evt.keyCode) {
      this.escape(evt);
    } else {
      if (!this.isEventIgnored(evt)) {
        var boundFunction = this.getFunction(evt);
        if (null != boundFunction) {
          boundFunction(evt);
          mxEvent.consume(evt);
        }
      }
    }
  }
};
mxKeyHandler.prototype.isEnabledForEvent = function(evt) {
  return this.graph.isEnabled() && (!mxEvent.isConsumed(evt) && (this.isGraphEvent(evt) && this.isEnabled()));
};
mxKeyHandler.prototype.isEventIgnored = function(me) {
  return this.graph.isEditing();
};
mxKeyHandler.prototype.escape = function(evt) {
  if (this.graph.isEscapeEnabled()) {
    this.graph.escape(evt);
  }
};
mxKeyHandler.prototype.destroy = function() {
  if (null != this.target) {
    if (null != this.keydownHandler) {
      mxEvent.removeListener(this.target, "keydown", this.keydownHandler);
      this.keydownHandler = null;
    }
  }
  this.target = null;
};
function mxTooltipHandler(graph, delay) {
  if (null != graph) {
    this.graph = graph;
    this.delay = delay || 500;
    this.graph.addMouseListener(this);
  }
}
mxTooltipHandler.prototype.zIndex = 10005;
mxTooltipHandler.prototype.graph = null;
mxTooltipHandler.prototype.delay = null;
mxTooltipHandler.prototype.ignoreTouchEvents = true;
mxTooltipHandler.prototype.hideOnHover = false;
mxTooltipHandler.prototype.destroyed = false;
mxTooltipHandler.prototype.enabled = true;
mxTooltipHandler.prototype.isEnabled = function() {
  return this.enabled;
};
mxTooltipHandler.prototype.setEnabled = function(value) {
  this.enabled = value;
};
mxTooltipHandler.prototype.isHideOnHover = function() {
  return this.hideOnHover;
};
mxTooltipHandler.prototype.setHideOnHover = function(value) {
  this.hideOnHover = value;
};
mxTooltipHandler.prototype.init = function() {
  if (null != document.body) {
    this.div = document.createElement("div");
    this.div.className = "mxTooltip";
    this.div.style.visibility = "hidden";
    document.body.appendChild(this.div);
    mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(evt) {
      if ("A" != mxEvent.getSource(evt).nodeName) {
        this.hideTooltip();
      }
    }));
  }
};
mxTooltipHandler.prototype.getStateForEvent = function(me) {
  return me.getState();
};
mxTooltipHandler.prototype.mouseDown = function(cell, me) {
  this.reset(me, false);
  this.hideTooltip();
};
mxTooltipHandler.prototype.mouseMove = function(state, me) {
  if (me.getX() != this.lastX || me.getY() != this.lastY) {
    this.reset(me, true);
    state = this.getStateForEvent(me);
    if (this.isHideOnHover() || (state != this.state || me.getSource() != this.node && (!this.stateSource || null != state && this.stateSource == (me.isSource(state.shape) || !me.isSource(state.text))))) {
      this.hideTooltip();
    }
  }
  this.lastX = me.getX();
  this.lastY = me.getY();
};
mxTooltipHandler.prototype.mouseUp = function(sender, me) {
  this.reset(me, true);
  this.hideTooltip();
};
mxTooltipHandler.prototype.resetTimer = function() {
  if (null != this.thread) {
    window.clearTimeout(this.thread);
    this.thread = null;
  }
};
mxTooltipHandler.prototype.reset = function(me, restart, state) {
  if (!this.ignoreTouchEvents || mxEvent.isMouseEvent(me.getEvent())) {
    if (this.resetTimer(), state = null != state ? state : this.getStateForEvent(me), restart && (this.isEnabled() && (null != state && (null == this.div || "hidden" == this.div.style.visibility)))) {
      var node = me.getSource();
      var x = me.getX();
      var y = me.getY();
      var stateSource = me.isSource(state.shape) || me.isSource(state.text);
      this.thread = window.setTimeout(mxUtils.bind(this, function() {
        if (!this.graph.isEditing() && (!this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown)) {
          var tip = this.graph.getTooltip(state, node, x, y);
          this.show(tip, x, y);
          this.state = state;
          this.node = node;
          this.stateSource = stateSource;
        }
      }), this.delay);
    }
  }
};
mxTooltipHandler.prototype.hide = function() {
  this.resetTimer();
  this.hideTooltip();
};
mxTooltipHandler.prototype.hideTooltip = function() {
  if (null != this.div) {
    this.div.style.visibility = "hidden";
    this.div.innerText = "";
  }
};
mxTooltipHandler.prototype.show = function(tip, x, y) {
  if (!this.destroyed && (null != tip && 0 < tip.length)) {
    if (null == this.div) {
      this.init();
    }
    var origin = mxUtils.getScrollOrigin();
    this.div.style.zIndex = this.zIndex;
    this.div.style.left = x + origin.x + "px";
    this.div.style.top = y + mxConstants.TOOLTIP_VERTICAL_OFFSET + origin.y + "px";
    if (mxUtils.isNode(tip)) {
      this.div.innerText = "";
      this.div.appendChild(tip);
    } else {
      this.div.innerHTML = tip.replace(/\n/g, "<br>");
    }
    this.div.style.visibility = "";
    mxUtils.fit(this.div);
  }
};
mxTooltipHandler.prototype.destroy = function() {
  if (!this.destroyed) {
    this.graph.removeMouseListener(this);
    mxEvent.release(this.div);
    if (null != this.div) {
      if (null != this.div.parentNode) {
        this.div.parentNode.removeChild(this.div);
      }
    }
    this.destroyed = true;
    this.div = null;
  }
};
function mxCellTracker(graph, color, funct) {
  mxCellMarker.call(this, graph, color);
  this.graph.addMouseListener(this);
  if (null != funct) {
    this.getCell = funct;
  }
  if (mxClient.IS_IE) {
    mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
      this.destroy();
    }));
  }
}
mxUtils.extend(mxCellTracker, mxCellMarker);
mxCellTracker.prototype.mouseDown = function(cell, sender) {
};
mxCellTracker.prototype.mouseMove = function(sender, me) {
  if (this.isEnabled()) {
    this.process(me);
  }
};
mxCellTracker.prototype.mouseUp = function(sender, me) {
};
mxCellTracker.prototype.destroy = function() {
  if (!this.destroyed) {
    this.destroyed = true;
    this.graph.removeMouseListener(this);
    mxCellMarker.prototype.destroy.apply(this);
  }
};
function mxCellHighlight(graph, highlightColor, strokeWidth, dashed) {
  if (null != graph) {
    this.graph = graph;
    this.highlightColor = null != highlightColor ? highlightColor : mxConstants.DEFAULT_VALID_COLOR;
    this.strokeWidth = null != strokeWidth ? strokeWidth : mxConstants.HIGHLIGHT_STROKEWIDTH;
    this.dashed = null != dashed ? dashed : false;
    this.opacity = mxConstants.HIGHLIGHT_OPACITY;
    this.repaintHandler = mxUtils.bind(this, function() {
      if (null != this.state) {
        var tmp = this.graph.view.getState(this.state.cell);
        if (null == tmp) {
          this.hide();
        } else {
          this.state = tmp;
          this.repaint();
        }
      }
    });
    this.graph.getView().addListener(mxEvent.SCALE, this.repaintHandler);
    this.graph.getView().addListener(mxEvent.TRANSLATE, this.repaintHandler);
    this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler);
    this.graph.getModel().addListener(mxEvent.CHANGE, this.repaintHandler);
    this.resetHandler = mxUtils.bind(this, function() {
      this.hide();
    });
    this.graph.getView().addListener(mxEvent.DOWN, this.resetHandler);
    this.graph.getView().addListener(mxEvent.UP, this.resetHandler);
  }
}
mxCellHighlight.prototype.keepOnTop = false;
mxCellHighlight.prototype.graph = null;
mxCellHighlight.prototype.state = null;
mxCellHighlight.prototype.spacing = 2;
mxCellHighlight.prototype.resetHandler = null;
mxCellHighlight.prototype.setHighlightColor = function(color) {
  this.highlightColor = color;
  if (null != this.shape) {
    this.shape.stroke = color;
  }
};
mxCellHighlight.prototype.drawHighlight = function() {
  this.shape = this.createShape();
  this.repaint();
  if (!this.keepOnTop) {
    if (!(this.shape.node.parentNode.firstChild == this.shape.node)) {
      this.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);
    }
  }
};
mxCellHighlight.prototype.createShape = function() {
  var shape = this.graph.cellRenderer.createShape(this.state);
  shape.svgStrokeTolerance = this.graph.tolerance;
  shape.points = this.state.absolutePoints;
  shape.apply(this.state);
  shape.stroke = this.highlightColor;
  shape.opacity = this.opacity;
  shape.isDashed = this.dashed;
  shape.isShadow = false;
  shape.dialect = mxConstants.DIALECT_SVG;
  shape.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(shape.node, this.graph, this.state);
  if (this.graph.dialect != mxConstants.DIALECT_SVG) {
    shape.pointerEvents = false;
  } else {
    shape.svgPointerEvents = "stroke";
  }
  return shape;
};
mxCellHighlight.prototype.getStrokeWidth = function(state) {
  return this.strokeWidth;
};
mxCellHighlight.prototype.repaint = function() {
  if (null != this.state) {
    if (null != this.shape) {
      this.shape.scale = this.state.view.scale;
      if (this.graph.model.isEdge(this.state.cell)) {
        this.shape.strokewidth = this.getStrokeWidth();
        this.shape.points = this.state.absolutePoints;
        this.shape.outline = false;
      } else {
        this.shape.bounds = new mxRectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);
        this.shape.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
        this.shape.strokewidth = this.getStrokeWidth() / this.state.view.scale;
        this.shape.outline = true;
      }
      if (null != this.state.shape) {
        this.shape.setCursor(this.state.shape.getCursor());
      }
      this.shape.redraw();
    }
  }
};
mxCellHighlight.prototype.hide = function() {
  this.highlight(null);
};
mxCellHighlight.prototype.highlight = function(state) {
  if (this.state != state) {
    if (null != this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
    this.state = state;
    if (null != this.state) {
      this.drawHighlight();
    }
  }
};
mxCellHighlight.prototype.isHighlightAt = function(x, y) {
  var hit = false;
  if (null != this.shape && null != document.elementFromPoint) {
    for (x = document.elementFromPoint(x, y);null != x;) {
      if (x == this.shape.node) {
        hit = true;
        break;
      }
      x = x.parentNode;
    }
  }
  return hit;
};
mxCellHighlight.prototype.destroy = function() {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getView().removeListener(this.repaintHandler);
  this.graph.getModel().removeListener(this.repaintHandler);
  if (null != this.shape) {
    this.shape.destroy();
    this.shape = null;
  }
};
var mxCodecRegistry = {
  codecs : [],
  aliases : [],
  register : function(codec) {
    if (null != codec) {
      var name = codec.getName();
      mxCodecRegistry.codecs[name] = codec;
      var classname = mxUtils.getFunctionName(codec.template.constructor);
      if (classname != name) {
        mxCodecRegistry.addAlias(classname, name);
      }
    }
    return codec;
  },
  addAlias : function(classname, codecname) {
    mxCodecRegistry.aliases[classname] = codecname;
  },
  getCodec : function(ctor) {
    var codec = null;
    if (null != ctor) {
      codec = mxUtils.getFunctionName(ctor);
      var c = mxCodecRegistry.aliases[codec];
      if (null != c) {
        codec = c;
      }
      codec = mxCodecRegistry.codecs[codec];
      if (null == codec) {
        try {
          codec = new mxObjectCodec(new ctor);
          mxCodecRegistry.register(codec);
        } catch (d) {
        }
      }
    }
    return codec;
  }
};
function mxCodec(flex) {
  this.document = flex || mxUtils.createXmlDocument();
  this.objects = [];
}
mxCodec.allowlist = null;
mxCodec.prototype.document = null;
mxCodec.prototype.objects = null;
mxCodec.prototype.elements = null;
mxCodec.prototype.encodeDefaults = false;
mxCodec.prototype.putObject = function(id, obj) {
  return this.objects[id] = obj;
};
mxCodec.prototype.getObject = function(id) {
  var obj = null;
  if (null != id) {
    obj = this.objects[id];
    if (null == obj) {
      obj = this.lookup(id);
      if (null == obj) {
        id = this.getElementById(id);
        if (null != id) {
          obj = this.decode(id);
        }
      }
    }
  }
  return obj;
};
mxCodec.prototype.lookup = function(id) {
  return null;
};
mxCodec.prototype.getElementById = function(id) {
  this.updateElements();
  return this.elements[id];
};
mxCodec.prototype.updateElements = function() {
  if (null == this.elements) {
    this.elements = {};
    if (null != this.document.documentElement) {
      this.addElement(this.document.documentElement);
    }
  }
};
mxCodec.prototype.addElement = function(node) {
  if (node.nodeType == mxConstants.NODETYPE_ELEMENT) {
    var id = node.getAttribute("id");
    if (null != id) {
      if (null == this.elements[id]) {
        this.elements[id] = node;
      } else {
        if (this.elements[id] != node) {
          throw Error(id + ": Duplicate ID");
        }
      }
    }
  }
  for (node = node.firstChild;null != node;) {
    this.addElement(node);
    node = node.nextSibling;
  }
};
mxCodec.prototype.getId = function(cell) {
  var id = null;
  if (null != cell) {
    id = this.reference(cell);
    if (null == id) {
      if (cell instanceof mxCell) {
        id = cell.getId();
        if (null == id) {
          id = mxCellPath.create(cell);
          if (0 == id.length) {
            id = "root";
          }
        }
      }
    }
  }
  return id;
};
mxCodec.prototype.reference = function(cell) {
  return null;
};
mxCodec.prototype.encode = function(obj) {
  var node = null;
  if (null != obj && null != obj.constructor) {
    var enc = mxCodecRegistry.getCodec(obj.constructor);
    if (null != enc) {
      node = enc.encode(this, obj);
    } else {
      if (mxUtils.isNode(obj)) {
        node = mxUtils.importNode(this.document, obj, true);
      } else {
        mxLog.warn("mxCodec.encode: No codec for " + mxUtils.getFunctionName(obj.constructor));
      }
    }
  }
  return node;
};
mxCodec.prototype.decode = function(node, into) {
  this.updateElements();
  var obj = null;
  if (null != node) {
    if (node.nodeType == mxConstants.NODETYPE_ELEMENT) {
      obj = this.getConstructor(node.nodeName);
      obj = mxCodecRegistry.getCodec(obj);
      if (null != obj) {
        obj = obj.decode(this, node, into);
      } else {
        obj = node.cloneNode(true);
        obj.removeAttribute("as");
      }
    }
  }
  return obj;
};
mxCodec.prototype.getConstructor = function(cell) {
  var ctor = null;
  try {
    if (null == mxCodec.allowlist || 0 <= mxUtils.indexOf(mxCodec.allowlist, cell)) {
      ctor = window[cell];
    } else {
      if (null != window.console) {
        console.error("mxCodec.getConstructor: " + cell + " not allowed in mxCodec.allowlist");
      }
    }
  } catch (c) {
  }
  return ctor;
};
mxCodec.prototype.encodeCell = function(cell, node, includeChildren) {
  node.appendChild(this.encode(cell));
  if (null == includeChildren || includeChildren) {
    includeChildren = cell.getChildCount();
    for (var i = 0;i < includeChildren;i++) {
      this.encodeCell(cell.getChildAt(i), node);
    }
  }
};
mxCodec.prototype.isCellCodec = function(codec) {
  return null != codec && "function" == typeof codec.isCellCodec ? codec.isCellCodec() : false;
};
mxCodec.prototype.decodeCell = function(node, restoreStructures) {
  restoreStructures = null != restoreStructures ? restoreStructures : true;
  var decoder = null;
  if (null != node && node.nodeType == mxConstants.NODETYPE_ELEMENT) {
    decoder = mxCodecRegistry.getCodec(node.nodeName);
    if (!this.isCellCodec(decoder)) {
      for (var child = node.firstChild;null != child && !this.isCellCodec(decoder);) {
        decoder = mxCodecRegistry.getCodec(child.nodeName);
        child = child.nextSibling;
      }
    }
    if (!this.isCellCodec(decoder)) {
      decoder = mxCodecRegistry.getCodec(mxCell);
    }
    decoder = decoder.decode(this, node);
    if (restoreStructures) {
      this.insertIntoGraph(decoder);
    }
  }
  return decoder;
};
mxCodec.prototype.insertIntoGraph = function(cell) {
  var parent = cell.parent;
  var target = cell.getTerminal(true);
  var source = cell.getTerminal(false);
  cell.setTerminal(null, false);
  cell.setTerminal(null, true);
  cell.parent = null;
  if (null != parent) {
    if (parent == cell) {
      throw Error(parent.id + ": Self Reference");
    }
    parent.insert(cell);
  }
  if (null != target) {
    target.insertEdge(cell, true);
  }
  if (null != source) {
    source.insertEdge(cell, false);
  }
};
mxCodec.prototype.setAttribute = function(value, attribute, name) {
  if (null != attribute) {
    if (null != name) {
      value.setAttribute(attribute, name);
    }
  }
};
function mxObjectCodec(template, exclude, idrefs, mapping) {
  this.template = template;
  this.exclude = null != exclude ? exclude : [];
  this.idrefs = null != idrefs ? idrefs : [];
  this.mapping = null != mapping ? mapping : [];
  this.reverse = {};
  for (var i in this.mapping) {
    this.reverse[this.mapping[i]] = i;
  }
}
mxObjectCodec.allowEval = false;
mxObjectCodec.prototype.template = null;
mxObjectCodec.prototype.exclude = null;
mxObjectCodec.prototype.idrefs = null;
mxObjectCodec.prototype.mapping = null;
mxObjectCodec.prototype.reverse = null;
mxObjectCodec.prototype.getName = function() {
  return mxUtils.getFunctionName(this.template.constructor);
};
mxObjectCodec.prototype.cloneTemplate = function() {
  return new this.template.constructor;
};
mxObjectCodec.prototype.getFieldName = function(attributename) {
  if (null != attributename) {
    var mapped = this.reverse[attributename];
    if (null != mapped) {
      attributename = mapped;
    }
  }
  return attributename;
};
mxObjectCodec.prototype.getAttributeName = function(fieldname) {
  if (null != fieldname) {
    var mapped = this.mapping[fieldname];
    if (null != mapped) {
      fieldname = mapped;
    }
  }
  return fieldname;
};
mxObjectCodec.prototype.isExcluded = function(obj, attr, value, write) {
  return attr == mxObjectIdentity.FIELD_NAME || 0 <= mxUtils.indexOf(this.exclude, attr);
};
mxObjectCodec.prototype.isReference = function(obj, attr, value, isWrite) {
  return 0 <= mxUtils.indexOf(this.idrefs, attr);
};
mxObjectCodec.prototype.encode = function(enc, obj) {
  var node = enc.document.createElement(this.getName());
  obj = this.beforeEncode(enc, obj, node);
  this.encodeObject(enc, obj, node);
  return this.afterEncode(enc, obj, node);
};
mxObjectCodec.prototype.encodeObject = function(enc, obj, node) {
  enc.setAttribute(node, "id", enc.getId(obj));
  for (var i in obj) {
    var name = i;
    var value = obj[name];
    if (!(null == value)) {
      if (!this.isExcluded(obj, name, value, true)) {
        if (mxUtils.isInteger(name)) {
          name = null;
        }
        this.encodeValue(enc, obj, name, value, node);
      }
    }
  }
};
mxObjectCodec.prototype.encodeValue = function(enc, obj, name, value, node) {
  if (null != value) {
    if (this.isReference(obj, name, value, true)) {
      var defaultValue = enc.getId(value);
      if (null == defaultValue) {
        mxLog.warn("mxObjectCodec.encode: No ID for " + this.getName() + "." + name + "=" + value);
        return;
      }
      value = defaultValue;
    }
    defaultValue = this.template[name];
    if (null == name || (enc.encodeDefaults || defaultValue != value)) {
      name = this.getAttributeName(name);
      this.writeAttribute(enc, obj, name, value, node);
    }
  }
};
mxObjectCodec.prototype.writeAttribute = function(enc, obj, name, value, node) {
  if ("object" != typeof value) {
    this.writePrimitiveAttribute(enc, obj, name, value, node);
  } else {
    this.writeComplexAttribute(enc, obj, name, value, node);
  }
};
mxObjectCodec.prototype.writePrimitiveAttribute = function(enc, child, name, value, node) {
  value = this.convertAttributeToXml(enc, child, name, value, node);
  if (null == name) {
    child = enc.document.createElement("add");
    if ("function" == typeof value) {
      child.appendChild(enc.document.createTextNode(value));
    } else {
      enc.setAttribute(child, "value", value);
    }
    node.appendChild(child);
  } else {
    if ("function" != typeof value) {
      enc.setAttribute(node, name, value);
    }
  }
};
mxObjectCodec.prototype.writeComplexAttribute = function(enc, obj, name, value, node) {
  enc = enc.encode(value);
  if (null != enc) {
    if (null != name) {
      enc.setAttribute("as", name);
    }
    node.appendChild(enc);
  } else {
    mxLog.warn("mxObjectCodec.encode: No node for " + this.getName() + "." + name + ": " + value);
  }
};
mxObjectCodec.prototype.convertAttributeToXml = function(enc, name, willCollapse, value) {
  if (this.isBooleanAttribute(enc, name, willCollapse, value)) {
    value = 1 == value ? "1" : "0";
  }
  return value;
};
mxObjectCodec.prototype.isBooleanAttribute = function(enc, name, willCollapse, value) {
  return "undefined" == typeof value.length && (1 == value || 0 == value);
};
mxObjectCodec.prototype.convertAttributeFromXml = function(dec, attr, obj) {
  var value = attr.value;
  if (this.isNumericAttribute(dec, attr, obj)) {
    if (value = parseFloat(value), isNaN(value) || !isFinite(value)) {
      value = 0;
    }
  }
  return value;
};
mxObjectCodec.prototype.isNumericAttribute = function(dec, attr, obj) {
  return obj.constructor == mxGeometry && ("x" == attr.name || ("y" == attr.name || ("width" == attr.name || "height" == attr.name))) || (obj.constructor == mxPoint && ("x" == attr.name || "y" == attr.name) || mxUtils.isNumeric(attr.value));
};
mxObjectCodec.prototype.beforeEncode = function(enc, obj, node) {
  return obj;
};
mxObjectCodec.prototype.afterEncode = function(enc, obj, node) {
  return node;
};
mxObjectCodec.prototype.decode = function(dec, node, into) {
  var id = node.getAttribute("id");
  var obj = dec.objects[id];
  if (null == obj) {
    obj = into || this.cloneTemplate();
    if (null != id) {
      dec.putObject(id, obj);
    }
  }
  node = this.beforeDecode(dec, node, obj);
  this.decodeNode(dec, node, obj);
  return this.afterDecode(dec, node, obj);
};
mxObjectCodec.prototype.decodeNode = function(dec, node, obj) {
  if (null != node) {
    this.decodeAttributes(dec, node, obj);
    this.decodeChildren(dec, node, obj);
  }
};
mxObjectCodec.prototype.decodeAttributes = function(dec, node, obj) {
  node = node.attributes;
  if (null != node) {
    for (var i = 0;i < node.length;i++) {
      this.decodeAttribute(dec, node[i], obj);
    }
  }
};
mxObjectCodec.prototype.isIgnoredAttribute = function(dec, attr, obj) {
  return "as" == attr.nodeName || "id" == attr.nodeName;
};
mxObjectCodec.prototype.decodeAttribute = function(dec, value, obj) {
  if (!this.isIgnoredAttribute(dec, value, obj)) {
    var name = value.nodeName;
    value = this.convertAttributeFromXml(dec, value, obj);
    var fieldname = this.getFieldName(name);
    if (this.isReference(obj, fieldname, value, false)) {
      dec = dec.getObject(value);
      if (null == dec) {
        mxLog.warn("mxObjectCodec.decode: No object for " + this.getName() + "." + name + "=" + value);
        return;
      }
      value = dec;
    }
    if (!this.isExcluded(obj, name, value, false)) {
      obj[name] = value;
    }
  }
};
mxObjectCodec.prototype.decodeChildren = function(dec, node, obj) {
  for (node = node.firstChild;null != node;) {
    var tmp = node.nextSibling;
    if (!(node.nodeType != mxConstants.NODETYPE_ELEMENT)) {
      if (!this.processInclude(dec, node, obj)) {
        this.decodeChild(dec, node, obj);
      }
    }
    node = tmp;
  }
};
mxObjectCodec.prototype.decodeChild = function(dec, child, obj) {
  var fieldname = this.getFieldName(child.getAttribute("as"));
  if (null == fieldname || !this.isExcluded(obj, fieldname, child, false)) {
    var template = this.getFieldTemplate(obj, fieldname, child);
    if ("add" == child.nodeName) {
      dec = child.getAttribute("value");
      if (null == dec) {
        if (mxObjectCodec.allowEval) {
          dec = mxUtils.eval(mxUtils.getTextContent(child));
        }
      }
    } else {
      dec = dec.decode(child, template);
    }
    try {
      this.addObjectValue(obj, fieldname, dec, template);
    } catch (e) {
      throw Error(e.message + " for " + child.nodeName);
    }
  }
};
mxObjectCodec.prototype.getFieldTemplate = function(obj, fieldname, child) {
  obj = obj[fieldname];
  if (obj instanceof Array) {
    if (0 < obj.length) {
      obj = null;
    }
  }
  return obj;
};
mxObjectCodec.prototype.addObjectValue = function(obj, fieldname, value, template) {
  if (null != value) {
    if (value != template) {
      if (null != fieldname && 0 < fieldname.length) {
        obj[fieldname] = value;
      } else {
        obj.push(value);
      }
    }
  }
};
mxObjectCodec.prototype.processInclude = function(dec, name, into) {
  if ("include" == name.nodeName) {
    name = name.getAttribute("name");
    if (null != name) {
      try {
        var xml = mxUtils.load(name).getDocumentElement();
        if (null != xml) {
          dec.decode(xml, into);
        }
      } catch (e) {
      }
    }
    return true;
  }
  return false;
};
mxObjectCodec.prototype.beforeDecode = function(dec, node, obj) {
  return node;
};
mxObjectCodec.prototype.afterDecode = function(dec, node, obj) {
  return obj;
};
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxCell, ["children", "edges", "overlays", "mxTransient"], ["parent", "source", "target"]);
  codec.isCellCodec = function() {
    return true;
  };
  codec.isNumericAttribute = function(dec, attr, obj) {
    return "value" !== attr.nodeName && mxObjectCodec.prototype.isNumericAttribute.apply(this, arguments);
  };
  codec.isExcluded = function(obj, attr, value, isWrite) {
    return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || isWrite && ("value" == attr && mxUtils.isNode(value));
  };
  codec.afterEncode = function(enc, obj, node) {
    if (null != obj.value && mxUtils.isNode(obj.value)) {
      var tmp = node;
      node = mxUtils.importNode(enc.document, obj.value, true);
      node.appendChild(tmp);
      enc = tmp.getAttribute("id");
      node.setAttribute("id", enc);
      tmp.removeAttribute("id");
    }
    return node;
  };
  codec.beforeDecode = function(dec, node, obj) {
    var tmp = node.cloneNode(true);
    var attr = this.getName();
    if (node.nodeName != attr) {
      tmp = node.getElementsByTagName(attr)[0];
      if (null != tmp && tmp.parentNode == node) {
        mxUtils.removeWhitespace(tmp, true);
        mxUtils.removeWhitespace(tmp, false);
        tmp.parentNode.removeChild(tmp);
      } else {
        tmp = null;
      }
      obj.value = node.cloneNode(true);
      node = obj.value.getAttribute("id");
      if (null != node) {
        obj.setId(node);
        obj.value.removeAttribute("id");
      }
    } else {
      obj.setId(node.getAttribute("id"));
    }
    if (null != tmp) {
      for (node = 0;node < this.idrefs.length;node++) {
        attr = this.idrefs[node];
        var ref = tmp.getAttribute(attr);
        if (null != ref) {
          tmp.removeAttribute(attr);
          var object = dec.objects[ref] || dec.lookup(ref);
          if (null == object) {
            ref = dec.getElementById(ref);
            if (null != ref) {
              object = (mxCodecRegistry.codecs[ref.nodeName] || this).decode(dec, ref);
            }
          }
          obj[attr] = object;
        }
      }
    }
    return tmp;
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxGraphModel);
  codec.encodeObject = function(enc, obj, node) {
    var rootNode = enc.document.createElement("root");
    enc.encodeCell(obj.getRoot(), rootNode);
    node.appendChild(rootNode);
  };
  codec.decodeChild = function(dec, child, obj) {
    if ("root" == child.nodeName) {
      this.decodeRoot(dec, child, obj);
    } else {
      mxObjectCodec.prototype.decodeChild.apply(this, arguments);
    }
  };
  codec.decodeRoot = function(dec, node, model) {
    var rootCell = null;
    for (node = node.firstChild;null != node;) {
      var cell = dec.decodeCell(node);
      if (null != cell) {
        if (null == cell.getParent()) {
          rootCell = cell;
        }
      }
      node = node.nextSibling;
    }
    if (null != rootCell) {
      model.setRoot(rootCell);
    }
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxRootChange, ["model", "previous", "root"]);
  codec.afterEncode = function(enc, obj, node) {
    enc.encodeCell(obj.root, node);
    return node;
  };
  codec.beforeDecode = function(dec, node, obj) {
    if (null != node.firstChild && node.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
      node = node.cloneNode(true);
      var tmp = node.firstChild;
      obj.root = dec.decodeCell(tmp, false);
      obj = tmp.nextSibling;
      tmp.parentNode.removeChild(tmp);
      for (tmp = obj;null != tmp;) {
        obj = tmp.nextSibling;
        dec.decodeCell(tmp);
        tmp.parentNode.removeChild(tmp);
        tmp = obj;
      }
    }
    return node;
  };
  codec.afterDecode = function(dec, node, obj) {
    obj.previous = obj.root;
    return obj;
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxChildChange, ["model", "child", "previousIndex"], ["parent", "previous"]);
  codec.isReference = function(obj, attr, value, isWrite) {
    return "child" != attr || isWrite && !obj.model.contains(obj.previous) ? 0 <= mxUtils.indexOf(this.idrefs, attr) : true;
  };
  codec.isExcluded = function(obj, attr, value, isWrite) {
    return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || isWrite && (null != value && (("previous" == attr || "parent" == attr) && !obj.model.contains(value)));
  };
  codec.afterEncode = function(enc, obj, node) {
    if (this.isReference(obj, "child", obj.child, true)) {
      node.setAttribute("child", enc.getId(obj.child));
    } else {
      enc.encodeCell(obj.child, node);
    }
    return node;
  };
  codec.beforeDecode = function(dec, node, obj) {
    if (null != node.firstChild && node.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
      node = node.cloneNode(true);
      var tmp = node.firstChild;
      obj.child = dec.decodeCell(tmp, false);
      obj = tmp.nextSibling;
      tmp.parentNode.removeChild(tmp);
      for (tmp = obj;null != tmp;) {
        obj = tmp.nextSibling;
        if (tmp.nodeType == mxConstants.NODETYPE_ELEMENT) {
          var id = tmp.getAttribute("id");
          if (null == dec.lookup(id)) {
            dec.decodeCell(tmp);
          }
        }
        tmp.parentNode.removeChild(tmp);
        tmp = obj;
      }
    } else {
      tmp = node.getAttribute("child");
      obj.child = dec.getObject(tmp);
    }
    return node;
  };
  codec.afterDecode = function(dec, node, obj) {
    if (null != obj.child) {
      if (null != obj.child.parent) {
        if (null != obj.previous) {
          if (obj.child.parent != obj.previous) {
            obj.previous = obj.child.parent;
          }
        }
      }
      obj.child.parent = obj.previous;
      obj.previous = obj.parent;
      obj.previousIndex = obj.index;
    }
    return obj;
  };
  return codec;
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxTerminalChange, ["model", "previous"], ["cell", "terminal"]);
  codec.afterDecode = function(dec, node, obj) {
    obj.previous = obj.terminal;
    return obj;
  };
  return codec;
}());
var mxGenericChangeCodec = function(codec, variable) {
  codec = new mxObjectCodec(codec, ["model", "previous"], ["cell"]);
  codec.afterDecode = function(dec, node, obj) {
    if (mxUtils.isNode(obj.cell)) {
      obj.cell = dec.decodeCell(obj.cell, false);
    }
    obj.previous = obj[variable];
    return obj;
  };
  return codec;
};
mxCodecRegistry.register(mxGenericChangeCodec(new mxValueChange, "value"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxStyleChange, "style"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxGeometryChange, "geometry"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxCollapseChange, "collapsed"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxVisibleChange, "visible"));
mxCodecRegistry.register(mxGenericChangeCodec(new mxCellAttributeChange, "value"));
mxCodecRegistry.register(function() {
  return new mxObjectCodec(new mxGraph, "graphListeners eventListeners view container cellRenderer editor selection".split(" "));
}());
mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxGraphView);
  codec.encode = function(enc, view) {
    return this.encodeCell(enc, view, view.graph.getModel().getRoot());
  };
  codec.encodeCell = function(enc, view, cell) {
    var model = view.graph.getModel();
    var state = view.getState(cell);
    var value = model.getParent(cell);
    if (null == value || null != state) {
      var childCount = model.getChildCount(cell);
      var src = view.graph.getCellGeometry(cell);
      var name = null;
      if (value == model.getRoot()) {
        name = "layer";
      } else {
        if (null == value) {
          name = "graph";
        } else {
          if (model.isEdge(cell)) {
            name = "edge";
          } else {
            if (0 < childCount && null != src) {
              name = "group";
            } else {
              if (model.isVertex(cell)) {
                name = "vertex";
              }
            }
          }
        }
      }
      if (null != name) {
        var node = enc.document.createElement(name);
        if (null != view.graph.getLabel(cell)) {
          node.setAttribute("label", view.graph.getLabel(cell));
          if (view.graph.isHtmlLabel(cell)) {
            node.setAttribute("html", true);
          }
        }
        if (null == value) {
          var i = view.getGraphBounds();
          if (null != i) {
            node.setAttribute("x", Math.round(i.x));
            node.setAttribute("y", Math.round(i.y));
            node.setAttribute("width", Math.round(i.width));
            node.setAttribute("height", Math.round(i.height));
          }
          node.setAttribute("scale", view.scale);
        } else {
          if (null != state && null != src) {
            for (i in state.style) {
              value = state.style[i];
              if ("function" == typeof value) {
                if ("object" == typeof value) {
                  value = mxStyleRegistry.getName(value);
                }
              }
              if (null != value) {
                if ("function" != typeof value) {
                  if ("object" != typeof value) {
                    node.setAttribute(i, value);
                  }
                }
              }
            }
            value = state.absolutePoints;
            if (null != value && 0 < value.length) {
              src = Math.round(value[0].x) + "," + Math.round(value[0].y);
              for (i = 1;i < value.length;i++) {
                src += " " + Math.round(value[i].x) + "," + Math.round(value[i].y);
              }
              node.setAttribute("points", src);
            } else {
              node.setAttribute("x", Math.round(state.x));
              node.setAttribute("y", Math.round(state.y));
              node.setAttribute("width", Math.round(state.width));
              node.setAttribute("height", Math.round(state.height));
            }
            i = state.absoluteOffset;
            if (null != i) {
              if (0 != i.x) {
                node.setAttribute("dx", Math.round(i.x));
              }
              if (0 != i.y) {
                node.setAttribute("dy", Math.round(i.y));
              }
            }
          }
        }
        for (i = 0;i < childCount;i++) {
          state = this.encodeCell(enc, view, model.getChildAt(cell, i));
          if (null != state) {
            node.appendChild(state);
          }
        }
      }
    }
    return node;
  };
  return codec;
}());
var mxStylesheetCodec = mxCodecRegistry.register(function() {
  var codec = new mxObjectCodec(new mxStylesheet);
  codec.encode = function(enc, obj) {
    var node = enc.document.createElement(this.getName());
    for (var i in obj.styles) {
      var style = obj.styles[i];
      var styleNode = enc.document.createElement("add");
      if (null != i) {
        styleNode.setAttribute("as", i);
        for (var j in style) {
          var value = this.getStringValue(j, style[j]);
          if (null != value) {
            var entry = enc.document.createElement("add");
            entry.setAttribute("value", value);
            entry.setAttribute("as", j);
            styleNode.appendChild(entry);
          }
        }
        if (0 < styleNode.childNodes.length) {
          node.appendChild(styleNode);
        }
      }
    }
    return node;
  };
  codec.getStringValue = function(key, value) {
    key = typeof value;
    if ("function" == key) {
      value = mxStyleRegistry.getName(value);
    } else {
      if ("object" == key) {
        value = null;
      }
    }
    return value;
  };
  codec.decode = function(dec, node, obj) {
    obj = obj || new this.template.constructor;
    var id = node.getAttribute("id");
    if (null != id) {
      dec.objects[id] = obj;
    }
    for (node = node.firstChild;null != node;) {
      if (!this.processInclude(dec, node, obj) && ("add" == node.nodeName && (id = node.getAttribute("as"), null != id))) {
        var tmp = node.getAttribute("extend");
        var style = null != tmp ? mxUtils.clone(obj.styles[tmp]) : null;
        if (null == style) {
          if (null != tmp) {
            mxLog.warn("mxStylesheetCodec.decode: stylesheet " + tmp + " not found to extend");
          }
          style = {};
        }
        for (tmp = node.firstChild;null != tmp;) {
          if (tmp.nodeType == mxConstants.NODETYPE_ELEMENT) {
            var key = tmp.getAttribute("as");
            if ("add" == tmp.nodeName) {
              var value = mxUtils.getTextContent(tmp);
              if (null != value && (0 < value.length && mxStylesheetCodec.allowEval)) {
                value = mxUtils.eval(value);
              } else {
                value = tmp.getAttribute("value");
                if (mxUtils.isNumeric(value)) {
                  value = parseFloat(value);
                }
              }
              if (null != value) {
                style[key] = value;
              }
            } else {
              if ("remove" == tmp.nodeName) {
                delete style[key];
              }
            }
          }
          tmp = tmp.nextSibling;
        }
        obj.putCellStyle(id, style);
      }
      node = node.nextSibling;
    }
    return obj;
  };
  return codec;
}());
mxStylesheetCodec.allowEval = false;
